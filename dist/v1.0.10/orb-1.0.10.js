/**
 * orb v1.0.10, Pivot table javascript library.
 *
 * Copyright (c) 2014-2016 [object Object].
 *
 * @version v1.0.10
 * @link http://orbjs.net/
 * @license MIT
 */

/* global module, require, define, window, document, global, React */
/*jshint node: true, eqnull: true*/

'use strict';
! function(e) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.orb = e()
    }
}(function() {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    })({
        1: [function(_dereq_, module, exports) {

            module.exports.utils = _dereq_('./orb.utils');
            module.exports.pgrid = _dereq_('./orb.pgrid');
            module.exports.pgridwidget = _dereq_('./orb.ui.pgridwidget');
            module.exports.query = _dereq_('./orb.query');
            module.exports.export = _dereq_('./orb.export.excel');

        }, {
            "./orb.export.excel": 184,
            "./orb.pgrid": 186,
            "./orb.query": 187,
            "./orb.ui.pgridwidget": 193,
            "./orb.utils": 195
        }],
        2: [function(_dereq_, module, exports) {
            (function(process) {

                var emptyFunction = _dereq_('./emptyFunction');

                var EventListener = {

                    listen: function listen(target, eventType, callback) {
                        if (target.addEventListener) {
                            target.addEventListener(eventType, callback, false);
                            return {
                                remove: function remove() {
                                    target.removeEventListener(eventType, callback, false);
                                }
                            };
                        } else if (target.attachEvent) {
                            target.attachEvent('on' + eventType, callback);
                            return {
                                remove: function remove() {
                                    target.detachEvent('on' + eventType, callback);
                                }
                            };
                        }
                    },


                    capture: function capture(target, eventType, callback) {
                        if (target.addEventListener) {
                            target.addEventListener(eventType, callback, true);
                            return {
                                remove: function remove() {
                                    target.removeEventListener(eventType, callback, true);
                                }
                            };
                        } else {
                            if (process.env.NODE_ENV !== 'production') {
                                console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
                            }
                            return {
                                remove: emptyFunction
                            };
                        }
                    },

                    registerDefault: function registerDefault() {}
                };

                module.exports = EventListener;
            }).call(this, _dereq_('_process'))
        }, {
            "./emptyFunction": 9,
            "_process": 28
        }],
        3: [function(_dereq_, module, exports) {

            var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

            var ExecutionEnvironment = {

                canUseDOM: canUseDOM,

                canUseWorkers: typeof Worker !== 'undefined',

                canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

                canUseViewport: canUseDOM && !!window.screen,

                isInWorker: !canUseDOM // For now, this is true - might change in the future.

            };

            module.exports = ExecutionEnvironment;
        }, {}],
        4: [function(_dereq_, module, exports) {

            var _hyphenPattern = /-(.)/g;

            function camelize(string) {
                return string.replace(_hyphenPattern, function(_, character) {
                    return character.toUpperCase();
                });
            }

            module.exports = camelize;
        }, {}],
        5: [function(_dereq_, module, exports) {

            var camelize = _dereq_('./camelize');

            var msPattern = /^-ms-/;

            function camelizeStyleName(string) {
                return camelize(string.replace(msPattern, 'ms-'));
            }

            module.exports = camelizeStyleName;
        }, {
            "./camelize": 4
        }],
        6: [function(_dereq_, module, exports) {

            var isTextNode = _dereq_('./isTextNode');

            function containsNode(outerNode, innerNode) {
                if (!outerNode || !innerNode) {
                    return false;
                } else if (outerNode === innerNode) {
                    return true;
                } else if (isTextNode(outerNode)) {
                    return false;
                } else if (isTextNode(innerNode)) {
                    return containsNode(outerNode, innerNode.parentNode);
                } else if ('contains' in outerNode) {
                    return outerNode.contains(innerNode);
                } else if (outerNode.compareDocumentPosition) {
                    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
                } else {
                    return false;
                }
            }

            module.exports = containsNode;
        }, {
            "./isTextNode": 19
        }],
        7: [function(_dereq_, module, exports) {
            (function(process) {

                var invariant = _dereq_('./invariant');

                function toArray(obj) {
                    var length = obj.length;

                    // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
                    // in old versions of Safari).
                    !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false): void 0;

                    !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false): void 0;

                    !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false): void 0;

                    !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false): void 0;

                    // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
                    // without method will throw during the slice call and skip straight to the
                    // fallback.
                    if (obj.hasOwnProperty) {
                        try {
                            return Array.prototype.slice.call(obj);
                        } catch (e) {
                            // IE < 9 does not support Array#slice on collections objects
                        }
                    }

                    // Fall back to copying key by key. This assumes all keys have a value,
                    // so will not preserve sparsely populated inputs.
                    var ret = Array(length);
                    for (var ii = 0; ii < length; ii++) {
                        ret[ii] = obj[ii];
                    }
                    return ret;
                }

                function hasArrayNature(obj) {
                    return (
                        // not null/false
                        !!obj && (
                            // arrays are objects, NodeLists are functions in Safari
                            typeof obj == 'object' || typeof obj == 'function') &&
                        // quacks like an array
                        'length' in obj &&
                        // not window
                        !('setInterval' in obj) &&
                        // no DOM node should be considered an array-like
                        // a 'select' element has 'length' and 'item' properties on IE8
                        typeof obj.nodeType != 'number' && (
                            // a real array
                            Array.isArray(obj) ||
                            // arguments
                            'callee' in obj ||
                            // HTMLCollection/NodeList
                            'item' in obj)
                    );
                }

                function createArrayFromMixed(obj) {
                    if (!hasArrayNature(obj)) {
                        return [obj];
                    } else if (Array.isArray(obj)) {
                        return obj.slice();
                    } else {
                        return toArray(obj);
                    }
                }

                module.exports = createArrayFromMixed;
            }).call(this, _dereq_('_process'))
        }, {
            "./invariant": 17,
            "_process": 28
        }],
        8: [function(_dereq_, module, exports) {
            (function(process) {

                var ExecutionEnvironment = _dereq_('./ExecutionEnvironment');

                var createArrayFromMixed = _dereq_('./createArrayFromMixed');
                var getMarkupWrap = _dereq_('./getMarkupWrap');
                var invariant = _dereq_('./invariant');

                var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

                var nodeNamePattern = /^\s*<(\w+)/;

                function getNodeName(markup) {
                    var nodeNameMatch = markup.match(nodeNamePattern);
                    return nodeNameMatch && nodeNameMatch[1].toLowerCase();
                }

                function createNodesFromMarkup(markup, handleScript) {
                    var node = dummyNode;
                    !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
                    var nodeName = getNodeName(markup);

                    var wrap = nodeName && getMarkupWrap(nodeName);
                    if (wrap) {
                        node.innerHTML = wrap[1] + markup + wrap[2];

                        var wrapDepth = wrap[0];
                        while (wrapDepth--) {
                            node = node.lastChild;
                        }
                    } else {
                        node.innerHTML = markup;
                    }

                    var scripts = node.getElementsByTagName('script');
                    if (scripts.length) {
                        !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
                        createArrayFromMixed(scripts).forEach(handleScript);
                    }

                    var nodes = Array.from(node.childNodes);
                    while (node.lastChild) {
                        node.removeChild(node.lastChild);
                    }
                    return nodes;
                }

                module.exports = createNodesFromMarkup;
            }).call(this, _dereq_('_process'))
        }, {
            "./ExecutionEnvironment": 3,
            "./createArrayFromMixed": 7,
            "./getMarkupWrap": 13,
            "./invariant": 17,
            "_process": 28
        }],
        9: [function(_dereq_, module, exports) {

            function makeEmptyFunction(arg) {
                return function() {
                    return arg;
                };
            }

            var emptyFunction = function emptyFunction() {};

            emptyFunction.thatReturns = makeEmptyFunction;
            emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
            emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
            emptyFunction.thatReturnsNull = makeEmptyFunction(null);
            emptyFunction.thatReturnsThis = function() {
                return this;
            };
            emptyFunction.thatReturnsArgument = function(arg) {
                return arg;
            };

            module.exports = emptyFunction;
        }, {}],
        10: [function(_dereq_, module, exports) {
            (function(process) {

                var emptyObject = {};

                if (process.env.NODE_ENV !== 'production') {
                    Object.freeze(emptyObject);
                }

                module.exports = emptyObject;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28
        }],
        11: [function(_dereq_, module, exports) {

            function focusNode(node) {
                // IE8 can throw "Can't move focus to the control because it is invisible,
                // not enabled, or of a type that does not accept the focus." for all kinds of
                // reasons that are too expensive and fragile to test.
                try {
                    node.focus();
                } catch (e) {}
            }

            module.exports = focusNode;
        }, {}],
        12: [function(_dereq_, module, exports) {

            function getActiveElement() {
                if (typeof document === 'undefined') {
                    return null;
                }
                try {
                    return document.activeElement || document.body;
                } catch (e) {
                    return document.body;
                }
            }

            module.exports = getActiveElement;
        }, {}],
        13: [function(_dereq_, module, exports) {
            (function(process) {

                var ExecutionEnvironment = _dereq_('./ExecutionEnvironment');

                var invariant = _dereq_('./invariant');

                var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

                var shouldWrap = {};

                var selectWrap = [1, '<select multiple="true">', '</select>'];
                var tableWrap = [1, '<table>', '</table>'];
                var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

                var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

                var markupWrap = {
                    '*': [1, '?<div>', '</div>'],

                    'area': [1, '<map>', '</map>'],
                    'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
                    'legend': [1, '<fieldset>', '</fieldset>'],
                    'param': [1, '<object>', '</object>'],
                    'tr': [2, '<table><tbody>', '</tbody></table>'],

                    'optgroup': selectWrap,
                    'option': selectWrap,

                    'caption': tableWrap,
                    'colgroup': tableWrap,
                    'tbody': tableWrap,
                    'tfoot': tableWrap,
                    'thead': tableWrap,

                    'td': trWrap,
                    'th': trWrap
                };

                // Initialize the SVG elements since we know they'll always need to be wrapped
                // consistently. If they are created inside a <div> they will be initialized in
                // the wrong namespace (and will not display).
                var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
                svgElements.forEach(function(nodeName) {
                    markupWrap[nodeName] = svgWrap;
                    shouldWrap[nodeName] = true;
                });

                function getMarkupWrap(nodeName) {
                    !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
                    if (!markupWrap.hasOwnProperty(nodeName)) {
                        nodeName = '*';
                    }
                    if (!shouldWrap.hasOwnProperty(nodeName)) {
                        if (nodeName === '*') {
                            dummyNode.innerHTML = '<link />';
                        } else {
                            dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
                        }
                        shouldWrap[nodeName] = !dummyNode.firstChild;
                    }
                    return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
                }

                module.exports = getMarkupWrap;
            }).call(this, _dereq_('_process'))
        }, {
            "./ExecutionEnvironment": 3,
            "./invariant": 17,
            "_process": 28
        }],
        14: [function(_dereq_, module, exports) {

            function getUnboundedScrollPosition(scrollable) {
                if (scrollable === window) {
                    return {
                        x: window.pageXOffset || document.documentElement.scrollLeft,
                        y: window.pageYOffset || document.documentElement.scrollTop
                    };
                }
                return {
                    x: scrollable.scrollLeft,
                    y: scrollable.scrollTop
                };
            }

            module.exports = getUnboundedScrollPosition;
        }, {}],
        15: [function(_dereq_, module, exports) {

            var _uppercasePattern = /([A-Z])/g;

            function hyphenate(string) {
                return string.replace(_uppercasePattern, '-$1').toLowerCase();
            }

            module.exports = hyphenate;
        }, {}],
        16: [function(_dereq_, module, exports) {

            var hyphenate = _dereq_('./hyphenate');

            var msPattern = /^ms-/;

            function hyphenateStyleName(string) {
                return hyphenate(string).replace(msPattern, '-ms-');
            }

            module.exports = hyphenateStyleName;
        }, {
            "./hyphenate": 15
        }],
        17: [function(_dereq_, module, exports) {
            (function(process) {

                function invariant(condition, format, a, b, c, d, e, f) {
                    if (process.env.NODE_ENV !== 'production') {
                        if (format === undefined) {
                            throw new Error('invariant requires an error message argument');
                        }
                    }

                    if (!condition) {
                        var error;
                        if (format === undefined) {
                            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
                        } else {
                            var args = [a, b, c, d, e, f];
                            var argIndex = 0;
                            error = new Error(format.replace(/%s/g, function() {
                                return args[argIndex++];
                            }));
                            error.name = 'Invariant Violation';
                        }

                        error.framesToPop = 1; // we don't care about invariant's own frame
                        throw error;
                    }
                }

                module.exports = invariant;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28
        }],
        18: [function(_dereq_, module, exports) {

            function isNode(object) {
                return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
            }

            module.exports = isNode;
        }, {}],
        19: [function(_dereq_, module, exports) {

            var isNode = _dereq_('./isNode');

            function isTextNode(object) {
                return isNode(object) && object.nodeType == 3;
            }

            module.exports = isTextNode;
        }, {
            "./isNode": 18
        }],
        20: [function(_dereq_, module, exports) {

            function memoizeStringOnly(callback) {
                var cache = {};
                return function(string) {
                    if (!cache.hasOwnProperty(string)) {
                        cache[string] = callback.call(this, string);
                    }
                    return cache[string];
                };
            }

            module.exports = memoizeStringOnly;
        }, {}],
        21: [function(_dereq_, module, exports) {

            var ExecutionEnvironment = _dereq_('./ExecutionEnvironment');

            var performance;

            if (ExecutionEnvironment.canUseDOM) {
                performance = window.performance || window.msPerformance || window.webkitPerformance;
            }

            module.exports = performance || {};
        }, {
            "./ExecutionEnvironment": 3
        }],
        22: [function(_dereq_, module, exports) {

            var performance = _dereq_('./performance');

            var performanceNow;

            if (performance.now) {
                performanceNow = function performanceNow() {
                    return performance.now();
                };
            } else {
                performanceNow = function performanceNow() {
                    return Date.now();
                };
            }

            module.exports = performanceNow;
        }, {
            "./performance": 21
        }],
        23: [function(_dereq_, module, exports) {

            var hasOwnProperty = Object.prototype.hasOwnProperty;

            function is(x, y) {
                // SameValue algorithm
                if (x === y) {
                    // Steps 1-5, 7-10
                    // Steps 6.b-6.e: +0 != -0
                    // Added the nonzero y check to make Flow happy, but it is redundant
                    return x !== 0 || y !== 0 || 1 / x === 1 / y;
                } else {
                    // Step 6.a: NaN == NaN
                    return x !== x && y !== y;
                }
            }

            function shallowEqual(objA, objB) {
                if (is(objA, objB)) {
                    return true;
                }

                if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
                    return false;
                }

                var keysA = Object.keys(objA);
                var keysB = Object.keys(objB);

                if (keysA.length !== keysB.length) {
                    return false;
                }

                // Test for A's keys different from B.
                for (var i = 0; i < keysA.length; i++) {
                    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
                        return false;
                    }
                }

                return true;
            }

            module.exports = shallowEqual;
        }, {}],
        24: [function(_dereq_, module, exports) {
            (function(process) {

                var emptyFunction = _dereq_('./emptyFunction');

                var warning = emptyFunction;

                if (process.env.NODE_ENV !== 'production') {
                    (function() {
                        var printWarning = function printWarning(format) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                args[_key - 1] = arguments[_key];
                            }

                            var argIndex = 0;
                            var message = 'Warning: ' + format.replace(/%s/g, function() {
                                return args[argIndex++];
                            });
                            if (typeof console !== 'undefined') {
                                console.error(message);
                            }
                            try {
                                // --- Welcome to debugging React ---
                                // This error was thrown as a convenience so that you can use this stack
                                // to find the callsite that caused this warning to fire.
                                throw new Error(message);
                            } catch (x) {}
                        };

                        warning = function warning(condition, format) {
                            if (format === undefined) {
                                throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
                            }

                            if (format.indexOf('Failed Composite propType: ') === 0) {
                                return; // Ignore CompositeComponent proptype check.
                            }

                            if (!condition) {
                                for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                                    args[_key2 - 2] = arguments[_key2];
                                }

                                printWarning.apply(undefined, [format].concat(args));
                            }
                        };
                    })();
                }

                module.exports = warning;
            }).call(this, _dereq_('_process'))
        }, {
            "./emptyFunction": 9,
            "_process": 28
        }],
        25: [function(_dereq_, module, exports) {

            (function(global, factory) {



                if (typeof module === "object" && typeof module.exports === "object") {

                    // For CommonJS and CommonJS-like environments where a proper `window`
                    // is present, execute the factory and get jQuery.
                    // For environments that do not have a `window` with a `document`
                    // (such as Node.js), expose a factory as module.exports.
                    // This accentuates the need for the creation of a real `window`.
                    // e.g. var jQuery = require("jquery")(window);
                    // See ticket #14549 for more info.
                    module.exports = global.document ?
                        factory(global, true) :
                        function(w) {
                            if (!w.document) {
                                throw new Error("jQuery requires a window with a document");
                            }
                            return factory(w);
                        };
                } else {
                    factory(global);
                }

                // Pass this if window is not defined yet
            })(typeof window !== "undefined" ? window : this, function(window, noGlobal) {

                // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
                // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
                // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
                // enough that all such attempts are guarded in a try block.

                var arr = [];

                var document = window.document;

                var getProto = Object.getPrototypeOf;

                var slice = arr.slice;

                var concat = arr.concat;

                var push = arr.push;

                var indexOf = arr.indexOf;

                var class2type = {};

                var toString = class2type.toString;

                var hasOwn = class2type.hasOwnProperty;

                var fnToString = hasOwn.toString;

                var ObjectFunctionString = fnToString.call(Object);

                var support = {};

                function DOMEval(code, doc) {
                    doc = doc || document;

                    var script = doc.createElement("script");

                    script.text = code;
                    doc.head.appendChild(script).parentNode.removeChild(script);
                }

                // Defining this global in .eslintrc.json would create a danger of using the global
                // unguarded in another place, it seems safer to define global only for this module

                var
                    version = "3.1.1",

                    // Define a local copy of jQuery
                    jQuery = function(selector, context) {

                        // The jQuery object is actually just the init constructor 'enhanced'
                        // Need init if jQuery is called (just allow error to be thrown if not included)
                        return new jQuery.fn.init(selector, context);
                    },

                    // Support: Android <=4.0 only
                    // Make sure we trim BOM and NBSP
                    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

                    // Matches dashed string for camelizing
                    rmsPrefix = /^-ms-/,
                    rdashAlpha = /-([a-z])/g,

                    // Used by jQuery.camelCase as callback to replace()
                    fcamelCase = function(all, letter) {
                        return letter.toUpperCase();
                    };

                jQuery.fn = jQuery.prototype = {

                    // The current version of jQuery being used
                    jquery: version,

                    constructor: jQuery,

                    // The default length of a jQuery object is 0
                    length: 0,

                    toArray: function() {
                        return slice.call(this);
                    },

                    // Get the Nth element in the matched element set OR
                    // Get the whole matched element set as a clean array
                    get: function(num) {

                        // Return all the elements in a clean array
                        if (num == null) {
                            return slice.call(this);
                        }

                        // Return just the one element from the set
                        return num < 0 ? this[num + this.length] : this[num];
                    },

                    // Take an array of elements and push it onto the stack
                    // (returning the new matched element set)
                    pushStack: function(elems) {

                        // Build a new jQuery matched element set
                        var ret = jQuery.merge(this.constructor(), elems);

                        // Add the old object onto the stack (as a reference)
                        ret.prevObject = this;

                        // Return the newly-formed element set
                        return ret;
                    },

                    // Execute a callback for every element in the matched set.
                    each: function(callback) {
                        return jQuery.each(this, callback);
                    },

                    map: function(callback) {
                        return this.pushStack(jQuery.map(this, function(elem, i) {
                            return callback.call(elem, i, elem);
                        }));
                    },

                    slice: function() {
                        return this.pushStack(slice.apply(this, arguments));
                    },

                    first: function() {
                        return this.eq(0);
                    },

                    last: function() {
                        return this.eq(-1);
                    },

                    eq: function(i) {
                        var len = this.length,
                            j = +i + (i < 0 ? len : 0);
                        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                    },

                    end: function() {
                        return this.prevObject || this.constructor();
                    },

                    // For internal use only.
                    // Behaves like an Array's method, not like a jQuery method.
                    push: push,
                    sort: arr.sort,
                    splice: arr.splice
                };

                jQuery.extend = jQuery.fn.extend = function() {
                    var options, name, src, copy, copyIsArray, clone,
                        target = arguments[0] || {},
                        i = 1,
                        length = arguments.length,
                        deep = false;

                    // Handle a deep copy situation
                    if (typeof target === "boolean") {
                        deep = target;

                        // Skip the boolean and the target
                        target = arguments[i] || {};
                        i++;
                    }

                    // Handle case when target is a string or something (possible in deep copy)
                    if (typeof target !== "object" && !jQuery.isFunction(target)) {
                        target = {};
                    }

                    // Extend jQuery itself if only one argument is passed
                    if (i === length) {
                        target = this;
                        i--;
                    }

                    for (; i < length; i++) {

                        // Only deal with non-null/undefined values
                        if ((options = arguments[i]) != null) {

                            // Extend the base object
                            for (name in options) {
                                src = target[name];
                                copy = options[name];

                                // Prevent never-ending loop
                                if (target === copy) {
                                    continue;
                                }

                                // Recurse if we're merging plain objects or arrays
                                if (deep && copy && (jQuery.isPlainObject(copy) ||
                                        (copyIsArray = jQuery.isArray(copy)))) {

                                    if (copyIsArray) {
                                        copyIsArray = false;
                                        clone = src && jQuery.isArray(src) ? src : [];

                                    } else {
                                        clone = src && jQuery.isPlainObject(src) ? src : {};
                                    }

                                    // Never move original objects, clone them
                                    target[name] = jQuery.extend(deep, clone, copy);

                                    // Don't bring in undefined values
                                } else if (copy !== undefined) {
                                    target[name] = copy;
                                }
                            }
                        }
                    }

                    // Return the modified object
                    return target;
                };

                jQuery.extend({

                    // Unique for each copy of jQuery on the page
                    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

                    // Assume jQuery is ready without the ready module
                    isReady: true,

                    error: function(msg) {
                        throw new Error(msg);
                    },

                    noop: function() {},

                    isFunction: function(obj) {
                        return jQuery.type(obj) === "function";
                    },

                    isArray: Array.isArray,

                    isWindow: function(obj) {
                        return obj != null && obj === obj.window;
                    },

                    isNumeric: function(obj) {

                        // As of jQuery 3.0, isNumeric is limited to
                        // strings and numbers (primitives or objects)
                        // that can be coerced to finite numbers (gh-2662)
                        var type = jQuery.type(obj);
                        return (type === "number" || type === "string") &&

                            // parseFloat NaNs numeric-cast false positives ("")
                            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                            // subtraction forces infinities to NaN
                            !isNaN(obj - parseFloat(obj));
                    },

                    isPlainObject: function(obj) {
                        var proto, Ctor;

                        // Detect obvious negatives
                        // Use toString instead of jQuery.type to catch host objects
                        if (!obj || toString.call(obj) !== "[object Object]") {
                            return false;
                        }

                        proto = getProto(obj);

                        // Objects with no prototype (e.g., `Object.create( null )`) are plain
                        if (!proto) {
                            return true;
                        }

                        // Objects with prototype are plain iff they were constructed by a global Object function
                        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
                        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
                    },

                    isEmptyObject: function(obj) {


                        // See https://github.com/eslint/eslint/issues/6125
                        var name;

                        for (name in obj) {
                            return false;
                        }
                        return true;
                    },

                    type: function(obj) {
                        if (obj == null) {
                            return obj + "";
                        }

                        // Support: Android <=2.3 only (functionish RegExp)
                        return typeof obj === "object" || typeof obj === "function" ?
                            class2type[toString.call(obj)] || "object" :
                            typeof obj;
                    },

                    // Evaluates a script in a global context
                    globalEval: function(code) {
                        DOMEval(code);
                    },

                    // Convert dashed to camelCase; used by the css and data modules
                    // Support: IE <=9 - 11, Edge 12 - 13
                    // Microsoft forgot to hump their vendor prefix (#9572)
                    camelCase: function(string) {
                        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                    },

                    nodeName: function(elem, name) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                    },

                    each: function(obj, callback) {
                        var length, i = 0;

                        if (isArrayLike(obj)) {
                            length = obj.length;
                            for (; i < length; i++) {
                                if (callback.call(obj[i], i, obj[i]) === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                if (callback.call(obj[i], i, obj[i]) === false) {
                                    break;
                                }
                            }
                        }

                        return obj;
                    },

                    // Support: Android <=4.0 only
                    trim: function(text) {
                        return text == null ?
                            "" :
                            (text + "").replace(rtrim, "");
                    },

                    // results is for internal usage only
                    makeArray: function(arr, results) {
                        var ret = results || [];

                        if (arr != null) {
                            if (isArrayLike(Object(arr))) {
                                jQuery.merge(ret,
                                    typeof arr === "string" ? [arr] : arr
                                );
                            } else {
                                push.call(ret, arr);
                            }
                        }

                        return ret;
                    },

                    inArray: function(elem, arr, i) {
                        return arr == null ? -1 : indexOf.call(arr, elem, i);
                    },

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    merge: function(first, second) {
                        var len = +second.length,
                            j = 0,
                            i = first.length;

                        for (; j < len; j++) {
                            first[i++] = second[j];
                        }

                        first.length = i;

                        return first;
                    },

                    grep: function(elems, callback, invert) {
                        var callbackInverse,
                            matches = [],
                            i = 0,
                            length = elems.length,
                            callbackExpect = !invert;

                        // Go through the array, only saving the items
                        // that pass the validator function
                        for (; i < length; i++) {
                            callbackInverse = !callback(elems[i], i);
                            if (callbackInverse !== callbackExpect) {
                                matches.push(elems[i]);
                            }
                        }

                        return matches;
                    },

                    // arg is for internal usage only
                    map: function(elems, callback, arg) {
                        var length, value,
                            i = 0,
                            ret = [];

                        // Go through the array, translating each of the items to their new values
                        if (isArrayLike(elems)) {
                            length = elems.length;
                            for (; i < length; i++) {
                                value = callback(elems[i], i, arg);

                                if (value != null) {
                                    ret.push(value);
                                }
                            }

                            // Go through every key on the object,
                        } else {
                            for (i in elems) {
                                value = callback(elems[i], i, arg);

                                if (value != null) {
                                    ret.push(value);
                                }
                            }
                        }

                        // Flatten any nested arrays
                        return concat.apply([], ret);
                    },

                    // A global GUID counter for objects
                    guid: 1,

                    // Bind a function to a context, optionally partially applying any
                    // arguments.
                    proxy: function(fn, context) {
                        var tmp, args, proxy;

                        if (typeof context === "string") {
                            tmp = fn[context];
                            context = fn;
                            fn = tmp;
                        }

                        // Quick check to determine if target is callable, in the spec
                        // this throws a TypeError, but we will just return undefined.
                        if (!jQuery.isFunction(fn)) {
                            return undefined;
                        }

                        // Simulated bind
                        args = slice.call(arguments, 2);
                        proxy = function() {
                            return fn.apply(context || this, args.concat(slice.call(arguments)));
                        };

                        // Set the guid of unique handler to the same of original handler, so it can be removed
                        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                        return proxy;
                    },

                    now: Date.now,

                    // jQuery.support is not used in Core but other projects attach their
                    // properties to it so it needs to exist.
                    support: support
                });

                if (typeof Symbol === "function") {
                    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
                }

                // Populate the class2type map
                jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
                    function(i, name) {
                        class2type["[object " + name + "]"] = name.toLowerCase();
                    });

                function isArrayLike(obj) {

                    // Support: real iOS 8.2 only (not reproducible in simulator)
                    // `in` check used to prevent JIT error (gh-2145)
                    // hasOwn isn't used here due to false negatives
                    // regarding Nodelist length in IE
                    var length = !!obj && "length" in obj && obj.length,
                        type = jQuery.type(obj);

                    if (type === "function" || jQuery.isWindow(obj)) {
                        return false;
                    }

                    return type === "array" || length === 0 ||
                        typeof length === "number" && length > 0 && (length - 1) in obj;
                }
                var Sizzle =

                    (function(window) {

                        var i,
                            support,
                            Expr,
                            getText,
                            isXML,
                            tokenize,
                            compile,
                            select,
                            outermostContext,
                            sortInput,
                            hasDuplicate,

                            // Local document vars
                            setDocument,
                            document,
                            docElem,
                            documentIsHTML,
                            rbuggyQSA,
                            rbuggyMatches,
                            matches,
                            contains,

                            // Instance-specific data
                            expando = "sizzle" + 1 * new Date(),
                            preferredDoc = window.document,
                            dirruns = 0,
                            done = 0,
                            classCache = createCache(),
                            tokenCache = createCache(),
                            compilerCache = createCache(),
                            sortOrder = function(a, b) {
                                if (a === b) {
                                    hasDuplicate = true;
                                }
                                return 0;
                            },

                            // Instance methods
                            hasOwn = ({}).hasOwnProperty,
                            arr = [],
                            pop = arr.pop,
                            push_native = arr.push,
                            push = arr.push,
                            slice = arr.slice,
                            // Use a stripped-down indexOf as it's faster than native
                            // https://jsperf.com/thor-indexof-vs-for/5
                            indexOf = function(list, elem) {
                                var i = 0,
                                    len = list.length;
                                for (; i < len; i++) {
                                    if (list[i] === elem) {
                                        return i;
                                    }
                                }
                                return -1;
                            },

                            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                            // Regular expressions

                            // http://www.w3.org/TR/css3-selectors/#whitespace
                            whitespace = "[\\x20\\t\\r\\n\\f]",

                            // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                            identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

                            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                            attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                            // Operator (capture 2)
                            "*([*^$|!~]?=)" + whitespace +
                            // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                            "*\\]",

                            pseudos = ":(" + identifier + ")(?:\\((" +
                            // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                            // 1. quoted (capture 3; capture 4 or capture 5)
                            "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                            // 2. simple (capture 6)
                            "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                            // 3. anything else (capture 2)
                            ".*" +
                            ")\\)|)",

                            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                            rwhitespace = new RegExp(whitespace + "+", "g"),
                            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

                            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

                            rpseudo = new RegExp(pseudos),
                            ridentifier = new RegExp("^" + identifier + "$"),

                            matchExpr = {
                                "ID": new RegExp("^#(" + identifier + ")"),
                                "CLASS": new RegExp("^\\.(" + identifier + ")"),
                                "TAG": new RegExp("^(" + identifier + "|[*])"),
                                "ATTR": new RegExp("^" + attributes),
                                "PSEUDO": new RegExp("^" + pseudos),
                                "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                                    "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                                    "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                                "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                                // For use in libraries implementing .is()
                                // We use this for POS matching in `select`
                                "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                                    whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                            },

                            rinputs = /^(?:input|select|textarea|button)$/i,
                            rheader = /^h\d$/i,

                            rnative = /^[^{]+\{\s*\[native \w/,

                            // Easily-parseable/retrievable ID or TAG or CLASS selectors
                            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                            rsibling = /[+~]/,

                            // CSS escapes
                            // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                            runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                            funescape = function(_, escaped, escapedWhitespace) {
                                var high = "0x" + escaped - 0x10000;
                                // NaN means non-codepoint
                                // Support: Firefox<24
                                // Workaround erroneous numeric interpretation of +"0x"
                                return high !== high || escapedWhitespace ?
                                    escaped :
                                    high < 0 ?
                                    // BMP codepoint
                                    String.fromCharCode(high + 0x10000) :
                                    // Supplemental Plane codepoint (surrogate pair)
                                    String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                            },

                            // CSS string/identifier serialization
                            // https://drafts.csswg.org/cssom/#common-serializing-idioms
                            rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                            fcssescape = function(ch, asCodePoint) {
                                if (asCodePoint) {

                                    // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                                    if (ch === "\0") {
                                        return "\uFFFD";
                                    }

                                    // Control characters and (dependent upon position) numbers get escaped as code points
                                    return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                                }

                                // Other potentially-special ASCII characters get backslash-escaped
                                return "\\" + ch;
                            },

                            // Used for iframes
                            // See setDocument()
                            // Removing the function wrapper causes a "Permission Denied"
                            // error in IE
                            unloadHandler = function() {
                                setDocument();
                            },

                            disabledAncestor = addCombinator(
                                function(elem) {
                                    return elem.disabled === true && ("form" in elem || "label" in elem);
                                }, {
                                    dir: "parentNode",
                                    next: "legend"
                                }
                            );

                        // Optimize for push.apply( _, NodeList )
                        try {
                            push.apply(
                                (arr = slice.call(preferredDoc.childNodes)),
                                preferredDoc.childNodes
                            );
                            // Support: Android<4.0
                            // Detect silently failing push.apply
                            arr[preferredDoc.childNodes.length].nodeType;
                        } catch (e) {
                            push = {
                                apply: arr.length ?

                                    // Leverage slice if possible
                                    function(target, els) {
                                        push_native.apply(target, slice.call(els));
                                    } :

                                    // Support: IE<9
                                    // Otherwise append directly
                                    function(target, els) {
                                        var j = target.length,
                                            i = 0;
                                        // Can't trust NodeList.length
                                        while ((target[j++] = els[i++])) {}
                                        target.length = j - 1;
                                    }
                            };
                        }

                        function Sizzle(selector, context, results, seed) {
                            var m, i, elem, nid, match, groups, newSelector,
                                newContext = context && context.ownerDocument,

                                // nodeType defaults to 9, since context defaults to document
                                nodeType = context ? context.nodeType : 9;

                            results = results || [];

                            // Return early from calls with invalid selector or context
                            if (typeof selector !== "string" || !selector ||
                                nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                                return results;
                            }

                            // Try to shortcut find operations (as opposed to filters) in HTML documents
                            if (!seed) {

                                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                                    setDocument(context);
                                }
                                context = context || document;

                                if (documentIsHTML) {

                                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                                    // (excepting DocumentFragment context, where the methods don't exist)
                                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                                        // ID selector
                                        if ((m = match[1])) {

                                            // Document context
                                            if (nodeType === 9) {
                                                if ((elem = context.getElementById(m))) {

                                                    // Support: IE, Opera, Webkit
                                                    // TODO: identify versions
                                                    // getElementById can match elements by name instead of ID
                                                    if (elem.id === m) {
                                                        results.push(elem);
                                                        return results;
                                                    }
                                                } else {
                                                    return results;
                                                }

                                                // Element context
                                            } else {

                                                // Support: IE, Opera, Webkit
                                                // TODO: identify versions
                                                // getElementById can match elements by name instead of ID
                                                if (newContext && (elem = newContext.getElementById(m)) &&
                                                    contains(context, elem) &&
                                                    elem.id === m) {

                                                    results.push(elem);
                                                    return results;
                                                }
                                            }

                                            // Type selector
                                        } else if (match[2]) {
                                            push.apply(results, context.getElementsByTagName(selector));
                                            return results;

                                            // Class selector
                                        } else if ((m = match[3]) && support.getElementsByClassName &&
                                            context.getElementsByClassName) {

                                            push.apply(results, context.getElementsByClassName(m));
                                            return results;
                                        }
                                    }

                                    // Take advantage of querySelectorAll
                                    if (support.qsa &&
                                        !compilerCache[selector + " "] &&
                                        (!rbuggyQSA || !rbuggyQSA.test(selector))) {

                                        if (nodeType !== 1) {
                                            newContext = context;
                                            newSelector = selector;

                                            // qSA looks outside Element context, which is not what we want
                                            // Thanks to Andrew Dupont for this workaround technique
                                            // Support: IE <=8
                                            // Exclude object elements
                                        } else if (context.nodeName.toLowerCase() !== "object") {

                                            // Capture the context ID, setting it first if necessary
                                            if ((nid = context.getAttribute("id"))) {
                                                nid = nid.replace(rcssescape, fcssescape);
                                            } else {
                                                context.setAttribute("id", (nid = expando));
                                            }

                                            // Prefix every selector in the list
                                            groups = tokenize(selector);
                                            i = groups.length;
                                            while (i--) {
                                                groups[i] = "#" + nid + " " + toSelector(groups[i]);
                                            }
                                            newSelector = groups.join(",");

                                            // Expand context for sibling selectors
                                            newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                                                context;
                                        }

                                        if (newSelector) {
                                            try {
                                                push.apply(results,
                                                    newContext.querySelectorAll(newSelector)
                                                );
                                                return results;
                                            } catch (qsaError) {} finally {
                                                if (nid === expando) {
                                                    context.removeAttribute("id");
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            // All others
                            return select(selector.replace(rtrim, "$1"), context, results, seed);
                        }

                        function createCache() {
                            var keys = [];

                            function cache(key, value) {
                                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                                if (keys.push(key + " ") > Expr.cacheLength) {
                                    // Only keep the most recent entries
                                    delete cache[keys.shift()];
                                }
                                return (cache[key + " "] = value);
                            }
                            return cache;
                        }

                        function markFunction(fn) {
                            fn[expando] = true;
                            return fn;
                        }

                        function assert(fn) {
                            var el = document.createElement("fieldset");

                            try {
                                return !!fn(el);
                            } catch (e) {
                                return false;
                            } finally {
                                // Remove from its parent by default
                                if (el.parentNode) {
                                    el.parentNode.removeChild(el);
                                }
                                // release memory in IE
                                el = null;
                            }
                        }

                        function addHandle(attrs, handler) {
                            var arr = attrs.split("|"),
                                i = arr.length;

                            while (i--) {
                                Expr.attrHandle[arr[i]] = handler;
                            }
                        }

                        function siblingCheck(a, b) {
                            var cur = b && a,
                                diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                a.sourceIndex - b.sourceIndex;

                            // Use IE sourceIndex if available on both nodes
                            if (diff) {
                                return diff;
                            }

                            // Check if b follows a
                            if (cur) {
                                while ((cur = cur.nextSibling)) {
                                    if (cur === b) {
                                        return -1;
                                    }
                                }
                            }

                            return a ? 1 : -1;
                        }

                        function createInputPseudo(type) {
                            return function(elem) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === type;
                            };
                        }

                        function createButtonPseudo(type) {
                            return function(elem) {
                                var name = elem.nodeName.toLowerCase();
                                return (name === "input" || name === "button") && elem.type === type;
                            };
                        }

                        function createDisabledPseudo(disabled) {

                            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                            return function(elem) {

                                // Only certain elements can match :enabled or :disabled
                                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                                if ("form" in elem) {

                                    // Check for inherited disabledness on relevant non-disabled elements:
                                    // * listed form-associated elements in a disabled fieldset
                                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                                    // * option elements in a disabled optgroup
                                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                                    // All such elements have a "form" property.
                                    if (elem.parentNode && elem.disabled === false) {

                                        // Option elements defer to a parent optgroup if present
                                        if ("label" in elem) {
                                            if ("label" in elem.parentNode) {
                                                return elem.parentNode.disabled === disabled;
                                            } else {
                                                return elem.disabled === disabled;
                                            }
                                        }

                                        // Support: IE 6 - 11
                                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                                        return elem.isDisabled === disabled ||

                                            // Where there is no isDisabled, check manually

                                            elem.isDisabled !== !disabled &&
                                            disabledAncestor(elem) === disabled;
                                    }

                                    return elem.disabled === disabled;

                                    // Try to winnow out elements that can't be disabled before trusting the disabled property.
                                    // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                                    // even exist on them, let alone have a boolean value.
                                } else if ("label" in elem) {
                                    return elem.disabled === disabled;
                                }

                                // Remaining elements are neither :enabled nor :disabled
                                return false;
                            };
                        }

                        function createPositionalPseudo(fn) {
                            return markFunction(function(argument) {
                                argument = +argument;
                                return markFunction(function(seed, matches) {
                                    var j,
                                        matchIndexes = fn([], seed.length, argument),
                                        i = matchIndexes.length;

                                    // Match elements found at the specified indexes
                                    while (i--) {
                                        if (seed[(j = matchIndexes[i])]) {
                                            seed[j] = !(matches[j] = seed[j]);
                                        }
                                    }
                                });
                            });
                        }

                        function testContext(context) {
                            return context && typeof context.getElementsByTagName !== "undefined" && context;
                        }

                        // Expose support vars for convenience
                        support = Sizzle.support = {};

                        isXML = Sizzle.isXML = function(elem) {
                            // documentElement is verified for cases where it doesn't yet exist
                            // (such as loading iframes in IE - #4833)
                            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                            return documentElement ? documentElement.nodeName !== "HTML" : false;
                        };

                        setDocument = Sizzle.setDocument = function(node) {
                            var hasCompare, subWindow,
                                doc = node ? node.ownerDocument || node : preferredDoc;

                            // Return early if doc is invalid or already selected
                            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                                return document;
                            }

                            // Update global variables
                            document = doc;
                            docElem = document.documentElement;
                            documentIsHTML = !isXML(document);

                            // Support: IE 9-11, Edge
                            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                            if (preferredDoc !== document &&
                                (subWindow = document.defaultView) && subWindow.top !== subWindow) {

                                // Support: IE 11, Edge
                                if (subWindow.addEventListener) {
                                    subWindow.addEventListener("unload", unloadHandler, false);

                                    // Support: IE 9 - 10 only
                                } else if (subWindow.attachEvent) {
                                    subWindow.attachEvent("onunload", unloadHandler);
                                }
                            }



                            // Support: IE<8
                            // Verify that getAttribute really returns attributes and not properties
                            // (excepting IE8 booleans)
                            support.attributes = assert(function(el) {
                                el.className = "i";
                                return !el.getAttribute("className");
                            });



                            // Check if getElementsByTagName("*") returns only elements
                            support.getElementsByTagName = assert(function(el) {
                                el.appendChild(document.createComment(""));
                                return !el.getElementsByTagName("*").length;
                            });

                            // Support: IE<9
                            support.getElementsByClassName = rnative.test(document.getElementsByClassName);

                            // Support: IE<10
                            // Check if getElementById returns elements by name
                            // The broken getElementById methods don't pick up programmatically-set names,
                            // so use a roundabout getElementsByName test
                            support.getById = assert(function(el) {
                                docElem.appendChild(el).id = expando;
                                return !document.getElementsByName || !document.getElementsByName(expando).length;
                            });

                            // ID filter and find
                            if (support.getById) {
                                Expr.filter["ID"] = function(id) {
                                    var attrId = id.replace(runescape, funescape);
                                    return function(elem) {
                                        return elem.getAttribute("id") === attrId;
                                    };
                                };
                                Expr.find["ID"] = function(id, context) {
                                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                        var elem = context.getElementById(id);
                                        return elem ? [elem] : [];
                                    }
                                };
                            } else {
                                Expr.filter["ID"] = function(id) {
                                    var attrId = id.replace(runescape, funescape);
                                    return function(elem) {
                                        var node = typeof elem.getAttributeNode !== "undefined" &&
                                            elem.getAttributeNode("id");
                                        return node && node.value === attrId;
                                    };
                                };

                                // Support: IE 6 - 7 only
                                // getElementById is not reliable as a find shortcut
                                Expr.find["ID"] = function(id, context) {
                                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                        var node, i, elems,
                                            elem = context.getElementById(id);

                                        if (elem) {

                                            // Verify the id attribute
                                            node = elem.getAttributeNode("id");
                                            if (node && node.value === id) {
                                                return [elem];
                                            }

                                            // Fall back on getElementsByName
                                            elems = context.getElementsByName(id);
                                            i = 0;
                                            while ((elem = elems[i++])) {
                                                node = elem.getAttributeNode("id");
                                                if (node && node.value === id) {
                                                    return [elem];
                                                }
                                            }
                                        }

                                        return [];
                                    }
                                };
                            }

                            // Tag
                            Expr.find["TAG"] = support.getElementsByTagName ?
                                function(tag, context) {
                                    if (typeof context.getElementsByTagName !== "undefined") {
                                        return context.getElementsByTagName(tag);

                                        // DocumentFragment nodes don't have gEBTN
                                    } else if (support.qsa) {
                                        return context.querySelectorAll(tag);
                                    }
                                } :

                                function(tag, context) {
                                    var elem,
                                        tmp = [],
                                        i = 0,
                                        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                        results = context.getElementsByTagName(tag);

                                    // Filter out possible comments
                                    if (tag === "*") {
                                        while ((elem = results[i++])) {
                                            if (elem.nodeType === 1) {
                                                tmp.push(elem);
                                            }
                                        }

                                        return tmp;
                                    }
                                    return results;
                                };

                            // Class
                            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                                    return context.getElementsByClassName(className);
                                }
                            };



                            // QSA and matchesSelector support

                            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                            rbuggyMatches = [];

                            // qSa(:focus) reports false when true (Chrome 21)
                            // We allow this because of a bug in IE8/9 that throws an error
                            // whenever `document.activeElement` is accessed on an iframe
                            // So, we allow :focus to pass through QSA all the time to avoid the IE error
                            // See https://bugs.jquery.com/ticket/13378
                            rbuggyQSA = [];

                            if ((support.qsa = rnative.test(document.querySelectorAll))) {
                                // Build QSA regex
                                // Regex strategy adopted from Diego Perini
                                assert(function(el) {
                                    // Select is set to empty string on purpose
                                    // This is to test IE's treatment of not explicitly
                                    // setting a boolean content attribute,
                                    // since its presence should be enough
                                    // https://bugs.jquery.com/ticket/12359
                                    docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
                                        "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                                        "<option selected=''></option></select>";

                                    // Support: IE8, Opera 11-12.16
                                    // Nothing should be selected when empty strings follow ^= or $= or *=
                                    // The test attribute must be unknown in Opera but "safe" for WinRT
                                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                    if (el.querySelectorAll("[msallowcapture^='']").length) {
                                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                                    }

                                    // Support: IE8
                                    // Boolean attributes and "value" are not treated correctly
                                    if (!el.querySelectorAll("[selected]").length) {
                                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                                    }

                                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                                    if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                                        rbuggyQSA.push("~=");
                                    }

                                    // Webkit/Opera - :checked should return selected option elements
                                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                    // IE8 throws error here and will not see later tests
                                    if (!el.querySelectorAll(":checked").length) {
                                        rbuggyQSA.push(":checked");
                                    }

                                    // Support: Safari 8+, iOS 8+
                                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                                    // In-page `selector#id sibling-combinator selector` fails
                                    if (!el.querySelectorAll("a#" + expando + "+*").length) {
                                        rbuggyQSA.push(".#.+[+~]");
                                    }
                                });

                                assert(function(el) {
                                    el.innerHTML = "<a href='' disabled='disabled'></a>" +
                                        "<select disabled='disabled'><option/></select>";

                                    // Support: Windows 8 Native Apps
                                    // The type and name attributes are restricted during .innerHTML assignment
                                    var input = document.createElement("input");
                                    input.setAttribute("type", "hidden");
                                    el.appendChild(input).setAttribute("name", "D");

                                    // Support: IE8
                                    // Enforce case-sensitivity of name attribute
                                    if (el.querySelectorAll("[name=d]").length) {
                                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                                    }

                                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                    // IE8 throws error here and will not see later tests
                                    if (el.querySelectorAll(":enabled").length !== 2) {
                                        rbuggyQSA.push(":enabled", ":disabled");
                                    }

                                    // Support: IE9-11+
                                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                                    docElem.appendChild(el).disabled = true;
                                    if (el.querySelectorAll(":disabled").length !== 2) {
                                        rbuggyQSA.push(":enabled", ":disabled");
                                    }

                                    // Opera 10-11 does not throw on post-comma invalid pseudos
                                    el.querySelectorAll("*,:x");
                                    rbuggyQSA.push(",.*:");
                                });
                            }

                            if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                                    docElem.webkitMatchesSelector ||
                                    docElem.mozMatchesSelector ||
                                    docElem.oMatchesSelector ||
                                    docElem.msMatchesSelector)))) {

                                assert(function(el) {
                                    // Check to see if it's possible to do matchesSelector
                                    // on a disconnected node (IE 9)
                                    support.disconnectedMatch = matches.call(el, "*");

                                    // This should fail with an exception
                                    // Gecko does not error, returns false instead
                                    matches.call(el, "[s!='']:x");
                                    rbuggyMatches.push("!=", pseudos);
                                });
                            }

                            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));


                            hasCompare = rnative.test(docElem.compareDocumentPosition);

                            // Element contains another
                            // Purposefully self-exclusive
                            // As in, an element does not contain itself
                            contains = hasCompare || rnative.test(docElem.contains) ?
                                function(a, b) {
                                    var adown = a.nodeType === 9 ? a.documentElement : a,
                                        bup = b && b.parentNode;
                                    return a === bup || !!(bup && bup.nodeType === 1 && (
                                        adown.contains ?
                                        adown.contains(bup) :
                                        a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                                    ));
                                } :
                                function(a, b) {
                                    if (b) {
                                        while ((b = b.parentNode)) {
                                            if (b === a) {
                                                return true;
                                            }
                                        }
                                    }
                                    return false;
                                };



                            // Document order sorting
                            sortOrder = hasCompare ?
                                function(a, b) {

                                    // Flag for duplicate removal
                                    if (a === b) {
                                        hasDuplicate = true;
                                        return 0;
                                    }

                                    // Sort on method existence if only one input has compareDocumentPosition
                                    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                    if (compare) {
                                        return compare;
                                    }

                                    // Calculate position if both inputs belong to the same document
                                    compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                                        a.compareDocumentPosition(b) :

                                        // Otherwise we know they are disconnected
                                        1;

                                    // Disconnected nodes
                                    if (compare & 1 ||
                                        (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                                        // Choose the first element that is related to our preferred document
                                        if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                            return -1;
                                        }
                                        if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                            return 1;
                                        }

                                        // Maintain original order
                                        return sortInput ?
                                            (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                            0;
                                    }

                                    return compare & 4 ? -1 : 1;
                                } :
                                function(a, b) {
                                    // Exit early if the nodes are identical
                                    if (a === b) {
                                        hasDuplicate = true;
                                        return 0;
                                    }

                                    var cur,
                                        i = 0,
                                        aup = a.parentNode,
                                        bup = b.parentNode,
                                        ap = [a],
                                        bp = [b];

                                    // Parentless nodes are either documents or disconnected
                                    if (!aup || !bup) {
                                        return a === document ? -1 :
                                            b === document ? 1 :
                                            aup ? -1 :
                                            bup ? 1 :
                                            sortInput ?
                                            (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                            0;

                                        // If the nodes are siblings, we can do a quick check
                                    } else if (aup === bup) {
                                        return siblingCheck(a, b);
                                    }

                                    // Otherwise we need full lists of their ancestors for comparison
                                    cur = a;
                                    while ((cur = cur.parentNode)) {
                                        ap.unshift(cur);
                                    }
                                    cur = b;
                                    while ((cur = cur.parentNode)) {
                                        bp.unshift(cur);
                                    }

                                    // Walk down the tree looking for a discrepancy
                                    while (ap[i] === bp[i]) {
                                        i++;
                                    }

                                    return i ?
                                        // Do a sibling check if the nodes have a common ancestor
                                        siblingCheck(ap[i], bp[i]) :

                                        // Otherwise nodes in our document sort first
                                        ap[i] === preferredDoc ? -1 :
                                        bp[i] === preferredDoc ? 1 :
                                        0;
                                };

                            return document;
                        };

                        Sizzle.matches = function(expr, elements) {
                            return Sizzle(expr, null, null, elements);
                        };

                        Sizzle.matchesSelector = function(elem, expr) {
                            // Set document vars if needed
                            if ((elem.ownerDocument || elem) !== document) {
                                setDocument(elem);
                            }

                            // Make sure that attribute selectors are quoted
                            expr = expr.replace(rattributeQuotes, "='$1']");

                            if (support.matchesSelector && documentIsHTML &&
                                !compilerCache[expr + " "] &&
                                (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                                (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                                try {
                                    var ret = matches.call(elem, expr);

                                    // IE 9's matchesSelector returns false on disconnected nodes
                                    if (ret || support.disconnectedMatch ||
                                        // As well, disconnected nodes are said to be in a document
                                        // fragment in IE 9
                                        elem.document && elem.document.nodeType !== 11) {
                                        return ret;
                                    }
                                } catch (e) {}
                            }

                            return Sizzle(expr, document, null, [elem]).length > 0;
                        };

                        Sizzle.contains = function(context, elem) {
                            // Set document vars if needed
                            if ((context.ownerDocument || context) !== document) {
                                setDocument(context);
                            }
                            return contains(context, elem);
                        };

                        Sizzle.attr = function(elem, name) {
                            // Set document vars if needed
                            if ((elem.ownerDocument || elem) !== document) {
                                setDocument(elem);
                            }

                            var fn = Expr.attrHandle[name.toLowerCase()],
                                // Don't get fooled by Object.prototype properties (jQuery #13807)
                                val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                                fn(elem, name, !documentIsHTML) :
                                undefined;

                            return val !== undefined ?
                                val :
                                support.attributes || !documentIsHTML ?
                                elem.getAttribute(name) :
                                (val = elem.getAttributeNode(name)) && val.specified ?
                                val.value :
                                null;
                        };

                        Sizzle.escape = function(sel) {
                            return (sel + "").replace(rcssescape, fcssescape);
                        };

                        Sizzle.error = function(msg) {
                            throw new Error("Syntax error, unrecognized expression: " + msg);
                        };

                        Sizzle.uniqueSort = function(results) {
                            var elem,
                                duplicates = [],
                                j = 0,
                                i = 0;

                            // Unless we *know* we can detect duplicates, assume their presence
                            hasDuplicate = !support.detectDuplicates;
                            sortInput = !support.sortStable && results.slice(0);
                            results.sort(sortOrder);

                            if (hasDuplicate) {
                                while ((elem = results[i++])) {
                                    if (elem === results[i]) {
                                        j = duplicates.push(i);
                                    }
                                }
                                while (j--) {
                                    results.splice(duplicates[j], 1);
                                }
                            }

                            // Clear input after sorting to release objects
                            // See https://github.com/jquery/sizzle/pull/225
                            sortInput = null;

                            return results;
                        };

                        getText = Sizzle.getText = function(elem) {
                            var node,
                                ret = "",
                                i = 0,
                                nodeType = elem.nodeType;

                            if (!nodeType) {
                                // If no nodeType, this is expected to be an array
                                while ((node = elem[i++])) {
                                    // Do not traverse comment nodes
                                    ret += getText(node);
                                }
                            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                                // Use textContent for elements
                                // innerText usage removed for consistency of new lines (jQuery #11153)
                                if (typeof elem.textContent === "string") {
                                    return elem.textContent;
                                } else {
                                    // Traverse its children
                                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                        ret += getText(elem);
                                    }
                                }
                            } else if (nodeType === 3 || nodeType === 4) {
                                return elem.nodeValue;
                            }
                            // Do not include comment or processing instruction nodes

                            return ret;
                        };

                        Expr = Sizzle.selectors = {

                            // Can be adjusted by the user
                            cacheLength: 50,

                            createPseudo: markFunction,

                            match: matchExpr,

                            attrHandle: {},

                            find: {},

                            relative: {
                                ">": {
                                    dir: "parentNode",
                                    first: true
                                },
                                " ": {
                                    dir: "parentNode"
                                },
                                "+": {
                                    dir: "previousSibling",
                                    first: true
                                },
                                "~": {
                                    dir: "previousSibling"
                                }
                            },

                            preFilter: {
                                "ATTR": function(match) {
                                    match[1] = match[1].replace(runescape, funescape);

                                    // Move the given value to match[3] whether quoted or unquoted
                                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                                    if (match[2] === "~=") {
                                        match[3] = " " + match[3] + " ";
                                    }

                                    return match.slice(0, 4);
                                },

                                "CHILD": function(match) {

                                    match[1] = match[1].toLowerCase();

                                    if (match[1].slice(0, 3) === "nth") {
                                        // nth-* requires argument
                                        if (!match[3]) {
                                            Sizzle.error(match[0]);
                                        }

                                        // numeric x and y parameters for Expr.filter.CHILD
                                        // remember that false/true cast respectively to 0/1
                                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                                        match[5] = +((match[7] + match[8]) || match[3] === "odd");

                                        // other types prohibit arguments
                                    } else if (match[3]) {
                                        Sizzle.error(match[0]);
                                    }

                                    return match;
                                },

                                "PSEUDO": function(match) {
                                    var excess,
                                        unquoted = !match[6] && match[2];

                                    if (matchExpr["CHILD"].test(match[0])) {
                                        return null;
                                    }

                                    // Accept quoted arguments as-is
                                    if (match[3]) {
                                        match[2] = match[4] || match[5] || "";

                                        // Strip excess characters from unquoted arguments
                                    } else if (unquoted && rpseudo.test(unquoted) &&
                                        // Get excess from tokenize (recursively)
                                        (excess = tokenize(unquoted, true)) &&
                                        // advance to the next closing parenthesis
                                        (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                                        // excess is a negative index
                                        match[0] = match[0].slice(0, excess);
                                        match[2] = unquoted.slice(0, excess);
                                    }

                                    // Return only captures needed by the pseudo filter method (type and argument)
                                    return match.slice(0, 3);
                                }
                            },

                            filter: {

                                "TAG": function(nodeNameSelector) {
                                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                                    return nodeNameSelector === "*" ?
                                        function() {
                                            return true;
                                        } :
                                        function(elem) {
                                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                        };
                                },

                                "CLASS": function(className) {
                                    var pattern = classCache[className + " "];

                                    return pattern ||
                                        (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                                        classCache(className, function(elem) {
                                            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                                        });
                                },

                                "ATTR": function(name, operator, check) {
                                    return function(elem) {
                                        var result = Sizzle.attr(elem, name);

                                        if (result == null) {
                                            return operator === "!=";
                                        }
                                        if (!operator) {
                                            return true;
                                        }

                                        result += "";

                                        return operator === "=" ? result === check :
                                            operator === "!=" ? result !== check :
                                            operator === "^=" ? check && result.indexOf(check) === 0 :
                                            operator === "*=" ? check && result.indexOf(check) > -1 :
                                            operator === "$=" ? check && result.slice(-check.length) === check :
                                            operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                                            operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                            false;
                                    };
                                },

                                "CHILD": function(type, what, argument, first, last) {
                                    var simple = type.slice(0, 3) !== "nth",
                                        forward = type.slice(-4) !== "last",
                                        ofType = what === "of-type";

                                    return first === 1 && last === 0 ?

                                        // Shortcut for :nth-*(n)
                                        function(elem) {
                                            return !!elem.parentNode;
                                        } :

                                        function(elem, context, xml) {
                                            var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                                dir = simple !== forward ? "nextSibling" : "previousSibling",
                                                parent = elem.parentNode,
                                                name = ofType && elem.nodeName.toLowerCase(),
                                                useCache = !xml && !ofType,
                                                diff = false;

                                            if (parent) {

                                                // :(first|last|only)-(child|of-type)
                                                if (simple) {
                                                    while (dir) {
                                                        node = elem;
                                                        while ((node = node[dir])) {
                                                            if (ofType ?
                                                                node.nodeName.toLowerCase() === name :
                                                                node.nodeType === 1) {

                                                                return false;
                                                            }
                                                        }
                                                        // Reverse direction for :only-* (if we haven't yet done so)
                                                        start = dir = type === "only" && !start && "nextSibling";
                                                    }
                                                    return true;
                                                }

                                                start = [forward ? parent.firstChild : parent.lastChild];

                                                // non-xml :nth-child(...) stores cache data on `parent`
                                                if (forward && useCache) {

                                                    // Seek `elem` from a previously-cached index

                                                    // ...in a gzip-friendly way
                                                    node = parent;
                                                    outerCache = node[expando] || (node[expando] = {});

                                                    // Support: IE <9 only
                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                    uniqueCache = outerCache[node.uniqueID] ||
                                                        (outerCache[node.uniqueID] = {});

                                                    cache = uniqueCache[type] || [];
                                                    nodeIndex = cache[0] === dirruns && cache[1];
                                                    diff = nodeIndex && cache[2];
                                                    node = nodeIndex && parent.childNodes[nodeIndex];

                                                    while ((node = ++nodeIndex && node && node[dir] ||

                                                            // Fallback to seeking `elem` from the start
                                                            (diff = nodeIndex = 0) || start.pop())) {

                                                        // When found, cache indexes on `parent` and break
                                                        if (node.nodeType === 1 && ++diff && node === elem) {
                                                            uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                            break;
                                                        }
                                                    }

                                                } else {
                                                    // Use previously-cached element index if available
                                                    if (useCache) {
                                                        // ...in a gzip-friendly way
                                                        node = elem;
                                                        outerCache = node[expando] || (node[expando] = {});

                                                        // Support: IE <9 only
                                                        // Defend against cloned attroperties (jQuery gh-1709)
                                                        uniqueCache = outerCache[node.uniqueID] ||
                                                            (outerCache[node.uniqueID] = {});

                                                        cache = uniqueCache[type] || [];
                                                        nodeIndex = cache[0] === dirruns && cache[1];
                                                        diff = nodeIndex;
                                                    }

                                                    // xml :nth-child(...)
                                                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                    if (diff === false) {
                                                        // Use the same loop as above to seek `elem` from the start
                                                        while ((node = ++nodeIndex && node && node[dir] ||
                                                                (diff = nodeIndex = 0) || start.pop())) {

                                                            if ((ofType ?
                                                                    node.nodeName.toLowerCase() === name :
                                                                    node.nodeType === 1) &&
                                                                ++diff) {

                                                                // Cache the index of each encountered element
                                                                if (useCache) {
                                                                    outerCache = node[expando] || (node[expando] = {});

                                                                    // Support: IE <9 only
                                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                                    uniqueCache = outerCache[node.uniqueID] ||
                                                                        (outerCache[node.uniqueID] = {});

                                                                    uniqueCache[type] = [dirruns, diff];
                                                                }

                                                                if (node === elem) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                // Incorporate the offset, then check against cycle size
                                                diff -= last;
                                                return diff === first || (diff % first === 0 && diff / first >= 0);
                                            }
                                        };
                                },

                                "PSEUDO": function(pseudo, argument) {
                                    // pseudo-class names are case-insensitive
                                    // http://www.w3.org/TR/selectors/#pseudo-classes
                                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                    // Remember that setFilters inherits from pseudos
                                    var args,
                                        fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                        Sizzle.error("unsupported pseudo: " + pseudo);

                                    // The user may use createPseudo to indicate that
                                    // arguments are needed to create the filter function
                                    // just as Sizzle does
                                    if (fn[expando]) {
                                        return fn(argument);
                                    }

                                    // But maintain support for old signatures
                                    if (fn.length > 1) {
                                        args = [pseudo, pseudo, "", argument];
                                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                            markFunction(function(seed, matches) {
                                                var idx,
                                                    matched = fn(seed, argument),
                                                    i = matched.length;
                                                while (i--) {
                                                    idx = indexOf(seed, matched[i]);
                                                    seed[idx] = !(matches[idx] = matched[i]);
                                                }
                                            }) :
                                            function(elem) {
                                                return fn(elem, 0, args);
                                            };
                                    }

                                    return fn;
                                }
                            },

                            pseudos: {
                                // Potentially complex pseudos
                                "not": markFunction(function(selector) {
                                    // Trim the selector passed to compile
                                    // to avoid treating leading and trailing
                                    // spaces as combinators
                                    var input = [],
                                        results = [],
                                        matcher = compile(selector.replace(rtrim, "$1"));

                                    return matcher[expando] ?
                                        markFunction(function(seed, matches, context, xml) {
                                            var elem,
                                                unmatched = matcher(seed, null, xml, []),
                                                i = seed.length;

                                            // Match elements unmatched by `matcher`
                                            while (i--) {
                                                if ((elem = unmatched[i])) {
                                                    seed[i] = !(matches[i] = elem);
                                                }
                                            }
                                        }) :
                                        function(elem, context, xml) {
                                            input[0] = elem;
                                            matcher(input, null, xml, results);
                                            // Don't keep the element (issue #299)
                                            input[0] = null;
                                            return !results.pop();
                                        };
                                }),

                                "has": markFunction(function(selector) {
                                    return function(elem) {
                                        return Sizzle(selector, elem).length > 0;
                                    };
                                }),

                                "contains": markFunction(function(text) {
                                    text = text.replace(runescape, funescape);
                                    return function(elem) {
                                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                                    };
                                }),

                                // "Whether an element is represented by a :lang() selector
                                // is based solely on the element's language value
                                // being equal to the identifier C,
                                // or beginning with the identifier C immediately followed by "-".
                                // The matching of C against the element's language value is performed case-insensitively.
                                // The identifier C does not have to be a valid language name."
                                // http://www.w3.org/TR/selectors/#lang-pseudo
                                "lang": markFunction(function(lang) {
                                    // lang value must be a valid identifier
                                    if (!ridentifier.test(lang || "")) {
                                        Sizzle.error("unsupported lang: " + lang);
                                    }
                                    lang = lang.replace(runescape, funescape).toLowerCase();
                                    return function(elem) {
                                        var elemLang;
                                        do {
                                            if ((elemLang = documentIsHTML ?
                                                    elem.lang :
                                                    elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                                elemLang = elemLang.toLowerCase();
                                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                            }
                                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                        return false;
                                    };
                                }),

                                // Miscellaneous
                                "target": function(elem) {
                                    var hash = window.location && window.location.hash;
                                    return hash && hash.slice(1) === elem.id;
                                },

                                "root": function(elem) {
                                    return elem === docElem;
                                },

                                "focus": function(elem) {
                                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                                },

                                // Boolean properties
                                "enabled": createDisabledPseudo(false),
                                "disabled": createDisabledPseudo(true),

                                "checked": function(elem) {
                                    // In CSS3, :checked should return both checked and selected elements
                                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                    var nodeName = elem.nodeName.toLowerCase();
                                    return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                                },

                                "selected": function(elem) {
                                    // Accessing this property makes selected-by-default
                                    // options in Safari work properly
                                    if (elem.parentNode) {
                                        elem.parentNode.selectedIndex;
                                    }

                                    return elem.selected === true;
                                },

                                // Contents
                                "empty": function(elem) {
                                    // http://www.w3.org/TR/selectors/#empty-pseudo
                                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                                    // nodeType < 6 works because attributes (2) do not appear as children
                                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                        if (elem.nodeType < 6) {
                                            return false;
                                        }
                                    }
                                    return true;
                                },

                                "parent": function(elem) {
                                    return !Expr.pseudos["empty"](elem);
                                },

                                // Element/input types
                                "header": function(elem) {
                                    return rheader.test(elem.nodeName);
                                },

                                "input": function(elem) {
                                    return rinputs.test(elem.nodeName);
                                },

                                "button": function(elem) {
                                    var name = elem.nodeName.toLowerCase();
                                    return name === "input" && elem.type === "button" || name === "button";
                                },

                                "text": function(elem) {
                                    var attr;
                                    return elem.nodeName.toLowerCase() === "input" &&
                                        elem.type === "text" &&

                                        // Support: IE<8
                                        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                        ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                                },

                                // Position-in-collection
                                "first": createPositionalPseudo(function() {
                                    return [0];
                                }),

                                "last": createPositionalPseudo(function(matchIndexes, length) {
                                    return [length - 1];
                                }),

                                "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                                    return [argument < 0 ? argument + length : argument];
                                }),

                                "even": createPositionalPseudo(function(matchIndexes, length) {
                                    var i = 0;
                                    for (; i < length; i += 2) {
                                        matchIndexes.push(i);
                                    }
                                    return matchIndexes;
                                }),

                                "odd": createPositionalPseudo(function(matchIndexes, length) {
                                    var i = 1;
                                    for (; i < length; i += 2) {
                                        matchIndexes.push(i);
                                    }
                                    return matchIndexes;
                                }),

                                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                                    var i = argument < 0 ? argument + length : argument;
                                    for (; --i >= 0;) {
                                        matchIndexes.push(i);
                                    }
                                    return matchIndexes;
                                }),

                                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                                    var i = argument < 0 ? argument + length : argument;
                                    for (; ++i < length;) {
                                        matchIndexes.push(i);
                                    }
                                    return matchIndexes;
                                })
                            }
                        };

                        Expr.pseudos["nth"] = Expr.pseudos["eq"];

                        // Add button/input type pseudos
                        for (i in {
                                radio: true,
                                checkbox: true,
                                file: true,
                                password: true,
                                image: true
                            }) {
                            Expr.pseudos[i] = createInputPseudo(i);
                        }
                        for (i in {
                                submit: true,
                                reset: true
                            }) {
                            Expr.pseudos[i] = createButtonPseudo(i);
                        }

                        // Easy API for creating new setFilters
                        function setFilters() {}
                        setFilters.prototype = Expr.filters = Expr.pseudos;
                        Expr.setFilters = new setFilters();

                        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                            var matched, match, tokens, type,
                                soFar, groups, preFilters,
                                cached = tokenCache[selector + " "];

                            if (cached) {
                                return parseOnly ? 0 : cached.slice(0);
                            }

                            soFar = selector;
                            groups = [];
                            preFilters = Expr.preFilter;

                            while (soFar) {

                                // Comma and first run
                                if (!matched || (match = rcomma.exec(soFar))) {
                                    if (match) {
                                        // Don't consume trailing commas as valid
                                        soFar = soFar.slice(match[0].length) || soFar;
                                    }
                                    groups.push((tokens = []));
                                }

                                matched = false;

                                // Combinators
                                if ((match = rcombinators.exec(soFar))) {
                                    matched = match.shift();
                                    tokens.push({
                                        value: matched,
                                        // Cast descendant combinators to space
                                        type: match[0].replace(rtrim, " ")
                                    });
                                    soFar = soFar.slice(matched.length);
                                }

                                // Filters
                                for (type in Expr.filter) {
                                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                                            (match = preFilters[type](match)))) {
                                        matched = match.shift();
                                        tokens.push({
                                            value: matched,
                                            type: type,
                                            matches: match
                                        });
                                        soFar = soFar.slice(matched.length);
                                    }
                                }

                                if (!matched) {
                                    break;
                                }
                            }

                            // Return the length of the invalid excess
                            // if we're just parsing
                            // Otherwise, throw an error or return tokens
                            return parseOnly ?
                                soFar.length :
                                soFar ?
                                Sizzle.error(selector) :
                                // Cache the tokens
                                tokenCache(selector, groups).slice(0);
                        };

                        function toSelector(tokens) {
                            var i = 0,
                                len = tokens.length,
                                selector = "";
                            for (; i < len; i++) {
                                selector += tokens[i].value;
                            }
                            return selector;
                        }

                        function addCombinator(matcher, combinator, base) {
                            var dir = combinator.dir,
                                skip = combinator.next,
                                key = skip || dir,
                                checkNonElements = base && key === "parentNode",
                                doneName = done++;

                            return combinator.first ?
                                // Check against closest ancestor/preceding element
                                function(elem, context, xml) {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            return matcher(elem, context, xml);
                                        }
                                    }
                                    return false;
                                } :

                                // Check against all ancestor/preceding elements
                                function(elem, context, xml) {
                                    var oldCache, uniqueCache, outerCache,
                                        newCache = [dirruns, doneName];

                                    // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                                    if (xml) {
                                        while ((elem = elem[dir])) {
                                            if (elem.nodeType === 1 || checkNonElements) {
                                                if (matcher(elem, context, xml)) {
                                                    return true;
                                                }
                                            }
                                        }
                                    } else {
                                        while ((elem = elem[dir])) {
                                            if (elem.nodeType === 1 || checkNonElements) {
                                                outerCache = elem[expando] || (elem[expando] = {});

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                                                if (skip && skip === elem.nodeName.toLowerCase()) {
                                                    elem = elem[dir] || elem;
                                                } else if ((oldCache = uniqueCache[key]) &&
                                                    oldCache[0] === dirruns && oldCache[1] === doneName) {

                                                    // Assign to newCache so results back-propagate to previous elements
                                                    return (newCache[2] = oldCache[2]);
                                                } else {
                                                    // Reuse newcache so results back-propagate to previous elements
                                                    uniqueCache[key] = newCache;

                                                    // A match means we're done; a fail means we have to keep checking
                                                    if ((newCache[2] = matcher(elem, context, xml))) {
                                                        return true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    return false;
                                };
                        }

                        function elementMatcher(matchers) {
                            return matchers.length > 1 ?
                                function(elem, context, xml) {
                                    var i = matchers.length;
                                    while (i--) {
                                        if (!matchers[i](elem, context, xml)) {
                                            return false;
                                        }
                                    }
                                    return true;
                                } :
                                matchers[0];
                        }

                        function multipleContexts(selector, contexts, results) {
                            var i = 0,
                                len = contexts.length;
                            for (; i < len; i++) {
                                Sizzle(selector, contexts[i], results);
                            }
                            return results;
                        }

                        function condense(unmatched, map, filter, context, xml) {
                            var elem,
                                newUnmatched = [],
                                i = 0,
                                len = unmatched.length,
                                mapped = map != null;

                            for (; i < len; i++) {
                                if ((elem = unmatched[i])) {
                                    if (!filter || filter(elem, context, xml)) {
                                        newUnmatched.push(elem);
                                        if (mapped) {
                                            map.push(i);
                                        }
                                    }
                                }
                            }

                            return newUnmatched;
                        }

                        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                            if (postFilter && !postFilter[expando]) {
                                postFilter = setMatcher(postFilter);
                            }
                            if (postFinder && !postFinder[expando]) {
                                postFinder = setMatcher(postFinder, postSelector);
                            }
                            return markFunction(function(seed, results, context, xml) {
                                var temp, i, elem,
                                    preMap = [],
                                    postMap = [],
                                    preexisting = results.length,

                                    // Get initial elements from seed or context
                                    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                                    // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                    matcherIn = preFilter && (seed || !selector) ?
                                    condense(elems, preMap, preFilter, context, xml) :
                                    elems,

                                    matcherOut = matcher ?
                                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                    postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                    // ...intermediate processing is necessary
                                    [] :

                                    // ...otherwise use results directly
                                    results :
                                    matcherIn;

                                // Find primary matches
                                if (matcher) {
                                    matcher(matcherIn, matcherOut, context, xml);
                                }

                                // Apply postFilter
                                if (postFilter) {
                                    temp = condense(matcherOut, postMap);
                                    postFilter(temp, [], context, xml);

                                    // Un-match failing elements by moving them back to matcherIn
                                    i = temp.length;
                                    while (i--) {
                                        if ((elem = temp[i])) {
                                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                        }
                                    }
                                }

                                if (seed) {
                                    if (postFinder || preFilter) {
                                        if (postFinder) {
                                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                            temp = [];
                                            i = matcherOut.length;
                                            while (i--) {
                                                if ((elem = matcherOut[i])) {
                                                    // Restore matcherIn since elem is not yet a final match
                                                    temp.push((matcherIn[i] = elem));
                                                }
                                            }
                                            postFinder(null, (matcherOut = []), temp, xml);
                                        }

                                        // Move matched elements from seed to results to keep them synchronized
                                        i = matcherOut.length;
                                        while (i--) {
                                            if ((elem = matcherOut[i]) &&
                                                (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                                seed[temp] = !(results[temp] = elem);
                                            }
                                        }
                                    }

                                    // Add elements to results, through postFinder if defined
                                } else {
                                    matcherOut = condense(
                                        matcherOut === results ?
                                        matcherOut.splice(preexisting, matcherOut.length) :
                                        matcherOut
                                    );
                                    if (postFinder) {
                                        postFinder(null, results, matcherOut, xml);
                                    } else {
                                        push.apply(results, matcherOut);
                                    }
                                }
                            });
                        }

                        function matcherFromTokens(tokens) {
                            var checkContext, matcher, j,
                                len = tokens.length,
                                leadingRelative = Expr.relative[tokens[0].type],
                                implicitRelative = leadingRelative || Expr.relative[" "],
                                i = leadingRelative ? 1 : 0,

                                // The foundational matcher ensures that elements are reachable from top-level context(s)
                                matchContext = addCombinator(function(elem) {
                                    return elem === checkContext;
                                }, implicitRelative, true),
                                matchAnyContext = addCombinator(function(elem) {
                                    return indexOf(checkContext, elem) > -1;
                                }, implicitRelative, true),
                                matchers = [function(elem, context, xml) {
                                    var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
                                        (checkContext = context).nodeType ?
                                        matchContext(elem, context, xml) :
                                        matchAnyContext(elem, context, xml));
                                    // Avoid hanging onto element (issue #299)
                                    checkContext = null;
                                    return ret;
                                }];

                            for (; i < len; i++) {
                                if ((matcher = Expr.relative[tokens[i].type])) {
                                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                                } else {
                                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                                    // Return special upon seeing a positional matcher
                                    if (matcher[expando]) {
                                        // Find the next relative operator (if any) for proper handling
                                        j = ++i;
                                        for (; j < len; j++) {
                                            if (Expr.relative[tokens[j].type]) {
                                                break;
                                            }
                                        }
                                        return setMatcher(
                                            i > 1 && elementMatcher(matchers),
                                            i > 1 && toSelector(
                                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                                tokens.slice(0, i - 1).concat({
                                                    value: tokens[i - 2].type === " " ? "*" : ""
                                                })
                                            ).replace(rtrim, "$1"),
                                            matcher,
                                            i < j && matcherFromTokens(tokens.slice(i, j)),
                                            j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                            j < len && toSelector(tokens)
                                        );
                                    }
                                    matchers.push(matcher);
                                }
                            }

                            return elementMatcher(matchers);
                        }

                        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                            var bySet = setMatchers.length > 0,
                                byElement = elementMatchers.length > 0,
                                superMatcher = function(seed, context, xml, results, outermost) {
                                    var elem, j, matcher,
                                        matchedCount = 0,
                                        i = "0",
                                        unmatched = seed && [],
                                        setMatched = [],
                                        contextBackup = outermostContext,
                                        // We must always have either seed elements or outermost context
                                        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                                        // Use integer dirruns iff this is the outermost matcher
                                        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                        len = elems.length;

                                    if (outermost) {
                                        outermostContext = context === document || context || outermost;
                                    }

                                    // Add elements passing elementMatchers directly to results
                                    // Support: IE<9, Safari
                                    // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                    for (; i !== len && (elem = elems[i]) != null; i++) {
                                        if (byElement && elem) {
                                            j = 0;
                                            if (!context && elem.ownerDocument !== document) {
                                                setDocument(elem);
                                                xml = !documentIsHTML;
                                            }
                                            while ((matcher = elementMatchers[j++])) {
                                                if (matcher(elem, context || document, xml)) {
                                                    results.push(elem);
                                                    break;
                                                }
                                            }
                                            if (outermost) {
                                                dirruns = dirrunsUnique;
                                            }
                                        }

                                        // Track unmatched elements for set filters
                                        if (bySet) {
                                            // They will have gone through all possible matchers
                                            if ((elem = !matcher && elem)) {
                                                matchedCount--;
                                            }

                                            // Lengthen the array for every element, matched or not
                                            if (seed) {
                                                unmatched.push(elem);
                                            }
                                        }
                                    }

                                    // `i` is now the count of elements visited above, and adding it to `matchedCount`
                                    // makes the latter nonnegative.
                                    matchedCount += i;

                                    // Apply set filters to unmatched elements
                                    // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                                    // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                                    // no element matchers and no seed.
                                    // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                                    // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                                    // numerically zero.
                                    if (bySet && i !== matchedCount) {
                                        j = 0;
                                        while ((matcher = setMatchers[j++])) {
                                            matcher(unmatched, setMatched, context, xml);
                                        }

                                        if (seed) {
                                            // Reintegrate element matches to eliminate the need for sorting
                                            if (matchedCount > 0) {
                                                while (i--) {
                                                    if (!(unmatched[i] || setMatched[i])) {
                                                        setMatched[i] = pop.call(results);
                                                    }
                                                }
                                            }

                                            // Discard index placeholder values to get only actual matches
                                            setMatched = condense(setMatched);
                                        }

                                        // Add matches to results
                                        push.apply(results, setMatched);

                                        // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                        if (outermost && !seed && setMatched.length > 0 &&
                                            (matchedCount + setMatchers.length) > 1) {

                                            Sizzle.uniqueSort(results);
                                        }
                                    }

                                    // Override manipulation of globals by nested matchers
                                    if (outermost) {
                                        dirruns = dirrunsUnique;
                                        outermostContext = contextBackup;
                                    }

                                    return unmatched;
                                };

                            return bySet ?
                                markFunction(superMatcher) :
                                superMatcher;
                        }

                        compile = Sizzle.compile = function(selector, match) {
                            var i,
                                setMatchers = [],
                                elementMatchers = [],
                                cached = compilerCache[selector + " "];

                            if (!cached) {
                                // Generate a function of recursive functions that can be used to check each element
                                if (!match) {
                                    match = tokenize(selector);
                                }
                                i = match.length;
                                while (i--) {
                                    cached = matcherFromTokens(match[i]);
                                    if (cached[expando]) {
                                        setMatchers.push(cached);
                                    } else {
                                        elementMatchers.push(cached);
                                    }
                                }

                                // Cache the compiled function
                                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                                // Save selector and tokenization
                                cached.selector = selector;
                            }
                            return cached;
                        };

                        select = Sizzle.select = function(selector, context, results, seed) {
                            var i, tokens, token, type, find,
                                compiled = typeof selector === "function" && selector,
                                match = !seed && tokenize((selector = compiled.selector || selector));

                            results = results || [];

                            // Try to minimize operations if there is only one selector in the list and no seed
                            // (the latter of which guarantees us context)
                            if (match.length === 1) {

                                // Reduce context if the leading compound selector is an ID
                                tokens = match[0] = match[0].slice(0);
                                if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                    context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                                    if (!context) {
                                        return results;

                                        // Precompiled matchers will still verify ancestry, so step up a level
                                    } else if (compiled) {
                                        context = context.parentNode;
                                    }

                                    selector = selector.slice(tokens.shift().value.length);
                                }

                                // Fetch a seed set for right-to-left matching
                                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                                while (i--) {
                                    token = tokens[i];

                                    // Abort if we hit a combinator
                                    if (Expr.relative[(type = token.type)]) {
                                        break;
                                    }
                                    if ((find = Expr.find[type])) {
                                        // Search, expanding context for leading sibling combinators
                                        if ((seed = find(
                                                token.matches[0].replace(runescape, funescape),
                                                rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                            ))) {

                                            // If seed is empty or no tokens remain, we can return early
                                            tokens.splice(i, 1);
                                            selector = seed.length && toSelector(tokens);
                                            if (!selector) {
                                                push.apply(results, seed);
                                                return results;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }

                            // Compile and execute a filtering function if one is not provided
                            // Provide `match` to avoid retokenization if we modified the selector above
                            (compiled || compile(selector, match))(
                                seed,
                                context, !documentIsHTML,
                                results, !context || rsibling.test(selector) && testContext(context.parentNode) || context
                            );
                            return results;
                        };

                        // One-time assignments

                        // Sort stability
                        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

                        // Support: Chrome 14-35+
                        // Always assume duplicates if they aren't passed to the comparison function
                        support.detectDuplicates = !!hasDuplicate;

                        // Initialize against the default document
                        setDocument();

                        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                        // Detached nodes confoundingly follow *each other*
                        support.sortDetached = assert(function(el) {
                            // Should return 1, but returns 4 (following)
                            return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
                        });

                        // Support: IE<8
                        // Prevent attribute/property "interpolation"
                        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                        if (!assert(function(el) {
                                el.innerHTML = "<a href='#'></a>";
                                return el.firstChild.getAttribute("href") === "#";
                            })) {
                            addHandle("type|href|height|width", function(elem, name, isXML) {
                                if (!isXML) {
                                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                                }
                            });
                        }

                        // Support: IE<9
                        // Use defaultValue in place of getAttribute("value")
                        if (!support.attributes || !assert(function(el) {
                                el.innerHTML = "<input/>";
                                el.firstChild.setAttribute("value", "");
                                return el.firstChild.getAttribute("value") === "";
                            })) {
                            addHandle("value", function(elem, name, isXML) {
                                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                                    return elem.defaultValue;
                                }
                            });
                        }

                        // Support: IE<9
                        // Use getAttributeNode to fetch booleans when getAttribute lies
                        if (!assert(function(el) {
                                return el.getAttribute("disabled") == null;
                            })) {
                            addHandle(booleans, function(elem, name, isXML) {
                                var val;
                                if (!isXML) {
                                    return elem[name] === true ? name.toLowerCase() :
                                        (val = elem.getAttributeNode(name)) && val.specified ?
                                        val.value :
                                        null;
                                }
                            });
                        }

                        return Sizzle;

                    })(window);

                jQuery.find = Sizzle;
                jQuery.expr = Sizzle.selectors;

                // Deprecated
                jQuery.expr[":"] = jQuery.expr.pseudos;
                jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
                jQuery.text = Sizzle.getText;
                jQuery.isXMLDoc = Sizzle.isXML;
                jQuery.contains = Sizzle.contains;
                jQuery.escapeSelector = Sizzle.escape;

                var dir = function(elem, dir, until) {
                    var matched = [],
                        truncate = until !== undefined;

                    while ((elem = elem[dir]) && elem.nodeType !== 9) {
                        if (elem.nodeType === 1) {
                            if (truncate && jQuery(elem).is(until)) {
                                break;
                            }
                            matched.push(elem);
                        }
                    }
                    return matched;
                };

                var siblings = function(n, elem) {
                    var matched = [];

                    for (; n; n = n.nextSibling) {
                        if (n.nodeType === 1 && n !== elem) {
                            matched.push(n);
                        }
                    }

                    return matched;
                };

                var rneedsContext = jQuery.expr.match.needsContext;

                var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);

                var risSimple = /^.[^:#\[\.,]*$/;

                // Implement the identical functionality for filter and not
                function winnow(elements, qualifier, not) {
                    if (jQuery.isFunction(qualifier)) {
                        return jQuery.grep(elements, function(elem, i) {
                            return !!qualifier.call(elem, i, elem) !== not;
                        });
                    }

                    // Single element
                    if (qualifier.nodeType) {
                        return jQuery.grep(elements, function(elem) {
                            return (elem === qualifier) !== not;
                        });
                    }

                    // Arraylike of elements (jQuery, arguments, Array)
                    if (typeof qualifier !== "string") {
                        return jQuery.grep(elements, function(elem) {
                            return (indexOf.call(qualifier, elem) > -1) !== not;
                        });
                    }

                    // Simple selector that can be filtered directly, removing non-Elements
                    if (risSimple.test(qualifier)) {
                        return jQuery.filter(qualifier, elements, not);
                    }

                    // Complex selector, compare the two sets, removing non-Elements
                    qualifier = jQuery.filter(qualifier, elements);
                    return jQuery.grep(elements, function(elem) {
                        return (indexOf.call(qualifier, elem) > -1) !== not && elem.nodeType === 1;
                    });
                }

                jQuery.filter = function(expr, elems, not) {
                    var elem = elems[0];

                    if (not) {
                        expr = ":not(" + expr + ")";
                    }

                    if (elems.length === 1 && elem.nodeType === 1) {
                        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
                    }

                    return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                        return elem.nodeType === 1;
                    }));
                };

                jQuery.fn.extend({
                    find: function(selector) {
                        var i, ret,
                            len = this.length,
                            self = this;

                        if (typeof selector !== "string") {
                            return this.pushStack(jQuery(selector).filter(function() {
                                for (i = 0; i < len; i++) {
                                    if (jQuery.contains(self[i], this)) {
                                        return true;
                                    }
                                }
                            }));
                        }

                        ret = this.pushStack([]);

                        for (i = 0; i < len; i++) {
                            jQuery.find(selector, self[i], ret);
                        }

                        return len > 1 ? jQuery.uniqueSort(ret) : ret;
                    },
                    filter: function(selector) {
                        return this.pushStack(winnow(this, selector || [], false));
                    },
                    not: function(selector) {
                        return this.pushStack(winnow(this, selector || [], true));
                    },
                    is: function(selector) {
                        return !!winnow(
                            this,

                            // If this is a positional/relative selector, check membership in the returned set
                            // so $("p:first").is("p:last") won't return true for a doc with two "p".
                            typeof selector === "string" && rneedsContext.test(selector) ?
                            jQuery(selector) :
                            selector || [],
                            false
                        ).length;
                    }
                });

                // Initialize a jQuery object

                // A central reference to the root jQuery(document)
                var rootjQuery,

                    // A simple way to check for HTML strings
                    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                    // Strict HTML recognition (#11290: must start with <)
                    // Shortcut simple #id case for speed
                    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

                    init = jQuery.fn.init = function(selector, context, root) {
                        var match, elem;

                        // HANDLE: $(""), $(null), $(undefined), $(false)
                        if (!selector) {
                            return this;
                        }

                        // Method init() accepts an alternate rootjQuery
                        // so migrate can support jQuery.sub (gh-2101)
                        root = root || rootjQuery;

                        // Handle HTML strings
                        if (typeof selector === "string") {
                            if (selector[0] === "<" &&
                                selector[selector.length - 1] === ">" &&
                                selector.length >= 3) {

                                // Assume that strings that start and end with <> are HTML and skip the regex check
                                match = [null, selector, null];

                            } else {
                                match = rquickExpr.exec(selector);
                            }

                            // Match html or make sure no context is specified for #id
                            if (match && (match[1] || !context)) {

                                // HANDLE: $(html) -> $(array)
                                if (match[1]) {
                                    context = context instanceof jQuery ? context[0] : context;

                                    // Option to run scripts is true for back-compat
                                    // Intentionally let the error be thrown if parseHTML is not present
                                    jQuery.merge(this, jQuery.parseHTML(
                                        match[1],
                                        context && context.nodeType ? context.ownerDocument || context : document,
                                        true
                                    ));

                                    // HANDLE: $(html, props)
                                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                        for (match in context) {

                                            // Properties of context are called as methods if possible
                                            if (jQuery.isFunction(this[match])) {
                                                this[match](context[match]);

                                                // ...and otherwise set as attributes
                                            } else {
                                                this.attr(match, context[match]);
                                            }
                                        }
                                    }

                                    return this;

                                    // HANDLE: $(#id)
                                } else {
                                    elem = document.getElementById(match[2]);

                                    if (elem) {

                                        // Inject the element directly into the jQuery object
                                        this[0] = elem;
                                        this.length = 1;
                                    }
                                    return this;
                                }

                                // HANDLE: $(expr, $(...))
                            } else if (!context || context.jquery) {
                                return (context || root).find(selector);

                                // HANDLE: $(expr, context)
                                // (which is just equivalent to: $(context).find(expr)
                            } else {
                                return this.constructor(context).find(selector);
                            }

                            // HANDLE: $(DOMElement)
                        } else if (selector.nodeType) {
                            this[0] = selector;
                            this.length = 1;
                            return this;

                            // HANDLE: $(function)
                            // Shortcut for document ready
                        } else if (jQuery.isFunction(selector)) {
                            return root.ready !== undefined ?
                                root.ready(selector) :

                                // Execute immediately if ready is not present
                                selector(jQuery);
                        }

                        return jQuery.makeArray(selector, this);
                    };

                // Give the init function the jQuery prototype for later instantiation
                init.prototype = jQuery.fn;

                // Initialize central reference
                rootjQuery = jQuery(document);

                var rparentsprev = /^(?:parents|prev(?:Until|All))/,

                    // Methods guaranteed to produce a unique set when starting from a unique set
                    guaranteedUnique = {
                        children: true,
                        contents: true,
                        next: true,
                        prev: true
                    };

                jQuery.fn.extend({
                    has: function(target) {
                        var targets = jQuery(target, this),
                            l = targets.length;

                        return this.filter(function() {
                            var i = 0;
                            for (; i < l; i++) {
                                if (jQuery.contains(this, targets[i])) {
                                    return true;
                                }
                            }
                        });
                    },

                    closest: function(selectors, context) {
                        var cur,
                            i = 0,
                            l = this.length,
                            matched = [],
                            targets = typeof selectors !== "string" && jQuery(selectors);

                        // Positional selectors never match, since there's no _selection_ context
                        if (!rneedsContext.test(selectors)) {
                            for (; i < l; i++) {
                                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                                    // Always skip document fragments
                                    if (cur.nodeType < 11 && (targets ?
                                            targets.index(cur) > -1 :

                                            // Don't pass non-elements to Sizzle
                                            cur.nodeType === 1 &&
                                            jQuery.find.matchesSelector(cur, selectors))) {

                                        matched.push(cur);
                                        break;
                                    }
                                }
                            }
                        }

                        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
                    },

                    // Determine the position of an element within the set
                    index: function(elem) {

                        // No argument, return index in parent
                        if (!elem) {
                            return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
                        }

                        // Index in selector
                        if (typeof elem === "string") {
                            return indexOf.call(jQuery(elem), this[0]);
                        }

                        // Locate the position of the desired element
                        return indexOf.call(this,

                            // If it receives a jQuery object, the first element is used
                            elem.jquery ? elem[0] : elem
                        );
                    },

                    add: function(selector, context) {
                        return this.pushStack(
                            jQuery.uniqueSort(
                                jQuery.merge(this.get(), jQuery(selector, context))
                            )
                        );
                    },

                    addBack: function(selector) {
                        return this.add(selector == null ?
                            this.prevObject : this.prevObject.filter(selector)
                        );
                    }
                });

                function sibling(cur, dir) {
                    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
                    return cur;
                }

                jQuery.each({
                    parent: function(elem) {
                        var parent = elem.parentNode;
                        return parent && parent.nodeType !== 11 ? parent : null;
                    },
                    parents: function(elem) {
                        return dir(elem, "parentNode");
                    },
                    parentsUntil: function(elem, i, until) {
                        return dir(elem, "parentNode", until);
                    },
                    next: function(elem) {
                        return sibling(elem, "nextSibling");
                    },
                    prev: function(elem) {
                        return sibling(elem, "previousSibling");
                    },
                    nextAll: function(elem) {
                        return dir(elem, "nextSibling");
                    },
                    prevAll: function(elem) {
                        return dir(elem, "previousSibling");
                    },
                    nextUntil: function(elem, i, until) {
                        return dir(elem, "nextSibling", until);
                    },
                    prevUntil: function(elem, i, until) {
                        return dir(elem, "previousSibling", until);
                    },
                    siblings: function(elem) {
                        return siblings((elem.parentNode || {}).firstChild, elem);
                    },
                    children: function(elem) {
                        return siblings(elem.firstChild);
                    },
                    contents: function(elem) {
                        return elem.contentDocument || jQuery.merge([], elem.childNodes);
                    }
                }, function(name, fn) {
                    jQuery.fn[name] = function(until, selector) {
                        var matched = jQuery.map(this, fn, until);

                        if (name.slice(-5) !== "Until") {
                            selector = until;
                        }

                        if (selector && typeof selector === "string") {
                            matched = jQuery.filter(selector, matched);
                        }

                        if (this.length > 1) {

                            // Remove duplicates
                            if (!guaranteedUnique[name]) {
                                jQuery.uniqueSort(matched);
                            }

                            // Reverse order for parents* and prev-derivatives
                            if (rparentsprev.test(name)) {
                                matched.reverse();
                            }
                        }

                        return this.pushStack(matched);
                    };
                });
                var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);

                // Convert String-formatted options into Object-formatted ones
                function createOptions(options) {
                    var object = {};
                    jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
                        object[flag] = true;
                    });
                    return object;
                }

                jQuery.Callbacks = function(options) {

                    // Convert options from String-formatted to Object-formatted if needed
                    // (we check in cache first)
                    options = typeof options === "string" ?
                        createOptions(options) :
                        jQuery.extend({}, options);

                    var // Flag to know if list is currently firing
                        firing,

                        // Last fire value for non-forgettable lists
                        memory,

                        // Flag to know if list was already fired
                        fired,

                        // Flag to prevent firing
                        locked,

                        // Actual callback list
                        list = [],

                        // Queue of execution data for repeatable lists
                        queue = [],

                        // Index of currently firing callback (modified by add/remove as needed)
                        firingIndex = -1,

                        // Fire callbacks
                        fire = function() {

                            // Enforce single-firing
                            locked = options.once;

                            // Execute callbacks for all pending executions,
                            // respecting firingIndex overrides and runtime changes
                            fired = firing = true;
                            for (; queue.length; firingIndex = -1) {
                                memory = queue.shift();
                                while (++firingIndex < list.length) {

                                    // Run callback and check for early termination
                                    if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                                        options.stopOnFalse) {

                                        // Jump to end and forget the data so .add doesn't re-fire
                                        firingIndex = list.length;
                                        memory = false;
                                    }
                                }
                            }

                            // Forget the data if we're done with it
                            if (!options.memory) {
                                memory = false;
                            }

                            firing = false;

                            // Clean up if we're done firing for good
                            if (locked) {

                                // Keep an empty list if we have data for future add calls
                                if (memory) {
                                    list = [];

                                    // Otherwise, this object is spent
                                } else {
                                    list = "";
                                }
                            }
                        },

                        // Actual Callbacks object
                        self = {

                            // Add a callback or a collection of callbacks to the list
                            add: function() {
                                if (list) {

                                    // If we have memory from a past run, we should fire after adding
                                    if (memory && !firing) {
                                        firingIndex = list.length - 1;
                                        queue.push(memory);
                                    }

                                    (function add(args) {
                                        jQuery.each(args, function(_, arg) {
                                            if (jQuery.isFunction(arg)) {
                                                if (!options.unique || !self.has(arg)) {
                                                    list.push(arg);
                                                }
                                            } else if (arg && arg.length && jQuery.type(arg) !== "string") {

                                                // Inspect recursively
                                                add(arg);
                                            }
                                        });
                                    })(arguments);

                                    if (memory && !firing) {
                                        fire();
                                    }
                                }
                                return this;
                            },

                            // Remove a callback from the list
                            remove: function() {
                                jQuery.each(arguments, function(_, arg) {
                                    var index;
                                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                        list.splice(index, 1);

                                        // Handle firing indexes
                                        if (index <= firingIndex) {
                                            firingIndex--;
                                        }
                                    }
                                });
                                return this;
                            },

                            // Check if a given callback is in the list.
                            // If no argument is given, return whether or not list has callbacks attached.
                            has: function(fn) {
                                return fn ?
                                    jQuery.inArray(fn, list) > -1 :
                                    list.length > 0;
                            },

                            // Remove all callbacks from the list
                            empty: function() {
                                if (list) {
                                    list = [];
                                }
                                return this;
                            },

                            // Disable .fire and .add
                            // Abort any current/pending executions
                            // Clear all callbacks and values
                            disable: function() {
                                locked = queue = [];
                                list = memory = "";
                                return this;
                            },
                            disabled: function() {
                                return !list;
                            },

                            // Disable .fire
                            // Also disable .add unless we have memory (since it would have no effect)
                            // Abort any pending executions
                            lock: function() {
                                locked = queue = [];
                                if (!memory && !firing) {
                                    list = memory = "";
                                }
                                return this;
                            },
                            locked: function() {
                                return !!locked;
                            },

                            // Call all callbacks with the given context and arguments
                            fireWith: function(context, args) {
                                if (!locked) {
                                    args = args || [];
                                    args = [context, args.slice ? args.slice() : args];
                                    queue.push(args);
                                    if (!firing) {
                                        fire();
                                    }
                                }
                                return this;
                            },

                            // Call all the callbacks with the given arguments
                            fire: function() {
                                self.fireWith(this, arguments);
                                return this;
                            },

                            // To know if the callbacks have already been called at least once
                            fired: function() {
                                return !!fired;
                            }
                        };

                    return self;
                };

                function Identity(v) {
                    return v;
                }

                function Thrower(ex) {
                    throw ex;
                }

                function adoptValue(value, resolve, reject) {
                    var method;

                    try {

                        // Check for promise aspect first to privilege synchronous behavior
                        if (value && jQuery.isFunction((method = value.promise))) {
                            method.call(value).done(resolve).fail(reject);

                            // Other thenables
                        } else if (value && jQuery.isFunction((method = value.then))) {
                            method.call(value, resolve, reject);

                            // Other non-thenables
                        } else {

                            // Support: Android 4.0 only
                            // Strict mode functions invoked without .call/.apply get global-object context
                            resolve.call(undefined, value);
                        }

                        // For Promises/A+, convert exceptions into rejections
                        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
                        // Deferred#then to conditionally suppress rejection.
                    } catch (value) {

                        // Support: Android 4.0 only
                        // Strict mode functions invoked without .call/.apply get global-object context
                        reject.call(undefined, value);
                    }
                }

                jQuery.extend({

                    Deferred: function(func) {
                        var tuples = [

                                // action, add listener, callbacks,
                                // ... .then handlers, argument index, [final state]
                                ["notify", "progress", jQuery.Callbacks("memory"),
                                    jQuery.Callbacks("memory"), 2
                                ],
                                ["resolve", "done", jQuery.Callbacks("once memory"),
                                    jQuery.Callbacks("once memory"), 0, "resolved"
                                ],
                                ["reject", "fail", jQuery.Callbacks("once memory"),
                                    jQuery.Callbacks("once memory"), 1, "rejected"
                                ]
                            ],
                            state = "pending",
                            promise = {
                                state: function() {
                                    return state;
                                },
                                always: function() {
                                    deferred.done(arguments).fail(arguments);
                                    return this;
                                },
                                "catch": function(fn) {
                                    return promise.then(null, fn);
                                },

                                // Keep pipe for back-compat
                                pipe: function() {
                                    var fns = arguments;

                                    return jQuery.Deferred(function(newDefer) {
                                        jQuery.each(tuples, function(i, tuple) {

                                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                            var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];

                                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                            deferred[tuple[1]](function() {
                                                var returned = fn && fn.apply(this, arguments);
                                                if (returned && jQuery.isFunction(returned.promise)) {
                                                    returned.promise()
                                                        .progress(newDefer.notify)
                                                        .done(newDefer.resolve)
                                                        .fail(newDefer.reject);
                                                } else {
                                                    newDefer[tuple[0] + "With"](
                                                        this,
                                                        fn ? [returned] : arguments
                                                    );
                                                }
                                            });
                                        });
                                        fns = null;
                                    }).promise();
                                },
                                then: function(onFulfilled, onRejected, onProgress) {
                                    var maxDepth = 0;

                                    function resolve(depth, deferred, handler, special) {
                                        return function() {
                                            var that = this,
                                                args = arguments,
                                                mightThrow = function() {
                                                    var returned, then;

                                                    // Support: Promises/A+ section 2.3.3.3.3
                                                    // https://promisesaplus.com/#point-59
                                                    // Ignore double-resolution attempts
                                                    if (depth < maxDepth) {
                                                        return;
                                                    }

                                                    returned = handler.apply(that, args);

                                                    // Support: Promises/A+ section 2.3.1
                                                    // https://promisesaplus.com/#point-48
                                                    if (returned === deferred.promise()) {
                                                        throw new TypeError("Thenable self-resolution");
                                                    }

                                                    // Support: Promises/A+ sections 2.3.3.1, 3.5
                                                    // https://promisesaplus.com/#point-54
                                                    // https://promisesaplus.com/#point-75
                                                    // Retrieve `then` only once
                                                    then = returned &&

                                                        // Support: Promises/A+ section 2.3.4
                                                        // https://promisesaplus.com/#point-64
                                                        // Only check objects and functions for thenability
                                                        (typeof returned === "object" ||
                                                            typeof returned === "function") &&
                                                        returned.then;

                                                    // Handle a returned thenable
                                                    if (jQuery.isFunction(then)) {

                                                        // Special processors (notify) just wait for resolution
                                                        if (special) {
                                                            then.call(
                                                                returned,
                                                                resolve(maxDepth, deferred, Identity, special),
                                                                resolve(maxDepth, deferred, Thrower, special)
                                                            );

                                                            // Normal processors (resolve) also hook into progress
                                                        } else {

                                                            // ...and disregard older resolution values
                                                            maxDepth++;

                                                            then.call(
                                                                returned,
                                                                resolve(maxDepth, deferred, Identity, special),
                                                                resolve(maxDepth, deferred, Thrower, special),
                                                                resolve(maxDepth, deferred, Identity,
                                                                    deferred.notifyWith)
                                                            );
                                                        }

                                                        // Handle all other returned values
                                                    } else {

                                                        // Only substitute handlers pass on context
                                                        // and multiple values (non-spec behavior)
                                                        if (handler !== Identity) {
                                                            that = undefined;
                                                            args = [returned];
                                                        }

                                                        // Process the value(s)
                                                        // Default process is resolve
                                                        (special || deferred.resolveWith)(that, args);
                                                    }
                                                },

                                                // Only normal processors (resolve) catch and reject exceptions
                                                process = special ?
                                                mightThrow :
                                                function() {
                                                    try {
                                                        mightThrow();
                                                    } catch (e) {

                                                        if (jQuery.Deferred.exceptionHook) {
                                                            jQuery.Deferred.exceptionHook(e,
                                                                process.stackTrace);
                                                        }

                                                        // Support: Promises/A+ section 2.3.3.3.4.1
                                                        // https://promisesaplus.com/#point-61
                                                        // Ignore post-resolution exceptions
                                                        if (depth + 1 >= maxDepth) {

                                                            // Only substitute handlers pass on context
                                                            // and multiple values (non-spec behavior)
                                                            if (handler !== Thrower) {
                                                                that = undefined;
                                                                args = [e];
                                                            }

                                                            deferred.rejectWith(that, args);
                                                        }
                                                    }
                                                };

                                            // Support: Promises/A+ section 2.3.3.3.1
                                            // https://promisesaplus.com/#point-57
                                            // Re-resolve promises immediately to dodge false rejection from
                                            // subsequent errors
                                            if (depth) {
                                                process();
                                            } else {

                                                // Call an optional hook to record the stack, in case of exception
                                                // since it's otherwise lost when execution goes async
                                                if (jQuery.Deferred.getStackHook) {
                                                    process.stackTrace = jQuery.Deferred.getStackHook();
                                                }
                                                window.setTimeout(process);
                                            }
                                        };
                                    }

                                    return jQuery.Deferred(function(newDefer) {

                                        // progress_handlers.add( ... )
                                        tuples[0][3].add(
                                            resolve(
                                                0,
                                                newDefer,
                                                jQuery.isFunction(onProgress) ?
                                                onProgress :
                                                Identity,
                                                newDefer.notifyWith
                                            )
                                        );

                                        // fulfilled_handlers.add( ... )
                                        tuples[1][3].add(
                                            resolve(
                                                0,
                                                newDefer,
                                                jQuery.isFunction(onFulfilled) ?
                                                onFulfilled :
                                                Identity
                                            )
                                        );

                                        // rejected_handlers.add( ... )
                                        tuples[2][3].add(
                                            resolve(
                                                0,
                                                newDefer,
                                                jQuery.isFunction(onRejected) ?
                                                onRejected :
                                                Thrower
                                            )
                                        );
                                    }).promise();
                                },

                                // Get a promise for this deferred
                                // If obj is provided, the promise aspect is added to the object
                                promise: function(obj) {
                                    return obj != null ? jQuery.extend(obj, promise) : promise;
                                }
                            },
                            deferred = {};

                        // Add list-specific methods
                        jQuery.each(tuples, function(i, tuple) {
                            var list = tuple[2],
                                stateString = tuple[5];

                            // promise.progress = list.add
                            // promise.done = list.add
                            // promise.fail = list.add
                            promise[tuple[1]] = list.add;

                            // Handle state
                            if (stateString) {
                                list.add(
                                    function() {

                                        // state = "resolved" (i.e., fulfilled)
                                        // state = "rejected"
                                        state = stateString;
                                    },

                                    // rejected_callbacks.disable
                                    // fulfilled_callbacks.disable
                                    tuples[3 - i][2].disable,

                                    // progress_callbacks.lock
                                    tuples[0][2].lock
                                );
                            }

                            // progress_handlers.fire
                            // fulfilled_handlers.fire
                            // rejected_handlers.fire
                            list.add(tuple[3].fire);

                            // deferred.notify = function() { deferred.notifyWith(...) }
                            // deferred.resolve = function() { deferred.resolveWith(...) }
                            // deferred.reject = function() { deferred.rejectWith(...) }
                            deferred[tuple[0]] = function() {
                                deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                                return this;
                            };

                            // deferred.notifyWith = list.fireWith
                            // deferred.resolveWith = list.fireWith
                            // deferred.rejectWith = list.fireWith
                            deferred[tuple[0] + "With"] = list.fireWith;
                        });

                        // Make the deferred a promise
                        promise.promise(deferred);

                        // Call given func if any
                        if (func) {
                            func.call(deferred, deferred);
                        }

                        // All done!
                        return deferred;
                    },

                    // Deferred helper
                    when: function(singleValue) {
                        var

                        // count of uncompleted subordinates
                            remaining = arguments.length,

                            // count of unprocessed arguments
                            i = remaining,

                            // subordinate fulfillment data
                            resolveContexts = Array(i),
                            resolveValues = slice.call(arguments),

                            // the master Deferred
                            master = jQuery.Deferred(),

                            // subordinate callback factory
                            updateFunc = function(i) {
                                return function(value) {
                                    resolveContexts[i] = this;
                                    resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                    if (!(--remaining)) {
                                        master.resolveWith(resolveContexts, resolveValues);
                                    }
                                };
                            };

                        // Single- and empty arguments are adopted like Promise.resolve
                        if (remaining <= 1) {
                            adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject);

                            // Use .then() to unwrap secondary thenables (cf. gh-3000)
                            if (master.state() === "pending" ||
                                jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {

                                return master.then();
                            }
                        }

                        // Multiple arguments are aggregated like Promise.all array elements
                        while (i--) {
                            adoptValue(resolveValues[i], updateFunc(i), master.reject);
                        }

                        return master.promise();
                    }
                });

                // These usually indicate a programmer mistake during development,
                // warn about them ASAP rather than swallowing them by default.
                var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

                jQuery.Deferred.exceptionHook = function(error, stack) {

                    // Support: IE 8 - 9 only
                    // Console exists when dev tools are open, which can happen at any time
                    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
                        window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
                    }
                };

                jQuery.readyException = function(error) {
                    window.setTimeout(function() {
                        throw error;
                    });
                };

                // The deferred used on DOM ready
                var readyList = jQuery.Deferred();

                jQuery.fn.ready = function(fn) {

                    readyList
                        .then(fn)

                    // Wrap jQuery.readyException in a function so that the lookup
                    // happens at the time of error handling instead of callback
                    // registration.
                    .catch(function(error) {
                        jQuery.readyException(error);
                    });

                    return this;
                };

                jQuery.extend({

                    // Is the DOM ready to be used? Set to true once it occurs.
                    isReady: false,

                    // A counter to track how many items to wait for before
                    // the ready event fires. See #6781
                    readyWait: 1,

                    // Hold (or release) the ready event
                    holdReady: function(hold) {
                        if (hold) {
                            jQuery.readyWait++;
                        } else {
                            jQuery.ready(true);
                        }
                    },

                    // Handle when the DOM is ready
                    ready: function(wait) {

                        // Abort if there are pending holds or we're already ready
                        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                            return;
                        }

                        // Remember that the DOM is ready
                        jQuery.isReady = true;

                        // If a normal DOM Ready event fired, decrement, and wait if need be
                        if (wait !== true && --jQuery.readyWait > 0) {
                            return;
                        }

                        // If there are functions bound, to execute
                        readyList.resolveWith(document, [jQuery]);
                    }
                });

                jQuery.ready.then = readyList.then;

                // The ready event handler and self cleanup method
                function completed() {
                    document.removeEventListener("DOMContentLoaded", completed);
                    window.removeEventListener("load", completed);
                    jQuery.ready();
                }

                // Catch cases where $(document).ready() is called
                // after the browser event has already occurred.
                // Support: IE <=9 - 10 only
                // Older IE sometimes signals "interactive" too soon
                if (document.readyState === "complete" ||
                    (document.readyState !== "loading" && !document.documentElement.doScroll)) {

                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    window.setTimeout(jQuery.ready);

                } else {

                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", completed);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", completed);
                }

                // Multifunctional method to get and set values of a collection
                // The value/s can optionally be executed if it's a function
                var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                    var i = 0,
                        len = elems.length,
                        bulk = key == null;

                    // Sets many values
                    if (jQuery.type(key) === "object") {
                        chainable = true;
                        for (i in key) {
                            access(elems, fn, i, key[i], true, emptyGet, raw);
                        }

                        // Sets one value
                    } else if (value !== undefined) {
                        chainable = true;

                        if (!jQuery.isFunction(value)) {
                            raw = true;
                        }

                        if (bulk) {

                            // Bulk operations run against the entire set
                            if (raw) {
                                fn.call(elems, value);
                                fn = null;

                                // ...except when executing function values
                            } else {
                                bulk = fn;
                                fn = function(elem, key, value) {
                                    return bulk.call(jQuery(elem), value);
                                };
                            }
                        }

                        if (fn) {
                            for (; i < len; i++) {
                                fn(
                                    elems[i], key, raw ?
                                    value :
                                    value.call(elems[i], i, fn(elems[i], key))
                                );
                            }
                        }
                    }

                    if (chainable) {
                        return elems;
                    }

                    // Gets
                    if (bulk) {
                        return fn.call(elems);
                    }

                    return len ? fn(elems[0], key) : emptyGet;
                };
                var acceptData = function(owner) {

                    // Accepts only:
                    //  - Node
                    //    - Node.ELEMENT_NODE
                    //    - Node.DOCUMENT_NODE
                    //  - Object
                    //    - Any
                    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
                };

                function Data() {
                    this.expando = jQuery.expando + Data.uid++;
                }

                Data.uid = 1;

                Data.prototype = {

                    cache: function(owner) {

                        // Check if the owner object already has a cache
                        var value = owner[this.expando];

                        // If not, create one
                        if (!value) {
                            value = {};

                            // We can accept data for non-element nodes in modern browsers,
                            // but we should not, see #8335.
                            // Always return an empty object.
                            if (acceptData(owner)) {

                                // If it is a node unlikely to be stringify-ed or looped over
                                // use plain assignment
                                if (owner.nodeType) {
                                    owner[this.expando] = value;

                                    // Otherwise secure it in a non-enumerable property
                                    // configurable must be true to allow the property to be
                                    // deleted when data is removed
                                } else {
                                    Object.defineProperty(owner, this.expando, {
                                        value: value,
                                        configurable: true
                                    });
                                }
                            }
                        }

                        return value;
                    },
                    set: function(owner, data, value) {
                        var prop,
                            cache = this.cache(owner);

                        // Handle: [ owner, key, value ] args
                        // Always use camelCase key (gh-2257)
                        if (typeof data === "string") {
                            cache[jQuery.camelCase(data)] = value;

                            // Handle: [ owner, { properties } ] args
                        } else {

                            // Copy the properties one-by-one to the cache object
                            for (prop in data) {
                                cache[jQuery.camelCase(prop)] = data[prop];
                            }
                        }
                        return cache;
                    },
                    get: function(owner, key) {
                        return key === undefined ?
                            this.cache(owner) :

                            // Always use camelCase key (gh-2257)
                            owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
                    },
                    access: function(owner, key, value) {

                        // In cases where either:
                        //
                        //   1. No key was specified
                        //   2. A string key was specified, but no value provided
                        //
                        // Take the "read" path and allow the get method to determine
                        // which value to return, respectively either:
                        //
                        //   1. The entire cache object
                        //   2. The data stored at the key
                        //
                        if (key === undefined ||
                            ((key && typeof key === "string") && value === undefined)) {

                            return this.get(owner, key);
                        }

                        // When the key is not a string, or both a key and value
                        // are specified, set or extend (existing objects) with either:
                        //
                        //   1. An object of properties
                        //   2. A key and value
                        //
                        this.set(owner, key, value);

                        // Since the "set" path can have two possible entry points
                        // return the expected data based on which path was taken[*]
                        return value !== undefined ? value : key;
                    },
                    remove: function(owner, key) {
                        var i,
                            cache = owner[this.expando];

                        if (cache === undefined) {
                            return;
                        }

                        if (key !== undefined) {

                            // Support array or space separated string of keys
                            if (jQuery.isArray(key)) {

                                // If key is an array of keys...
                                // We always set camelCase keys, so remove that.
                                key = key.map(jQuery.camelCase);
                            } else {
                                key = jQuery.camelCase(key);

                                // If a key with the spaces exists, use it.
                                // Otherwise, create an array by matching non-whitespace
                                key = key in cache ? [key] :
                                    (key.match(rnothtmlwhite) || []);
                            }

                            i = key.length;

                            while (i--) {
                                delete cache[key[i]];
                            }
                        }

                        // Remove the expando if there's no more data
                        if (key === undefined || jQuery.isEmptyObject(cache)) {

                            // Support: Chrome <=35 - 45
                            // Webkit & Blink performance suffers when deleting properties
                            // from DOM nodes, so set to undefined instead
                            // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                            if (owner.nodeType) {
                                owner[this.expando] = undefined;
                            } else {
                                delete owner[this.expando];
                            }
                        }
                    },
                    hasData: function(owner) {
                        var cache = owner[this.expando];
                        return cache !== undefined && !jQuery.isEmptyObject(cache);
                    }
                };
                var dataPriv = new Data();

                var dataUser = new Data();

                //	Implementation Summary
                //
                //	1. Enforce API surface and semantic compatibility with 1.9.x branch
                //	2. Improve the module's maintainability by reducing the storage
                //		paths to a single mechanism.
                //	3. Use the same single mechanism to support "private" and "user" data.
                //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
                //	5. Avoid exposing implementation details on user objects (eg. expando properties)
                //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

                var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                    rmultiDash = /[A-Z]/g;

                function getData(data) {
                    if (data === "true") {
                        return true;
                    }

                    if (data === "false") {
                        return false;
                    }

                    if (data === "null") {
                        return null;
                    }

                    // Only convert to a number if it doesn't change the string
                    if (data === +data + "") {
                        return +data;
                    }

                    if (rbrace.test(data)) {
                        return JSON.parse(data);
                    }

                    return data;
                }

                function dataAttr(elem, key, data) {
                    var name;

                    // If nothing was found internally, try to fetch any
                    // data from the HTML5 data-* attribute
                    if (data === undefined && elem.nodeType === 1) {
                        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
                        data = elem.getAttribute(name);

                        if (typeof data === "string") {
                            try {
                                data = getData(data);
                            } catch (e) {}

                            // Make sure we set the data so it isn't changed later
                            dataUser.set(elem, key, data);
                        } else {
                            data = undefined;
                        }
                    }
                    return data;
                }

                jQuery.extend({
                    hasData: function(elem) {
                        return dataUser.hasData(elem) || dataPriv.hasData(elem);
                    },

                    data: function(elem, name, data) {
                        return dataUser.access(elem, name, data);
                    },

                    removeData: function(elem, name) {
                        dataUser.remove(elem, name);
                    },

                    // TODO: Now that all calls to _data and _removeData have been replaced
                    // with direct calls to dataPriv methods, these can be deprecated.
                    _data: function(elem, name, data) {
                        return dataPriv.access(elem, name, data);
                    },

                    _removeData: function(elem, name) {
                        dataPriv.remove(elem, name);
                    }
                });

                jQuery.fn.extend({
                    data: function(key, value) {
                        var i, name, data,
                            elem = this[0],
                            attrs = elem && elem.attributes;

                        // Gets all values
                        if (key === undefined) {
                            if (this.length) {
                                data = dataUser.get(elem);

                                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                                    i = attrs.length;
                                    while (i--) {

                                        // Support: IE 11 only
                                        // The attrs elements can be null (#14894)
                                        if (attrs[i]) {
                                            name = attrs[i].name;
                                            if (name.indexOf("data-") === 0) {
                                                name = jQuery.camelCase(name.slice(5));
                                                dataAttr(elem, name, data[name]);
                                            }
                                        }
                                    }
                                    dataPriv.set(elem, "hasDataAttrs", true);
                                }
                            }

                            return data;
                        }

                        // Sets multiple values
                        if (typeof key === "object") {
                            return this.each(function() {
                                dataUser.set(this, key);
                            });
                        }

                        return access(this, function(value) {
                            var data;

                            // The calling jQuery object (element matches) is not empty
                            // (and therefore has an element appears at this[ 0 ]) and the
                            // `value` parameter was not undefined. An empty jQuery object
                            // will result in `undefined` for elem = this[ 0 ] which will
                            // throw an exception if an attempt to read a data cache is made.
                            if (elem && value === undefined) {

                                // Attempt to get data from the cache
                                // The key will always be camelCased in Data
                                data = dataUser.get(elem, key);
                                if (data !== undefined) {
                                    return data;
                                }

                                // Attempt to "discover" the data in
                                // HTML5 custom data-* attrs
                                data = dataAttr(elem, key);
                                if (data !== undefined) {
                                    return data;
                                }

                                // We tried really hard, but the data doesn't exist.
                                return;
                            }

                            // Set the data...
                            this.each(function() {

                                // We always store the camelCased key
                                dataUser.set(this, key, value);
                            });
                        }, null, value, arguments.length > 1, null, true);
                    },

                    removeData: function(key) {
                        return this.each(function() {
                            dataUser.remove(this, key);
                        });
                    }
                });

                jQuery.extend({
                    queue: function(elem, type, data) {
                        var queue;

                        if (elem) {
                            type = (type || "fx") + "queue";
                            queue = dataPriv.get(elem, type);

                            // Speed up dequeue by getting out quickly if this is just a lookup
                            if (data) {
                                if (!queue || jQuery.isArray(data)) {
                                    queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                                } else {
                                    queue.push(data);
                                }
                            }
                            return queue || [];
                        }
                    },

                    dequeue: function(elem, type) {
                        type = type || "fx";

                        var queue = jQuery.queue(elem, type),
                            startLength = queue.length,
                            fn = queue.shift(),
                            hooks = jQuery._queueHooks(elem, type),
                            next = function() {
                                jQuery.dequeue(elem, type);
                            };

                        // If the fx queue is dequeued, always remove the progress sentinel
                        if (fn === "inprogress") {
                            fn = queue.shift();
                            startLength--;
                        }

                        if (fn) {

                            // Add a progress sentinel to prevent the fx queue from being
                            // automatically dequeued
                            if (type === "fx") {
                                queue.unshift("inprogress");
                            }

                            // Clear up the last queue stop function
                            delete hooks.stop;
                            fn.call(elem, next, hooks);
                        }

                        if (!startLength && hooks) {
                            hooks.empty.fire();
                        }
                    },

                    // Not public - generate a queueHooks object, or return the current one
                    _queueHooks: function(elem, type) {
                        var key = type + "queueHooks";
                        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                            empty: jQuery.Callbacks("once memory").add(function() {
                                dataPriv.remove(elem, [type + "queue", key]);
                            })
                        });
                    }
                });

                jQuery.fn.extend({
                    queue: function(type, data) {
                        var setter = 2;

                        if (typeof type !== "string") {
                            data = type;
                            type = "fx";
                            setter--;
                        }

                        if (arguments.length < setter) {
                            return jQuery.queue(this[0], type);
                        }

                        return data === undefined ?
                            this :
                            this.each(function() {
                                var queue = jQuery.queue(this, type, data);

                                // Ensure a hooks for this queue
                                jQuery._queueHooks(this, type);

                                if (type === "fx" && queue[0] !== "inprogress") {
                                    jQuery.dequeue(this, type);
                                }
                            });
                    },
                    dequeue: function(type) {
                        return this.each(function() {
                            jQuery.dequeue(this, type);
                        });
                    },
                    clearQueue: function(type) {
                        return this.queue(type || "fx", []);
                    },

                    // Get a promise resolved when queues of a certain type
                    // are emptied (fx is the type by default)
                    promise: function(type, obj) {
                        var tmp,
                            count = 1,
                            defer = jQuery.Deferred(),
                            elements = this,
                            i = this.length,
                            resolve = function() {
                                if (!(--count)) {
                                    defer.resolveWith(elements, [elements]);
                                }
                            };

                        if (typeof type !== "string") {
                            obj = type;
                            type = undefined;
                        }
                        type = type || "fx";

                        while (i--) {
                            tmp = dataPriv.get(elements[i], type + "queueHooks");
                            if (tmp && tmp.empty) {
                                count++;
                                tmp.empty.add(resolve);
                            }
                        }
                        resolve();
                        return defer.promise(obj);
                    }
                });
                var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

                var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

                var cssExpand = ["Top", "Right", "Bottom", "Left"];

                var isHiddenWithinTree = function(elem, el) {

                    // isHiddenWithinTree might be called from jQuery#filter function;
                    // in that case, element will be second argument
                    elem = el || elem;

                    // Inline style trumps all
                    return elem.style.display === "none" ||
                        elem.style.display === "" &&

                        // Otherwise, check computed style
                        // Support: Firefox <=43 - 45
                        // Disconnected elements can have computed display: none, so first confirm that elem is
                        // in the document.
                        jQuery.contains(elem.ownerDocument, elem) &&

                        jQuery.css(elem, "display") === "none";
                };

                var swap = function(elem, options, callback, args) {
                    var ret, name,
                        old = {};

                    // Remember the old values, and insert the new ones
                    for (name in options) {
                        old[name] = elem.style[name];
                        elem.style[name] = options[name];
                    }

                    ret = callback.apply(elem, args || []);

                    // Revert the old values
                    for (name in options) {
                        elem.style[name] = old[name];
                    }

                    return ret;
                };

                function adjustCSS(elem, prop, valueParts, tween) {
                    var adjusted,
                        scale = 1,
                        maxIterations = 20,
                        currentValue = tween ?
                        function() {
                            return tween.cur();
                        } :
                        function() {
                            return jQuery.css(elem, prop, "");
                        },
                        initial = currentValue(),
                        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

                        // Starting value computation is required for potential unit mismatches
                        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
                        rcssNum.exec(jQuery.css(elem, prop));

                    if (initialInUnit && initialInUnit[3] !== unit) {

                        // Trust units reported by jQuery.css
                        unit = unit || initialInUnit[3];

                        // Make sure we update the tween properties later on
                        valueParts = valueParts || [];

                        // Iteratively approximate from a nonzero starting point
                        initialInUnit = +initial || 1;

                        do {

                            // If previous iteration zeroed out, double until we get *something*.
                            // Use string for doubling so we don't accidentally see scale as unchanged below
                            scale = scale || ".5";

                            // Adjust and apply
                            initialInUnit = initialInUnit / scale;
                            jQuery.style(elem, prop, initialInUnit + unit);

                            // Update scale, tolerating zero or NaN from tween.cur()
                            // Break the loop if scale is unchanged or perfect, or if we've just had enough.
                        } while (
                            scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations
                        );
                    }

                    if (valueParts) {
                        initialInUnit = +initialInUnit || +initial || 0;

                        // Apply relative offset (+=/-=) if specified
                        adjusted = valueParts[1] ?
                            initialInUnit + (valueParts[1] + 1) * valueParts[2] :
                            +valueParts[2];
                        if (tween) {
                            tween.unit = unit;
                            tween.start = initialInUnit;
                            tween.end = adjusted;
                        }
                    }
                    return adjusted;
                }

                var defaultDisplayMap = {};

                function getDefaultDisplay(elem) {
                    var temp,
                        doc = elem.ownerDocument,
                        nodeName = elem.nodeName,
                        display = defaultDisplayMap[nodeName];

                    if (display) {
                        return display;
                    }

                    temp = doc.body.appendChild(doc.createElement(nodeName));
                    display = jQuery.css(temp, "display");

                    temp.parentNode.removeChild(temp);

                    if (display === "none") {
                        display = "block";
                    }
                    defaultDisplayMap[nodeName] = display;

                    return display;
                }

                function showHide(elements, show) {
                    var display, elem,
                        values = [],
                        index = 0,
                        length = elements.length;

                    // Determine new display value for elements that need to change
                    for (; index < length; index++) {
                        elem = elements[index];
                        if (!elem.style) {
                            continue;
                        }

                        display = elem.style.display;
                        if (show) {

                            // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                            // check is required in this first loop unless we have a nonempty display value (either
                            // inline or about-to-be-restored)
                            if (display === "none") {
                                values[index] = dataPriv.get(elem, "display") || null;
                                if (!values[index]) {
                                    elem.style.display = "";
                                }
                            }
                            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                                values[index] = getDefaultDisplay(elem);
                            }
                        } else {
                            if (display !== "none") {
                                values[index] = "none";

                                // Remember what we're overwriting
                                dataPriv.set(elem, "display", display);
                            }
                        }
                    }

                    // Set the display of the elements in a second loop to avoid constant reflow
                    for (index = 0; index < length; index++) {
                        if (values[index] != null) {
                            elements[index].style.display = values[index];
                        }
                    }

                    return elements;
                }

                jQuery.fn.extend({
                    show: function() {
                        return showHide(this, true);
                    },
                    hide: function() {
                        return showHide(this);
                    },
                    toggle: function(state) {
                        if (typeof state === "boolean") {
                            return state ? this.show() : this.hide();
                        }

                        return this.each(function() {
                            if (isHiddenWithinTree(this)) {
                                jQuery(this).show();
                            } else {
                                jQuery(this).hide();
                            }
                        });
                    }
                });
                var rcheckableType = (/^(?:checkbox|radio)$/i);

                var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);

                var rscriptType = (/^$|\/(?:java|ecma)script/i);

                // We have to close these tags to support XHTML (#13200)
                var wrapMap = {

                    // Support: IE <=9 only
                    option: [1, "<select multiple='multiple'>", "</select>"],

                    // XHTML parsers do not magically insert elements in the
                    // same way that tag soup parsers do. So we cannot shorten
                    // this by omitting <tbody> or other required elements.
                    thead: [1, "<table>", "</table>"],
                    col: [2, "<table><colgroup>", "</colgroup></table>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

                    _default: [0, "", ""]
                };

                // Support: IE <=9 only
                wrapMap.optgroup = wrapMap.option;

                wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
                wrapMap.th = wrapMap.td;

                function getAll(context, tag) {

                    // Support: IE <=9 - 11 only
                    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
                    var ret;

                    if (typeof context.getElementsByTagName !== "undefined") {
                        ret = context.getElementsByTagName(tag || "*");

                    } else if (typeof context.querySelectorAll !== "undefined") {
                        ret = context.querySelectorAll(tag || "*");

                    } else {
                        ret = [];
                    }

                    if (tag === undefined || tag && jQuery.nodeName(context, tag)) {
                        return jQuery.merge([context], ret);
                    }

                    return ret;
                }

                // Mark scripts as having already been evaluated
                function setGlobalEval(elems, refElements) {
                    var i = 0,
                        l = elems.length;

                    for (; i < l; i++) {
                        dataPriv.set(
                            elems[i],
                            "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval")
                        );
                    }
                }

                var rhtml = /<|&#?\w+;/;

                function buildFragment(elems, context, scripts, selection, ignored) {
                    var elem, tmp, tag, wrap, contains, j,
                        fragment = context.createDocumentFragment(),
                        nodes = [],
                        i = 0,
                        l = elems.length;

                    for (; i < l; i++) {
                        elem = elems[i];

                        if (elem || elem === 0) {

                            // Add nodes directly
                            if (jQuery.type(elem) === "object") {

                                // Support: Android <=4.0 only, PhantomJS 1 only
                                // push.apply(_, arraylike) throws on ancient WebKit
                                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                                // Convert non-html into a text node
                            } else if (!rhtml.test(elem)) {
                                nodes.push(context.createTextNode(elem));

                                // Convert html into DOM nodes
                            } else {
                                tmp = tmp || fragment.appendChild(context.createElement("div"));

                                // Deserialize a standard representation
                                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                                wrap = wrapMap[tag] || wrapMap._default;
                                tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                                // Descend through wrappers to the right content
                                j = wrap[0];
                                while (j--) {
                                    tmp = tmp.lastChild;
                                }

                                // Support: Android <=4.0 only, PhantomJS 1 only
                                // push.apply(_, arraylike) throws on ancient WebKit
                                jQuery.merge(nodes, tmp.childNodes);

                                // Remember the top-level container
                                tmp = fragment.firstChild;

                                // Ensure the created nodes are orphaned (#12392)
                                tmp.textContent = "";
                            }
                        }
                    }

                    // Remove wrapper from fragment
                    fragment.textContent = "";

                    i = 0;
                    while ((elem = nodes[i++])) {

                        // Skip elements already in the context collection (trac-4087)
                        if (selection && jQuery.inArray(elem, selection) > -1) {
                            if (ignored) {
                                ignored.push(elem);
                            }
                            continue;
                        }

                        contains = jQuery.contains(elem.ownerDocument, elem);

                        // Append to fragment
                        tmp = getAll(fragment.appendChild(elem), "script");

                        // Preserve script evaluation history
                        if (contains) {
                            setGlobalEval(tmp);
                        }

                        // Capture executables
                        if (scripts) {
                            j = 0;
                            while ((elem = tmp[j++])) {
                                if (rscriptType.test(elem.type || "")) {
                                    scripts.push(elem);
                                }
                            }
                        }
                    }

                    return fragment;
                }

                (function() {
                    var fragment = document.createDocumentFragment(),
                        div = fragment.appendChild(document.createElement("div")),
                        input = document.createElement("input");

                    // Support: Android 4.0 - 4.3 only
                    // Check state lost if the name is set (#11217)
                    // Support: Windows Web Apps (WWA)
                    // `name` and `type` must use .setAttribute for WWA (#14901)
                    input.setAttribute("type", "radio");
                    input.setAttribute("checked", "checked");
                    input.setAttribute("name", "t");

                    div.appendChild(input);

                    // Support: Android <=4.1 only
                    // Older WebKit doesn't clone checked state correctly in fragments
                    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

                    // Support: IE <=11 only
                    // Make sure textarea (and checkbox) defaultValue is properly cloned
                    div.innerHTML = "<textarea>x</textarea>";
                    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
                })();
                var documentElement = document.documentElement;

                var
                    rkeyEvent = /^key/,
                    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

                function returnTrue() {
                    return true;
                }

                function returnFalse() {
                    return false;
                }

                // Support: IE <=9 only
                // See #13393 for more info
                function safeActiveElement() {
                    try {
                        return document.activeElement;
                    } catch (err) {}
                }

                function on(elem, types, selector, data, fn, one) {
                    var origFn, type;

                    // Types can be a map of types/handlers
                    if (typeof types === "object") {

                        // ( types-Object, selector, data )
                        if (typeof selector !== "string") {

                            // ( types-Object, data )
                            data = data || selector;
                            selector = undefined;
                        }
                        for (type in types) {
                            on(elem, type, selector, data, types[type], one);
                        }
                        return elem;
                    }

                    if (data == null && fn == null) {

                        // ( types, fn )
                        fn = selector;
                        data = selector = undefined;
                    } else if (fn == null) {
                        if (typeof selector === "string") {

                            // ( types, selector, fn )
                            fn = data;
                            data = undefined;
                        } else {

                            // ( types, data, fn )
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    } else if (!fn) {
                        return elem;
                    }

                    if (one === 1) {
                        origFn = fn;
                        fn = function(event) {

                            // Can use an empty set, since event contains the info
                            jQuery().off(event);
                            return origFn.apply(this, arguments);
                        };

                        // Use same guid so caller can remove using origFn
                        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                    }
                    return elem.each(function() {
                        jQuery.event.add(this, types, fn, data, selector);
                    });
                }

                jQuery.event = {

                    global: {},

                    add: function(elem, types, handler, data, selector) {

                        var handleObjIn, eventHandle, tmp,
                            events, t, handleObj,
                            special, handlers, type, namespaces, origType,
                            elemData = dataPriv.get(elem);

                        // Don't attach events to noData or text/comment nodes (but allow plain objects)
                        if (!elemData) {
                            return;
                        }

                        // Caller can pass in an object of custom data in lieu of the handler
                        if (handler.handler) {
                            handleObjIn = handler;
                            handler = handleObjIn.handler;
                            selector = handleObjIn.selector;
                        }

                        // Ensure that invalid selectors throw exceptions at attach time
                        // Evaluate against documentElement in case elem is a non-element node (e.g., document)
                        if (selector) {
                            jQuery.find.matchesSelector(documentElement, selector);
                        }

                        // Make sure that the handler has a unique ID, used to find/remove it later
                        if (!handler.guid) {
                            handler.guid = jQuery.guid++;
                        }

                        // Init the element's event structure and main handler, if this is the first
                        if (!(events = elemData.events)) {
                            events = elemData.events = {};
                        }
                        if (!(eventHandle = elemData.handle)) {
                            eventHandle = elemData.handle = function(e) {

                                // Discard the second event of a jQuery.event.trigger() and
                                // when an event is called after a page has unloaded
                                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                                    jQuery.event.dispatch.apply(elem, arguments) : undefined;
                            };
                        }

                        // Handle multiple events separated by a space
                        types = (types || "").match(rnothtmlwhite) || [""];
                        t = types.length;
                        while (t--) {
                            tmp = rtypenamespace.exec(types[t]) || [];
                            type = origType = tmp[1];
                            namespaces = (tmp[2] || "").split(".").sort();

                            // There *must* be a type, no attaching namespace-only handlers
                            if (!type) {
                                continue;
                            }

                            // If event changes its type, use the special event handlers for the changed type
                            special = jQuery.event.special[type] || {};

                            // If selector defined, determine special event api type, otherwise given type
                            type = (selector ? special.delegateType : special.bindType) || type;

                            // Update special based on newly reset type
                            special = jQuery.event.special[type] || {};

                            // handleObj is passed to all event handlers
                            handleObj = jQuery.extend({
                                type: type,
                                origType: origType,
                                data: data,
                                handler: handler,
                                guid: handler.guid,
                                selector: selector,
                                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                                namespace: namespaces.join(".")
                            }, handleObjIn);

                            // Init the event handler queue if we're the first
                            if (!(handlers = events[type])) {
                                handlers = events[type] = [];
                                handlers.delegateCount = 0;

                                // Only use addEventListener if the special events handler returns false
                                if (!special.setup ||
                                    special.setup.call(elem, data, namespaces, eventHandle) === false) {

                                    if (elem.addEventListener) {
                                        elem.addEventListener(type, eventHandle);
                                    }
                                }
                            }

                            if (special.add) {
                                special.add.call(elem, handleObj);

                                if (!handleObj.handler.guid) {
                                    handleObj.handler.guid = handler.guid;
                                }
                            }

                            // Add to the element's handler list, delegates in front
                            if (selector) {
                                handlers.splice(handlers.delegateCount++, 0, handleObj);
                            } else {
                                handlers.push(handleObj);
                            }

                            // Keep track of which events have ever been used, for event optimization
                            jQuery.event.global[type] = true;
                        }

                    },

                    // Detach an event or set of events from an element
                    remove: function(elem, types, handler, selector, mappedTypes) {

                        var j, origCount, tmp,
                            events, t, handleObj,
                            special, handlers, type, namespaces, origType,
                            elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

                        if (!elemData || !(events = elemData.events)) {
                            return;
                        }

                        // Once for each type.namespace in types; type may be omitted
                        types = (types || "").match(rnothtmlwhite) || [""];
                        t = types.length;
                        while (t--) {
                            tmp = rtypenamespace.exec(types[t]) || [];
                            type = origType = tmp[1];
                            namespaces = (tmp[2] || "").split(".").sort();

                            // Unbind all events (on this namespace, if provided) for the element
                            if (!type) {
                                for (type in events) {
                                    jQuery.event.remove(elem, type + types[t], handler, selector, true);
                                }
                                continue;
                            }

                            special = jQuery.event.special[type] || {};
                            type = (selector ? special.delegateType : special.bindType) || type;
                            handlers = events[type] || [];
                            tmp = tmp[2] &&
                                new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                            // Remove matching events
                            origCount = j = handlers.length;
                            while (j--) {
                                handleObj = handlers[j];

                                if ((mappedTypes || origType === handleObj.origType) &&
                                    (!handler || handler.guid === handleObj.guid) &&
                                    (!tmp || tmp.test(handleObj.namespace)) &&
                                    (!selector || selector === handleObj.selector ||
                                        selector === "**" && handleObj.selector)) {
                                    handlers.splice(j, 1);

                                    if (handleObj.selector) {
                                        handlers.delegateCount--;
                                    }
                                    if (special.remove) {
                                        special.remove.call(elem, handleObj);
                                    }
                                }
                            }

                            // Remove generic event handler if we removed something and no more handlers exist
                            // (avoids potential for endless recursion during removal of special event handlers)
                            if (origCount && !handlers.length) {
                                if (!special.teardown ||
                                    special.teardown.call(elem, namespaces, elemData.handle) === false) {

                                    jQuery.removeEvent(elem, type, elemData.handle);
                                }

                                delete events[type];
                            }
                        }

                        // Remove data and the expando if it's no longer used
                        if (jQuery.isEmptyObject(events)) {
                            dataPriv.remove(elem, "handle events");
                        }
                    },

                    dispatch: function(nativeEvent) {

                        // Make a writable jQuery.Event from the native event object
                        var event = jQuery.event.fix(nativeEvent);

                        var i, j, ret, matched, handleObj, handlerQueue,
                            args = new Array(arguments.length),
                            handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                            special = jQuery.event.special[event.type] || {};

                        // Use the fix-ed jQuery.Event rather than the (read-only) native event
                        args[0] = event;

                        for (i = 1; i < arguments.length; i++) {
                            args[i] = arguments[i];
                        }

                        event.delegateTarget = this;

                        // Call the preDispatch hook for the mapped type, and let it bail if desired
                        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                            return;
                        }

                        // Determine handlers
                        handlerQueue = jQuery.event.handlers.call(this, event, handlers);

                        // Run delegates first; they may want to stop propagation beneath us
                        i = 0;
                        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                            event.currentTarget = matched.elem;

                            j = 0;
                            while ((handleObj = matched.handlers[j++]) &&
                                !event.isImmediatePropagationStopped()) {

                                // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                                // a subset or equal to those in the bound event (both can have no namespace).
                                if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

                                    event.handleObj = handleObj;
                                    event.data = handleObj.data;

                                    ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
                                        handleObj.handler).apply(matched.elem, args);

                                    if (ret !== undefined) {
                                        if ((event.result = ret) === false) {
                                            event.preventDefault();
                                            event.stopPropagation();
                                        }
                                    }
                                }
                            }
                        }

                        // Call the postDispatch hook for the mapped type
                        if (special.postDispatch) {
                            special.postDispatch.call(this, event);
                        }

                        return event.result;
                    },

                    handlers: function(event, handlers) {
                        var i, handleObj, sel, matchedHandlers, matchedSelectors,
                            handlerQueue = [],
                            delegateCount = handlers.delegateCount,
                            cur = event.target;

                        // Find delegate handlers
                        if (delegateCount &&

                            // Support: IE <=9
                            // Black-hole SVG <use> instance trees (trac-13180)
                            cur.nodeType &&

                            // Support: Firefox <=42
                            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                            // Support: IE 11 only
                            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                            !(event.type === "click" && event.button >= 1)) {

                            for (; cur !== this; cur = cur.parentNode || this) {

                                // Don't check non-elements (#13208)
                                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                                    matchedHandlers = [];
                                    matchedSelectors = {};
                                    for (i = 0; i < delegateCount; i++) {
                                        handleObj = handlers[i];

                                        // Don't conflict with Object.prototype properties (#13203)
                                        sel = handleObj.selector + " ";

                                        if (matchedSelectors[sel] === undefined) {
                                            matchedSelectors[sel] = handleObj.needsContext ?
                                                jQuery(sel, this).index(cur) > -1 :
                                                jQuery.find(sel, this, null, [cur]).length;
                                        }
                                        if (matchedSelectors[sel]) {
                                            matchedHandlers.push(handleObj);
                                        }
                                    }
                                    if (matchedHandlers.length) {
                                        handlerQueue.push({
                                            elem: cur,
                                            handlers: matchedHandlers
                                        });
                                    }
                                }
                            }
                        }

                        // Add the remaining (directly-bound) handlers
                        cur = this;
                        if (delegateCount < handlers.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: handlers.slice(delegateCount)
                            });
                        }

                        return handlerQueue;
                    },

                    addProp: function(name, hook) {
                        Object.defineProperty(jQuery.Event.prototype, name, {
                            enumerable: true,
                            configurable: true,

                            get: jQuery.isFunction(hook) ?
                                function() {
                                    if (this.originalEvent) {
                                        return hook(this.originalEvent);
                                    }
                                } : function() {
                                    if (this.originalEvent) {
                                        return this.originalEvent[name];
                                    }
                                },

                            set: function(value) {
                                Object.defineProperty(this, name, {
                                    enumerable: true,
                                    configurable: true,
                                    writable: true,
                                    value: value
                                });
                            }
                        });
                    },

                    fix: function(originalEvent) {
                        return originalEvent[jQuery.expando] ?
                            originalEvent :
                            new jQuery.Event(originalEvent);
                    },

                    special: {
                        load: {

                            // Prevent triggered image.load events from bubbling to window.load
                            noBubble: true
                        },
                        focus: {

                            // Fire native event if possible so blur/focus sequence is correct
                            trigger: function() {
                                if (this !== safeActiveElement() && this.focus) {
                                    this.focus();
                                    return false;
                                }
                            },
                            delegateType: "focusin"
                        },
                        blur: {
                            trigger: function() {
                                if (this === safeActiveElement() && this.blur) {
                                    this.blur();
                                    return false;
                                }
                            },
                            delegateType: "focusout"
                        },
                        click: {

                            // For checkbox, fire native event so checked state will be right
                            trigger: function() {
                                if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                                    this.click();
                                    return false;
                                }
                            },

                            // For cross-browser consistency, don't fire native .click() on links
                            _default: function(event) {
                                return jQuery.nodeName(event.target, "a");
                            }
                        },

                        beforeunload: {
                            postDispatch: function(event) {

                                // Support: Firefox 20+
                                // Firefox doesn't alert if the returnValue field is not set.
                                if (event.result !== undefined && event.originalEvent) {
                                    event.originalEvent.returnValue = event.result;
                                }
                            }
                        }
                    }
                };

                jQuery.removeEvent = function(elem, type, handle) {

                    // This "if" is needed for plain objects
                    if (elem.removeEventListener) {
                        elem.removeEventListener(type, handle);
                    }
                };

                jQuery.Event = function(src, props) {

                    // Allow instantiation without the 'new' keyword
                    if (!(this instanceof jQuery.Event)) {
                        return new jQuery.Event(src, props);
                    }

                    // Event object
                    if (src && src.type) {
                        this.originalEvent = src;
                        this.type = src.type;

                        // Events bubbling up the document may have been marked as prevented
                        // by a handler lower down the tree; reflect the correct value.
                        this.isDefaultPrevented = src.defaultPrevented ||
                            src.defaultPrevented === undefined &&

                            // Support: Android <=2.3 only
                            src.returnValue === false ?
                            returnTrue :
                            returnFalse;

                        // Create target properties
                        // Support: Safari <=6 - 7 only
                        // Target should not be a text node (#504, #13143)
                        this.target = (src.target && src.target.nodeType === 3) ?
                            src.target.parentNode :
                            src.target;

                        this.currentTarget = src.currentTarget;
                        this.relatedTarget = src.relatedTarget;

                        // Event type
                    } else {
                        this.type = src;
                    }

                    // Put explicitly provided properties onto the event object
                    if (props) {
                        jQuery.extend(this, props);
                    }

                    // Create a timestamp if incoming event doesn't have one
                    this.timeStamp = src && src.timeStamp || jQuery.now();

                    // Mark it as fixed
                    this[jQuery.expando] = true;
                };

                // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
                // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
                jQuery.Event.prototype = {
                    constructor: jQuery.Event,
                    isDefaultPrevented: returnFalse,
                    isPropagationStopped: returnFalse,
                    isImmediatePropagationStopped: returnFalse,
                    isSimulated: false,

                    preventDefault: function() {
                        var e = this.originalEvent;

                        this.isDefaultPrevented = returnTrue;

                        if (e && !this.isSimulated) {
                            e.preventDefault();
                        }
                    },
                    stopPropagation: function() {
                        var e = this.originalEvent;

                        this.isPropagationStopped = returnTrue;

                        if (e && !this.isSimulated) {
                            e.stopPropagation();
                        }
                    },
                    stopImmediatePropagation: function() {
                        var e = this.originalEvent;

                        this.isImmediatePropagationStopped = returnTrue;

                        if (e && !this.isSimulated) {
                            e.stopImmediatePropagation();
                        }

                        this.stopPropagation();
                    }
                };

                // Includes all common event props including KeyEvent and MouseEvent specific props
                jQuery.each({
                    altKey: true,
                    bubbles: true,
                    cancelable: true,
                    changedTouches: true,
                    ctrlKey: true,
                    detail: true,
                    eventPhase: true,
                    metaKey: true,
                    pageX: true,
                    pageY: true,
                    shiftKey: true,
                    view: true,
                    "char": true,
                    charCode: true,
                    key: true,
                    keyCode: true,
                    button: true,
                    buttons: true,
                    clientX: true,
                    clientY: true,
                    offsetX: true,
                    offsetY: true,
                    pointerId: true,
                    pointerType: true,
                    screenX: true,
                    screenY: true,
                    targetTouches: true,
                    toElement: true,
                    touches: true,

                    which: function(event) {
                        var button = event.button;

                        // Add which for key events
                        if (event.which == null && rkeyEvent.test(event.type)) {
                            return event.charCode != null ? event.charCode : event.keyCode;
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                            if (button & 1) {
                                return 1;
                            }

                            if (button & 2) {
                                return 3;
                            }

                            if (button & 4) {
                                return 2;
                            }

                            return 0;
                        }

                        return event.which;
                    }
                }, jQuery.event.addProp);

                // Create mouseenter/leave events using mouseover/out and event-time checks
                // so that event delegation works in jQuery.
                // Do the same for pointerenter/pointerleave and pointerover/pointerout
                //
                // Support: Safari 7 only
                // Safari sends mouseenter too often; see:
                // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
                // for the description of the bug (it existed in older Chrome versions as well).
                jQuery.each({
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, function(orig, fix) {
                    jQuery.event.special[orig] = {
                        delegateType: fix,
                        bindType: fix,

                        handle: function(event) {
                            var ret,
                                target = this,
                                related = event.relatedTarget,
                                handleObj = event.handleObj;

                            // For mouseenter/leave call the handler if related is outside the target.
                            // NB: No relatedTarget if the mouse left/entered the browser window
                            if (!related || (related !== target && !jQuery.contains(target, related))) {
                                event.type = handleObj.origType;
                                ret = handleObj.handler.apply(this, arguments);
                                event.type = fix;
                            }
                            return ret;
                        }
                    };
                });

                jQuery.fn.extend({

                    on: function(types, selector, data, fn) {
                        return on(this, types, selector, data, fn);
                    },
                    one: function(types, selector, data, fn) {
                        return on(this, types, selector, data, fn, 1);
                    },
                    off: function(types, selector, fn) {
                        var handleObj, type;
                        if (types && types.preventDefault && types.handleObj) {

                            // ( event )  dispatched jQuery.Event
                            handleObj = types.handleObj;
                            jQuery(types.delegateTarget).off(
                                handleObj.namespace ?
                                handleObj.origType + "." + handleObj.namespace :
                                handleObj.origType,
                                handleObj.selector,
                                handleObj.handler
                            );
                            return this;
                        }
                        if (typeof types === "object") {

                            // ( types-object [, selector] )
                            for (type in types) {
                                this.off(type, selector, types[type]);
                            }
                            return this;
                        }
                        if (selector === false || typeof selector === "function") {

                            // ( types [, fn] )
                            fn = selector;
                            selector = undefined;
                        }
                        if (fn === false) {
                            fn = returnFalse;
                        }
                        return this.each(function() {
                            jQuery.event.remove(this, types, fn, selector);
                        });
                    }
                });

                var



                // See https://github.com/eslint/eslint/issues/3229
                    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,



                    // Support: IE <=10 - 11, Edge 12 - 13
                    // In IE/Edge using regex groups here causes severe slowdowns.
                    // See https://connect.microsoft.com/IE/feedback/details/1736512/
                    rnoInnerhtml = /<script|<style|<link/i,

                    // checked="checked" or checked
                    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                    rscriptTypeMasked = /^true\/(.*)/,
                    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

                function manipulationTarget(elem, content) {
                    if (jQuery.nodeName(elem, "table") &&
                        jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

                        return elem.getElementsByTagName("tbody")[0] || elem;
                    }

                    return elem;
                }

                // Replace/restore the type attribute of script elements for safe DOM manipulation
                function disableScript(elem) {
                    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                    return elem;
                }

                function restoreScript(elem) {
                    var match = rscriptTypeMasked.exec(elem.type);

                    if (match) {
                        elem.type = match[1];
                    } else {
                        elem.removeAttribute("type");
                    }

                    return elem;
                }

                function cloneCopyEvent(src, dest) {
                    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

                    if (dest.nodeType !== 1) {
                        return;
                    }

                    // 1. Copy private data: events, handlers, etc.
                    if (dataPriv.hasData(src)) {
                        pdataOld = dataPriv.access(src);
                        pdataCur = dataPriv.set(dest, pdataOld);
                        events = pdataOld.events;

                        if (events) {
                            delete pdataCur.handle;
                            pdataCur.events = {};

                            for (type in events) {
                                for (i = 0, l = events[type].length; i < l; i++) {
                                    jQuery.event.add(dest, type, events[type][i]);
                                }
                            }
                        }
                    }

                    // 2. Copy user data
                    if (dataUser.hasData(src)) {
                        udataOld = dataUser.access(src);
                        udataCur = jQuery.extend({}, udataOld);

                        dataUser.set(dest, udataCur);
                    }
                }

                // Fix IE bugs, see support tests
                function fixInput(src, dest) {
                    var nodeName = dest.nodeName.toLowerCase();

                    // Fails to persist the checked state of a cloned checkbox or radio button.
                    if (nodeName === "input" && rcheckableType.test(src.type)) {
                        dest.checked = src.checked;

                        // Fails to return the selected option to the default selected state when cloning options
                    } else if (nodeName === "input" || nodeName === "textarea") {
                        dest.defaultValue = src.defaultValue;
                    }
                }

                function domManip(collection, args, callback, ignored) {

                    // Flatten any nested arrays
                    args = concat.apply([], args);

                    var fragment, first, scripts, hasScripts, node, doc,
                        i = 0,
                        l = collection.length,
                        iNoClone = l - 1,
                        value = args[0],
                        isFunction = jQuery.isFunction(value);

                    // We can't cloneNode fragments that contain checked, in WebKit
                    if (isFunction ||
                        (l > 1 && typeof value === "string" &&
                            !support.checkClone && rchecked.test(value))) {
                        return collection.each(function(index) {
                            var self = collection.eq(index);
                            if (isFunction) {
                                args[0] = value.call(this, index, self.html());
                            }
                            domManip(self, args, callback, ignored);
                        });
                    }

                    if (l) {
                        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
                        first = fragment.firstChild;

                        if (fragment.childNodes.length === 1) {
                            fragment = first;
                        }

                        // Require either new content or an interest in ignored elements to invoke the callback
                        if (first || ignored) {
                            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                            hasScripts = scripts.length;

                            // Use the original fragment for the last item
                            // instead of the first because it can end up
                            // being emptied incorrectly in certain situations (#8070).
                            for (; i < l; i++) {
                                node = fragment;

                                if (i !== iNoClone) {
                                    node = jQuery.clone(node, true, true);

                                    // Keep references to cloned scripts for later restoration
                                    if (hasScripts) {

                                        // Support: Android <=4.0 only, PhantomJS 1 only
                                        // push.apply(_, arraylike) throws on ancient WebKit
                                        jQuery.merge(scripts, getAll(node, "script"));
                                    }
                                }

                                callback.call(collection[i], node, i);
                            }

                            if (hasScripts) {
                                doc = scripts[scripts.length - 1].ownerDocument;

                                // Reenable scripts
                                jQuery.map(scripts, restoreScript);

                                // Evaluate executable scripts on first document insertion
                                for (i = 0; i < hasScripts; i++) {
                                    node = scripts[i];
                                    if (rscriptType.test(node.type || "") &&
                                        !dataPriv.access(node, "globalEval") &&
                                        jQuery.contains(doc, node)) {

                                        if (node.src) {

                                            // Optional AJAX dependency, but won't run scripts if not present
                                            if (jQuery._evalUrl) {
                                                jQuery._evalUrl(node.src);
                                            }
                                        } else {
                                            DOMEval(node.textContent.replace(rcleanScript, ""), doc);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return collection;
                }

                function remove(elem, selector, keepData) {
                    var node,
                        nodes = selector ? jQuery.filter(selector, elem) : elem,
                        i = 0;

                    for (;
                        (node = nodes[i]) != null; i++) {
                        if (!keepData && node.nodeType === 1) {
                            jQuery.cleanData(getAll(node));
                        }

                        if (node.parentNode) {
                            if (keepData && jQuery.contains(node.ownerDocument, node)) {
                                setGlobalEval(getAll(node, "script"));
                            }
                            node.parentNode.removeChild(node);
                        }
                    }

                    return elem;
                }

                jQuery.extend({
                    htmlPrefilter: function(html) {
                        return html.replace(rxhtmlTag, "<$1></$2>");
                    },

                    clone: function(elem, dataAndEvents, deepDataAndEvents) {
                        var i, l, srcElements, destElements,
                            clone = elem.cloneNode(true),
                            inPage = jQuery.contains(elem.ownerDocument, elem);

                        // Fix IE cloning issues
                        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
                            !jQuery.isXMLDoc(elem)) {

                            // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                            destElements = getAll(clone);
                            srcElements = getAll(elem);

                            for (i = 0, l = srcElements.length; i < l; i++) {
                                fixInput(srcElements[i], destElements[i]);
                            }
                        }

                        // Copy the events from the original to the clone
                        if (dataAndEvents) {
                            if (deepDataAndEvents) {
                                srcElements = srcElements || getAll(elem);
                                destElements = destElements || getAll(clone);

                                for (i = 0, l = srcElements.length; i < l; i++) {
                                    cloneCopyEvent(srcElements[i], destElements[i]);
                                }
                            } else {
                                cloneCopyEvent(elem, clone);
                            }
                        }

                        // Preserve script evaluation history
                        destElements = getAll(clone, "script");
                        if (destElements.length > 0) {
                            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                        }

                        // Return the cloned set
                        return clone;
                    },

                    cleanData: function(elems) {
                        var data, elem, type,
                            special = jQuery.event.special,
                            i = 0;

                        for (;
                            (elem = elems[i]) !== undefined; i++) {
                            if (acceptData(elem)) {
                                if ((data = elem[dataPriv.expando])) {
                                    if (data.events) {
                                        for (type in data.events) {
                                            if (special[type]) {
                                                jQuery.event.remove(elem, type);

                                                // This is a shortcut to avoid jQuery.event.remove's overhead
                                            } else {
                                                jQuery.removeEvent(elem, type, data.handle);
                                            }
                                        }
                                    }

                                    // Support: Chrome <=35 - 45+
                                    // Assign undefined instead of using delete, see Data#remove
                                    elem[dataPriv.expando] = undefined;
                                }
                                if (elem[dataUser.expando]) {

                                    // Support: Chrome <=35 - 45+
                                    // Assign undefined instead of using delete, see Data#remove
                                    elem[dataUser.expando] = undefined;
                                }
                            }
                        }
                    }
                });

                jQuery.fn.extend({
                    detach: function(selector) {
                        return remove(this, selector, true);
                    },

                    remove: function(selector) {
                        return remove(this, selector);
                    },

                    text: function(value) {
                        return access(this, function(value) {
                            return value === undefined ?
                                jQuery.text(this) :
                                this.empty().each(function() {
                                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                        this.textContent = value;
                                    }
                                });
                        }, null, value, arguments.length);
                    },

                    append: function() {
                        return domManip(this, arguments, function(elem) {
                            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                var target = manipulationTarget(this, elem);
                                target.appendChild(elem);
                            }
                        });
                    },

                    prepend: function() {
                        return domManip(this, arguments, function(elem) {
                            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                var target = manipulationTarget(this, elem);
                                target.insertBefore(elem, target.firstChild);
                            }
                        });
                    },

                    before: function() {
                        return domManip(this, arguments, function(elem) {
                            if (this.parentNode) {
                                this.parentNode.insertBefore(elem, this);
                            }
                        });
                    },

                    after: function() {
                        return domManip(this, arguments, function(elem) {
                            if (this.parentNode) {
                                this.parentNode.insertBefore(elem, this.nextSibling);
                            }
                        });
                    },

                    empty: function() {
                        var elem,
                            i = 0;

                        for (;
                            (elem = this[i]) != null; i++) {
                            if (elem.nodeType === 1) {

                                // Prevent memory leaks
                                jQuery.cleanData(getAll(elem, false));

                                // Remove any remaining nodes
                                elem.textContent = "";
                            }
                        }

                        return this;
                    },

                    clone: function(dataAndEvents, deepDataAndEvents) {
                        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                        return this.map(function() {
                            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                        });
                    },

                    html: function(value) {
                        return access(this, function(value) {
                            var elem = this[0] || {},
                                i = 0,
                                l = this.length;

                            if (value === undefined && elem.nodeType === 1) {
                                return elem.innerHTML;
                            }

                            // See if we can take a shortcut and just use innerHTML
                            if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                                !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                                value = jQuery.htmlPrefilter(value);

                                try {
                                    for (; i < l; i++) {
                                        elem = this[i] || {};

                                        // Remove element nodes and prevent memory leaks
                                        if (elem.nodeType === 1) {
                                            jQuery.cleanData(getAll(elem, false));
                                            elem.innerHTML = value;
                                        }
                                    }

                                    elem = 0;

                                    // If using innerHTML throws an exception, use the fallback method
                                } catch (e) {}
                            }

                            if (elem) {
                                this.empty().append(value);
                            }
                        }, null, value, arguments.length);
                    },

                    replaceWith: function() {
                        var ignored = [];

                        // Make the changes, replacing each non-ignored context element with the new content
                        return domManip(this, arguments, function(elem) {
                            var parent = this.parentNode;

                            if (jQuery.inArray(this, ignored) < 0) {
                                jQuery.cleanData(getAll(this));
                                if (parent) {
                                    parent.replaceChild(elem, this);
                                }
                            }

                            // Force callback invocation
                        }, ignored);
                    }
                });

                jQuery.each({
                    appendTo: "append",
                    prependTo: "prepend",
                    insertBefore: "before",
                    insertAfter: "after",
                    replaceAll: "replaceWith"
                }, function(name, original) {
                    jQuery.fn[name] = function(selector) {
                        var elems,
                            ret = [],
                            insert = jQuery(selector),
                            last = insert.length - 1,
                            i = 0;

                        for (; i <= last; i++) {
                            elems = i === last ? this : this.clone(true);
                            jQuery(insert[i])[original](elems);

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // .get() because push.apply(_, arraylike) throws on ancient WebKit
                            push.apply(ret, elems.get());
                        }

                        return this.pushStack(ret);
                    };
                });
                var rmargin = (/^margin/);

                var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

                var getStyles = function(elem) {

                    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
                    // IE throws on elements created in popups
                    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                    var view = elem.ownerDocument.defaultView;

                    if (!view || !view.opener) {
                        view = window;
                    }

                    return view.getComputedStyle(elem);
                };

                (function() {

                    // Executing both pixelPosition & boxSizingReliable tests require only one layout
                    // so they're executed at the same time to save the second computation.
                    function computeStyleTests() {

                        // This is a singleton, we need to execute it only once
                        if (!div) {
                            return;
                        }

                        div.style.cssText =
                            "box-sizing:border-box;" +
                            "position:relative;display:block;" +
                            "margin:auto;border:1px;padding:1px;" +
                            "top:1%;width:50%";
                        div.innerHTML = "";
                        documentElement.appendChild(container);

                        var divStyle = window.getComputedStyle(div);
                        pixelPositionVal = divStyle.top !== "1%";

                        // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
                        reliableMarginLeftVal = divStyle.marginLeft === "2px";
                        boxSizingReliableVal = divStyle.width === "4px";

                        // Support: Android 4.0 - 4.3 only
                        // Some styles come back with percentage values, even though they shouldn't
                        div.style.marginRight = "50%";
                        pixelMarginRightVal = divStyle.marginRight === "4px";

                        documentElement.removeChild(container);

                        // Nullify the div so it wouldn't be stored in the memory and
                        // it will also be a sign that checks already performed
                        div = null;
                    }

                    var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
                        container = document.createElement("div"),
                        div = document.createElement("div");

                    // Finish early in limited (non-browser) environments
                    if (!div.style) {
                        return;
                    }

                    // Support: IE <=9 - 11 only
                    // Style of cloned element affects source element cloned (#8908)
                    div.style.backgroundClip = "content-box";
                    div.cloneNode(true).style.backgroundClip = "";
                    support.clearCloneStyle = div.style.backgroundClip === "content-box";

                    container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
                        "padding:0;margin-top:1px;position:absolute";
                    container.appendChild(div);

                    jQuery.extend(support, {
                        pixelPosition: function() {
                            computeStyleTests();
                            return pixelPositionVal;
                        },
                        boxSizingReliable: function() {
                            computeStyleTests();
                            return boxSizingReliableVal;
                        },
                        pixelMarginRight: function() {
                            computeStyleTests();
                            return pixelMarginRightVal;
                        },
                        reliableMarginLeft: function() {
                            computeStyleTests();
                            return reliableMarginLeftVal;
                        }
                    });
                })();

                function curCSS(elem, name, computed) {
                    var width, minWidth, maxWidth, ret,
                        style = elem.style;

                    computed = computed || getStyles(elem);

                    // Support: IE <=9 only
                    // getPropertyValue is only needed for .css('filter') (#12537)
                    if (computed) {
                        ret = computed.getPropertyValue(name) || computed[name];

                        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                            ret = jQuery.style(elem, name);
                        }

                        // A tribute to the "awesome hack by Dean Edwards"
                        // Android Browser returns percentage for some values,
                        // but width seems to be reliably pixels.
                        // This is against the CSSOM draft spec:
                        // https://drafts.csswg.org/cssom/#resolved-values
                        if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

                            // Remember the original values
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;

                            // Put in the new values to get a computed value out
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;

                            // Revert the changed values
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }

                    return ret !== undefined ?

                        // Support: IE <=9 - 11 only
                        // IE returns zIndex value as an integer.
                        ret + "" :
                        ret;
                }

                function addGetHookIf(conditionFn, hookFn) {

                    // Define the hook, we'll check on the first run if it's really needed.
                    return {
                        get: function() {
                            if (conditionFn()) {

                                // Hook not needed (or it's not possible to use it due
                                // to missing dependency), remove it.
                                delete this.get;
                                return;
                            }

                            // Hook needed; redefine it so that the support test is not executed again.
                            return (this.get = hookFn).apply(this, arguments);
                        }
                    };
                }

                var

                // Swappable if display is none or starts with table
                // except "table", "table-cell", or "table-caption"
                // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                    cssShow = {
                        position: "absolute",
                        visibility: "hidden",
                        display: "block"
                    },
                    cssNormalTransform = {
                        letterSpacing: "0",
                        fontWeight: "400"
                    },

                    cssPrefixes = ["Webkit", "Moz", "ms"],
                    emptyStyle = document.createElement("div").style;

                // Return a css property mapped to a potentially vendor prefixed property
                function vendorPropName(name) {

                    // Shortcut for names that are not vendor prefixed
                    if (name in emptyStyle) {
                        return name;
                    }

                    // Check for vendor prefixed names
                    var capName = name[0].toUpperCase() + name.slice(1),
                        i = cssPrefixes.length;

                    while (i--) {
                        name = cssPrefixes[i] + capName;
                        if (name in emptyStyle) {
                            return name;
                        }
                    }
                }

                function setPositiveNumber(elem, value, subtract) {

                    // Any relative (+/-) values have already been
                    // normalized at this point
                    var matches = rcssNum.exec(value);
                    return matches ?

                        // Guard against undefined "subtract", e.g., when used as in cssHooks
                        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
                        value;
                }

                function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                    var i,
                        val = 0;

                    // If we already have the right measurement, avoid augmentation
                    if (extra === (isBorderBox ? "border" : "content")) {
                        i = 4;

                        // Otherwise initialize for horizontal or vertical properties
                    } else {
                        i = name === "width" ? 1 : 0;
                    }

                    for (; i < 4; i += 2) {

                        // Both box models exclude margin, so add it if we want it
                        if (extra === "margin") {
                            val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                        }

                        if (isBorderBox) {

                            // border-box includes padding, so remove it if we want content
                            if (extra === "content") {
                                val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                            }

                            // At this point, extra isn't border nor margin, so remove border
                            if (extra !== "margin") {
                                val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                            }
                        } else {

                            // At this point, extra isn't content, so add padding
                            val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                            // At this point, extra isn't content nor padding, so add border
                            if (extra !== "padding") {
                                val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                            }
                        }
                    }

                    return val;
                }

                function getWidthOrHeight(elem, name, extra) {

                    // Start with offset property, which is equivalent to the border-box value
                    var val,
                        valueIsBorderBox = true,
                        styles = getStyles(elem),
                        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a disconnected node
                    // in IE throws an error.
                    if (elem.getClientRects().length) {
                        val = elem.getBoundingClientRect()[name];
                    }

                    // Some non-html elements return undefined for offsetWidth, so check for null/undefined
                    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                    if (val <= 0 || val == null) {

                        // Fall back to computed then uncomputed css if necessary
                        val = curCSS(elem, name, styles);
                        if (val < 0 || val == null) {
                            val = elem.style[name];
                        }

                        // Computed unit is not pixels. Stop here and return.
                        if (rnumnonpx.test(val)) {
                            return val;
                        }

                        // Check for style in case a browser which returns unreliable values
                        // for getComputedStyle silently falls back to the reliable elem.style
                        valueIsBorderBox = isBorderBox &&
                            (support.boxSizingReliable() || val === elem.style[name]);

                        // Normalize "", auto, and prepare for extra
                        val = parseFloat(val) || 0;
                    }

                    // Use the active box-sizing model to add/subtract irrelevant styles
                    return (val +
                        augmentWidthOrHeight(
                            elem,
                            name,
                            extra || (isBorderBox ? "border" : "content"),
                            valueIsBorderBox,
                            styles
                        )
                    ) + "px";
                }

                jQuery.extend({

                    // Add in style property hooks for overriding the default
                    // behavior of getting and setting a style property
                    cssHooks: {
                        opacity: {
                            get: function(elem, computed) {
                                if (computed) {

                                    // We should always get a number back from opacity
                                    var ret = curCSS(elem, "opacity");
                                    return ret === "" ? "1" : ret;
                                }
                            }
                        }
                    },

                    // Don't automatically add "px" to these possibly-unitless properties
                    cssNumber: {
                        "animationIterationCount": true,
                        "columnCount": true,
                        "fillOpacity": true,
                        "flexGrow": true,
                        "flexShrink": true,
                        "fontWeight": true,
                        "lineHeight": true,
                        "opacity": true,
                        "order": true,
                        "orphans": true,
                        "widows": true,
                        "zIndex": true,
                        "zoom": true
                    },

                    // Add in properties whose names you wish to fix before
                    // setting or getting the value
                    cssProps: {
                        "float": "cssFloat"
                    },

                    // Get and set the style property on a DOM Node
                    style: function(elem, name, value, extra) {

                        // Don't set styles on text and comment nodes
                        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                            return;
                        }

                        // Make sure that we're working with the right name
                        var ret, type, hooks,
                            origName = jQuery.camelCase(name),
                            style = elem.style;

                        name = jQuery.cssProps[origName] ||
                            (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

                        // Gets hook for the prefixed version, then unprefixed version
                        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                        // Check if we're setting a value
                        if (value !== undefined) {
                            type = typeof value;

                            // Convert "+=" or "-=" to relative numbers (#7345)
                            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                                value = adjustCSS(elem, name, ret);

                                // Fixes bug #9237
                                type = "number";
                            }

                            // Make sure that null and NaN values aren't set (#7116)
                            if (value == null || value !== value) {
                                return;
                            }

                            // If a number was passed in, add the unit (except for certain CSS properties)
                            if (type === "number") {
                                value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                            }

                            // background-* props affect original clone's values
                            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                                style[name] = "inherit";
                            }

                            // If a hook was provided, use that value, otherwise just set the specified value
                            if (!hooks || !("set" in hooks) ||
                                (value = hooks.set(elem, value, extra)) !== undefined) {

                                style[name] = value;
                            }

                        } else {

                            // If a hook was provided get the non-computed value from there
                            if (hooks && "get" in hooks &&
                                (ret = hooks.get(elem, false, extra)) !== undefined) {

                                return ret;
                            }

                            // Otherwise just get the value from the style object
                            return style[name];
                        }
                    },

                    css: function(elem, name, extra, styles) {
                        var val, num, hooks,
                            origName = jQuery.camelCase(name);

                        // Make sure that we're working with the right name
                        name = jQuery.cssProps[origName] ||
                            (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

                        // Try prefixed name followed by the unprefixed name
                        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                        // If a hook was provided get the computed value from there
                        if (hooks && "get" in hooks) {
                            val = hooks.get(elem, true, extra);
                        }

                        // Otherwise, if a way to get the computed value exists, use that
                        if (val === undefined) {
                            val = curCSS(elem, name, styles);
                        }

                        // Convert "normal" to computed value
                        if (val === "normal" && name in cssNormalTransform) {
                            val = cssNormalTransform[name];
                        }

                        // Make numeric if forced or a qualifier was provided and val looks numeric
                        if (extra === "" || extra) {
                            num = parseFloat(val);
                            return extra === true || isFinite(num) ? num || 0 : val;
                        }
                        return val;
                    }
                });

                jQuery.each(["height", "width"], function(i, name) {
                    jQuery.cssHooks[name] = {
                        get: function(elem, computed, extra) {
                            if (computed) {

                                // Certain elements can have dimension info if we invisibly show them
                                // but it must have a current display style that would benefit
                                return rdisplayswap.test(jQuery.css(elem, "display")) &&

                                    // Support: Safari 8+
                                    // Table columns in Safari have non-zero offsetWidth & zero
                                    // getBoundingClientRect().width unless display is changed.
                                    // Support: IE <=11 only
                                    // Running getBoundingClientRect on a disconnected node
                                    // in IE throws an error.
                                    (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
                                    swap(elem, cssShow, function() {
                                        return getWidthOrHeight(elem, name, extra);
                                    }) :
                                    getWidthOrHeight(elem, name, extra);
                            }
                        },

                        set: function(elem, value, extra) {
                            var matches,
                                styles = extra && getStyles(elem),
                                subtract = extra && augmentWidthOrHeight(
                                    elem,
                                    name,
                                    extra,
                                    jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                                    styles
                                );

                            // Convert to pixels if value adjustment is needed
                            if (subtract && (matches = rcssNum.exec(value)) &&
                                (matches[3] || "px") !== "px") {

                                elem.style[name] = value;
                                value = jQuery.css(elem, name);
                            }

                            return setPositiveNumber(elem, value, subtract);
                        }
                    };
                });

                jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
                    function(elem, computed) {
                        if (computed) {
                            return (parseFloat(curCSS(elem, "marginLeft")) ||
                                elem.getBoundingClientRect().left -
                                swap(elem, {
                                    marginLeft: 0
                                }, function() {
                                    return elem.getBoundingClientRect().left;
                                })
                            ) + "px";
                        }
                    }
                );

                // These hooks are used by animate to expand properties
                jQuery.each({
                    margin: "",
                    padding: "",
                    border: "Width"
                }, function(prefix, suffix) {
                    jQuery.cssHooks[prefix + suffix] = {
                        expand: function(value) {
                            var i = 0,
                                expanded = {},

                                // Assumes a single number if not a string
                                parts = typeof value === "string" ? value.split(" ") : [value];

                            for (; i < 4; i++) {
                                expanded[prefix + cssExpand[i] + suffix] =
                                    parts[i] || parts[i - 2] || parts[0];
                            }

                            return expanded;
                        }
                    };

                    if (!rmargin.test(prefix)) {
                        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                    }
                });

                jQuery.fn.extend({
                    css: function(name, value) {
                        return access(this, function(elem, name, value) {
                            var styles, len,
                                map = {},
                                i = 0;

                            if (jQuery.isArray(name)) {
                                styles = getStyles(elem);
                                len = name.length;

                                for (; i < len; i++) {
                                    map[name[i]] = jQuery.css(elem, name[i], false, styles);
                                }

                                return map;
                            }

                            return value !== undefined ?
                                jQuery.style(elem, name, value) :
                                jQuery.css(elem, name);
                        }, name, value, arguments.length > 1);
                    }
                });

                function Tween(elem, options, prop, end, easing) {
                    return new Tween.prototype.init(elem, options, prop, end, easing);
                }
                jQuery.Tween = Tween;

                Tween.prototype = {
                    constructor: Tween,
                    init: function(elem, options, prop, end, easing, unit) {
                        this.elem = elem;
                        this.prop = prop;
                        this.easing = easing || jQuery.easing._default;
                        this.options = options;
                        this.start = this.now = this.cur();
                        this.end = end;
                        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
                    },
                    cur: function() {
                        var hooks = Tween.propHooks[this.prop];

                        return hooks && hooks.get ?
                            hooks.get(this) :
                            Tween.propHooks._default.get(this);
                    },
                    run: function(percent) {
                        var eased,
                            hooks = Tween.propHooks[this.prop];

                        if (this.options.duration) {
                            this.pos = eased = jQuery.easing[this.easing](
                                percent, this.options.duration * percent, 0, 1, this.options.duration
                            );
                        } else {
                            this.pos = eased = percent;
                        }
                        this.now = (this.end - this.start) * eased + this.start;

                        if (this.options.step) {
                            this.options.step.call(this.elem, this.now, this);
                        }

                        if (hooks && hooks.set) {
                            hooks.set(this);
                        } else {
                            Tween.propHooks._default.set(this);
                        }
                        return this;
                    }
                };

                Tween.prototype.init.prototype = Tween.prototype;

                Tween.propHooks = {
                    _default: {
                        get: function(tween) {
                            var result;

                            // Use a property on the element directly when it is not a DOM element,
                            // or when there is no matching style property that exists.
                            if (tween.elem.nodeType !== 1 ||
                                tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                                return tween.elem[tween.prop];
                            }

                            // Passing an empty string as a 3rd parameter to .css will automatically
                            // attempt a parseFloat and fallback to a string if the parse fails.
                            // Simple values such as "10px" are parsed to Float;
                            // complex values such as "rotate(1rad)" are returned as-is.
                            result = jQuery.css(tween.elem, tween.prop, "");

                            // Empty strings, null, undefined and "auto" are converted to 0.
                            return !result || result === "auto" ? 0 : result;
                        },
                        set: function(tween) {

                            // Use step hook for back compat.
                            // Use cssHook if its there.
                            // Use .style if available and use plain properties where available.
                            if (jQuery.fx.step[tween.prop]) {
                                jQuery.fx.step[tween.prop](tween);
                            } else if (tween.elem.nodeType === 1 &&
                                (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
                                    jQuery.cssHooks[tween.prop])) {
                                jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                            } else {
                                tween.elem[tween.prop] = tween.now;
                            }
                        }
                    }
                };

                // Support: IE <=9 only
                // Panic based approach to setting things on disconnected nodes
                Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                    set: function(tween) {
                        if (tween.elem.nodeType && tween.elem.parentNode) {
                            tween.elem[tween.prop] = tween.now;
                        }
                    }
                };

                jQuery.easing = {
                    linear: function(p) {
                        return p;
                    },
                    swing: function(p) {
                        return 0.5 - Math.cos(p * Math.PI) / 2;
                    },
                    _default: "swing"
                };

                jQuery.fx = Tween.prototype.init;

                // Back compat <1.8 extension point
                jQuery.fx.step = {};

                var
                    fxNow, timerId,
                    rfxtypes = /^(?:toggle|show|hide)$/,
                    rrun = /queueHooks$/;

                function raf() {
                    if (timerId) {
                        window.requestAnimationFrame(raf);
                        jQuery.fx.tick();
                    }
                }

                // Animations created synchronously will run synchronously
                function createFxNow() {
                    window.setTimeout(function() {
                        fxNow = undefined;
                    });
                    return (fxNow = jQuery.now());
                }

                // Generate parameters to create a standard animation
                function genFx(type, includeWidth) {
                    var which,
                        i = 0,
                        attrs = {
                            height: type
                        };

                    // If we include width, step value is 1 to do all cssExpand values,
                    // otherwise step value is 2 to skip over Left and Right
                    includeWidth = includeWidth ? 1 : 0;
                    for (; i < 4; i += 2 - includeWidth) {
                        which = cssExpand[i];
                        attrs["margin" + which] = attrs["padding" + which] = type;
                    }

                    if (includeWidth) {
                        attrs.opacity = attrs.width = type;
                    }

                    return attrs;
                }

                function createTween(value, prop, animation) {
                    var tween,
                        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
                        index = 0,
                        length = collection.length;
                    for (; index < length; index++) {
                        if ((tween = collection[index].call(animation, prop, value))) {

                            // We're done with this property
                            return tween;
                        }
                    }
                }

                function defaultPrefilter(elem, props, opts) {
                    var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
                        isBox = "width" in props || "height" in props,
                        anim = this,
                        orig = {},
                        style = elem.style,
                        hidden = elem.nodeType && isHiddenWithinTree(elem),
                        dataShow = dataPriv.get(elem, "fxshow");

                    // Queue-skipping animations hijack the fx hooks
                    if (!opts.queue) {
                        hooks = jQuery._queueHooks(elem, "fx");
                        if (hooks.unqueued == null) {
                            hooks.unqueued = 0;
                            oldfire = hooks.empty.fire;
                            hooks.empty.fire = function() {
                                if (!hooks.unqueued) {
                                    oldfire();
                                }
                            };
                        }
                        hooks.unqueued++;

                        anim.always(function() {

                            // Ensure the complete handler is called before this completes
                            anim.always(function() {
                                hooks.unqueued--;
                                if (!jQuery.queue(elem, "fx").length) {
                                    hooks.empty.fire();
                                }
                            });
                        });
                    }

                    // Detect show/hide animations
                    for (prop in props) {
                        value = props[prop];
                        if (rfxtypes.test(value)) {
                            delete props[prop];
                            toggle = toggle || value === "toggle";
                            if (value === (hidden ? "hide" : "show")) {

                                // Pretend to be hidden if this is a "show" and
                                // there is still data from a stopped show/hide
                                if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                                    hidden = true;

                                    // Ignore all other no-op show/hide data
                                } else {
                                    continue;
                                }
                            }
                            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                        }
                    }

                    // Bail out if this is a no-op like .hide().hide()
                    propTween = !jQuery.isEmptyObject(props);
                    if (!propTween && jQuery.isEmptyObject(orig)) {
                        return;
                    }

                    // Restrict "overflow" and "display" styles during box animations
                    if (isBox && elem.nodeType === 1) {

                        // Support: IE <=9 - 11, Edge 12 - 13
                        // Record all 3 overflow attributes because IE does not infer the shorthand
                        // from identically-valued overflowX and overflowY
                        opts.overflow = [style.overflow, style.overflowX, style.overflowY];

                        // Identify a display type, preferring old show/hide data over the CSS cascade
                        restoreDisplay = dataShow && dataShow.display;
                        if (restoreDisplay == null) {
                            restoreDisplay = dataPriv.get(elem, "display");
                        }
                        display = jQuery.css(elem, "display");
                        if (display === "none") {
                            if (restoreDisplay) {
                                display = restoreDisplay;
                            } else {

                                // Get nonempty value(s) by temporarily forcing visibility
                                showHide([elem], true);
                                restoreDisplay = elem.style.display || restoreDisplay;
                                display = jQuery.css(elem, "display");
                                showHide([elem]);
                            }
                        }

                        // Animate inline elements as inline-block
                        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                            if (jQuery.css(elem, "float") === "none") {

                                // Restore the original display value at the end of pure show/hide animations
                                if (!propTween) {
                                    anim.done(function() {
                                        style.display = restoreDisplay;
                                    });
                                    if (restoreDisplay == null) {
                                        display = style.display;
                                        restoreDisplay = display === "none" ? "" : display;
                                    }
                                }
                                style.display = "inline-block";
                            }
                        }
                    }

                    if (opts.overflow) {
                        style.overflow = "hidden";
                        anim.always(function() {
                            style.overflow = opts.overflow[0];
                            style.overflowX = opts.overflow[1];
                            style.overflowY = opts.overflow[2];
                        });
                    }

                    // Implement show/hide animations
                    propTween = false;
                    for (prop in orig) {

                        // General show/hide setup for this element animation
                        if (!propTween) {
                            if (dataShow) {
                                if ("hidden" in dataShow) {
                                    hidden = dataShow.hidden;
                                }
                            } else {
                                dataShow = dataPriv.access(elem, "fxshow", {
                                    display: restoreDisplay
                                });
                            }

                            // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                            if (toggle) {
                                dataShow.hidden = !hidden;
                            }

                            // Show elements before animating them
                            if (hidden) {
                                showHide([elem], true);
                            }



                            anim.done(function() {



                                // The final step of a "hide" animation is actually hiding the element
                                if (!hidden) {
                                    showHide([elem]);
                                }
                                dataPriv.remove(elem, "fxshow");
                                for (prop in orig) {
                                    jQuery.style(elem, prop, orig[prop]);
                                }
                            });
                        }

                        // Per-property setup
                        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                        if (!(prop in dataShow)) {
                            dataShow[prop] = propTween.start;
                            if (hidden) {
                                propTween.end = propTween.start;
                                propTween.start = 0;
                            }
                        }
                    }
                }

                function propFilter(props, specialEasing) {
                    var index, name, easing, value, hooks;

                    // camelCase, specialEasing and expand cssHook pass
                    for (index in props) {
                        name = jQuery.camelCase(index);
                        easing = specialEasing[name];
                        value = props[index];
                        if (jQuery.isArray(value)) {
                            easing = value[1];
                            value = props[index] = value[0];
                        }

                        if (index !== name) {
                            props[name] = value;
                            delete props[index];
                        }

                        hooks = jQuery.cssHooks[name];
                        if (hooks && "expand" in hooks) {
                            value = hooks.expand(value);
                            delete props[name];

                            // Not quite $.extend, this won't overwrite existing keys.
                            // Reusing 'index' because we have the correct "name"
                            for (index in value) {
                                if (!(index in props)) {
                                    props[index] = value[index];
                                    specialEasing[index] = easing;
                                }
                            }
                        } else {
                            specialEasing[name] = easing;
                        }
                    }
                }

                function Animation(elem, properties, options) {
                    var result,
                        stopped,
                        index = 0,
                        length = Animation.prefilters.length,
                        deferred = jQuery.Deferred().always(function() {

                            // Don't match elem in the :animated selector
                            delete tick.elem;
                        }),
                        tick = function() {
                            if (stopped) {
                                return false;
                            }
                            var currentTime = fxNow || createFxNow(),
                                remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

                                // Support: Android 2.3 only
                                // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                                temp = remaining / animation.duration || 0,
                                percent = 1 - temp,
                                index = 0,
                                length = animation.tweens.length;

                            for (; index < length; index++) {
                                animation.tweens[index].run(percent);
                            }

                            deferred.notifyWith(elem, [animation, percent, remaining]);

                            if (percent < 1 && length) {
                                return remaining;
                            } else {
                                deferred.resolveWith(elem, [animation]);
                                return false;
                            }
                        },
                        animation = deferred.promise({
                            elem: elem,
                            props: jQuery.extend({}, properties),
                            opts: jQuery.extend(true, {
                                specialEasing: {},
                                easing: jQuery.easing._default
                            }, options),
                            originalProperties: properties,
                            originalOptions: options,
                            startTime: fxNow || createFxNow(),
                            duration: options.duration,
                            tweens: [],
                            createTween: function(prop, end) {
                                var tween = jQuery.Tween(elem, animation.opts, prop, end,
                                    animation.opts.specialEasing[prop] || animation.opts.easing);
                                animation.tweens.push(tween);
                                return tween;
                            },
                            stop: function(gotoEnd) {
                                var index = 0,

                                    // If we are going to the end, we want to run all the tweens
                                    // otherwise we skip this part
                                    length = gotoEnd ? animation.tweens.length : 0;
                                if (stopped) {
                                    return this;
                                }
                                stopped = true;
                                for (; index < length; index++) {
                                    animation.tweens[index].run(1);
                                }

                                // Resolve when we played the last frame; otherwise, reject
                                if (gotoEnd) {
                                    deferred.notifyWith(elem, [animation, 1, 0]);
                                    deferred.resolveWith(elem, [animation, gotoEnd]);
                                } else {
                                    deferred.rejectWith(elem, [animation, gotoEnd]);
                                }
                                return this;
                            }
                        }),
                        props = animation.props;

                    propFilter(props, animation.opts.specialEasing);

                    for (; index < length; index++) {
                        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
                        if (result) {
                            if (jQuery.isFunction(result.stop)) {
                                jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
                                    jQuery.proxy(result.stop, result);
                            }
                            return result;
                        }
                    }

                    jQuery.map(props, createTween, animation);

                    if (jQuery.isFunction(animation.opts.start)) {
                        animation.opts.start.call(elem, animation);
                    }

                    jQuery.fx.timer(
                        jQuery.extend(tick, {
                            elem: elem,
                            anim: animation,
                            queue: animation.opts.queue
                        })
                    );

                    // attach callbacks from options
                    return animation.progress(animation.opts.progress)
                        .done(animation.opts.done, animation.opts.complete)
                        .fail(animation.opts.fail)
                        .always(animation.opts.always);
                }

                jQuery.Animation = jQuery.extend(Animation, {

                    tweeners: {
                        "*": [function(prop, value) {
                            var tween = this.createTween(prop, value);
                            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                            return tween;
                        }]
                    },

                    tweener: function(props, callback) {
                        if (jQuery.isFunction(props)) {
                            callback = props;
                            props = ["*"];
                        } else {
                            props = props.match(rnothtmlwhite);
                        }

                        var prop,
                            index = 0,
                            length = props.length;

                        for (; index < length; index++) {
                            prop = props[index];
                            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                            Animation.tweeners[prop].unshift(callback);
                        }
                    },

                    prefilters: [defaultPrefilter],

                    prefilter: function(callback, prepend) {
                        if (prepend) {
                            Animation.prefilters.unshift(callback);
                        } else {
                            Animation.prefilters.push(callback);
                        }
                    }
                });

                jQuery.speed = function(speed, easing, fn) {
                    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                        complete: fn || !fn && easing ||
                            jQuery.isFunction(speed) && speed,
                        duration: speed,
                        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                    };

                    // Go to the end state if fx are off or if document is hidden
                    if (jQuery.fx.off || document.hidden) {
                        opt.duration = 0;

                    } else {
                        if (typeof opt.duration !== "number") {
                            if (opt.duration in jQuery.fx.speeds) {
                                opt.duration = jQuery.fx.speeds[opt.duration];

                            } else {
                                opt.duration = jQuery.fx.speeds._default;
                            }
                        }
                    }

                    // Normalize opt.queue - true/undefined/null -> "fx"
                    if (opt.queue == null || opt.queue === true) {
                        opt.queue = "fx";
                    }

                    // Queueing
                    opt.old = opt.complete;

                    opt.complete = function() {
                        if (jQuery.isFunction(opt.old)) {
                            opt.old.call(this);
                        }

                        if (opt.queue) {
                            jQuery.dequeue(this, opt.queue);
                        }
                    };

                    return opt;
                };

                jQuery.fn.extend({
                    fadeTo: function(speed, to, easing, callback) {

                        // Show any hidden elements after setting opacity to 0
                        return this.filter(isHiddenWithinTree).css("opacity", 0).show()

                        // Animate to the value specified
                        .end().animate({
                            opacity: to
                        }, speed, easing, callback);
                    },
                    animate: function(prop, speed, easing, callback) {
                        var empty = jQuery.isEmptyObject(prop),
                            optall = jQuery.speed(speed, easing, callback),
                            doAnimation = function() {

                                // Operate on a copy of prop so per-property easing won't be lost
                                var anim = Animation(this, jQuery.extend({}, prop), optall);

                                // Empty animations, or finishing resolves immediately
                                if (empty || dataPriv.get(this, "finish")) {
                                    anim.stop(true);
                                }
                            };
                        doAnimation.finish = doAnimation;

                        return empty || optall.queue === false ?
                            this.each(doAnimation) :
                            this.queue(optall.queue, doAnimation);
                    },
                    stop: function(type, clearQueue, gotoEnd) {
                        var stopQueue = function(hooks) {
                            var stop = hooks.stop;
                            delete hooks.stop;
                            stop(gotoEnd);
                        };

                        if (typeof type !== "string") {
                            gotoEnd = clearQueue;
                            clearQueue = type;
                            type = undefined;
                        }
                        if (clearQueue && type !== false) {
                            this.queue(type || "fx", []);
                        }

                        return this.each(function() {
                            var dequeue = true,
                                index = type != null && type + "queueHooks",
                                timers = jQuery.timers,
                                data = dataPriv.get(this);

                            if (index) {
                                if (data[index] && data[index].stop) {
                                    stopQueue(data[index]);
                                }
                            } else {
                                for (index in data) {
                                    if (data[index] && data[index].stop && rrun.test(index)) {
                                        stopQueue(data[index]);
                                    }
                                }
                            }

                            for (index = timers.length; index--;) {
                                if (timers[index].elem === this &&
                                    (type == null || timers[index].queue === type)) {

                                    timers[index].anim.stop(gotoEnd);
                                    dequeue = false;
                                    timers.splice(index, 1);
                                }
                            }

                            // Start the next in the queue if the last step wasn't forced.
                            // Timers currently will call their complete callbacks, which
                            // will dequeue but only if they were gotoEnd.
                            if (dequeue || !gotoEnd) {
                                jQuery.dequeue(this, type);
                            }
                        });
                    },
                    finish: function(type) {
                        if (type !== false) {
                            type = type || "fx";
                        }
                        return this.each(function() {
                            var index,
                                data = dataPriv.get(this),
                                queue = data[type + "queue"],
                                hooks = data[type + "queueHooks"],
                                timers = jQuery.timers,
                                length = queue ? queue.length : 0;

                            // Enable finishing flag on private data
                            data.finish = true;

                            // Empty the queue first
                            jQuery.queue(this, type, []);

                            if (hooks && hooks.stop) {
                                hooks.stop.call(this, true);
                            }

                            // Look for any active animations, and finish them
                            for (index = timers.length; index--;) {
                                if (timers[index].elem === this && timers[index].queue === type) {
                                    timers[index].anim.stop(true);
                                    timers.splice(index, 1);
                                }
                            }

                            // Look for any animations in the old queue and finish them
                            for (index = 0; index < length; index++) {
                                if (queue[index] && queue[index].finish) {
                                    queue[index].finish.call(this);
                                }
                            }

                            // Turn off finishing flag
                            delete data.finish;
                        });
                    }
                });

                jQuery.each(["toggle", "show", "hide"], function(i, name) {
                    var cssFn = jQuery.fn[name];
                    jQuery.fn[name] = function(speed, easing, callback) {
                        return speed == null || typeof speed === "boolean" ?
                            cssFn.apply(this, arguments) :
                            this.animate(genFx(name, true), speed, easing, callback);
                    };
                });

                // Generate shortcuts for custom animations
                jQuery.each({
                    slideDown: genFx("show"),
                    slideUp: genFx("hide"),
                    slideToggle: genFx("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, function(name, props) {
                    jQuery.fn[name] = function(speed, easing, callback) {
                        return this.animate(props, speed, easing, callback);
                    };
                });

                jQuery.timers = [];
                jQuery.fx.tick = function() {
                    var timer,
                        i = 0,
                        timers = jQuery.timers;

                    fxNow = jQuery.now();

                    for (; i < timers.length; i++) {
                        timer = timers[i];

                        // Checks the timer has not already been removed
                        if (!timer() && timers[i] === timer) {
                            timers.splice(i--, 1);
                        }
                    }

                    if (!timers.length) {
                        jQuery.fx.stop();
                    }
                    fxNow = undefined;
                };

                jQuery.fx.timer = function(timer) {
                    jQuery.timers.push(timer);
                    if (timer()) {
                        jQuery.fx.start();
                    } else {
                        jQuery.timers.pop();
                    }
                };

                jQuery.fx.interval = 13;
                jQuery.fx.start = function() {
                    if (!timerId) {
                        timerId = window.requestAnimationFrame ?
                            window.requestAnimationFrame(raf) :
                            window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
                    }
                };

                jQuery.fx.stop = function() {
                    if (window.cancelAnimationFrame) {
                        window.cancelAnimationFrame(timerId);
                    } else {
                        window.clearInterval(timerId);
                    }

                    timerId = null;
                };

                jQuery.fx.speeds = {
                    slow: 600,
                    fast: 200,

                    // Default speed
                    _default: 400
                };

                // Based off of the plugin by Clint Helfers, with permission.
                // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
                jQuery.fn.delay = function(time, type) {
                    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                    type = type || "fx";

                    return this.queue(type, function(next, hooks) {
                        var timeout = window.setTimeout(next, time);
                        hooks.stop = function() {
                            window.clearTimeout(timeout);
                        };
                    });
                };

                (function() {
                    var input = document.createElement("input"),
                        select = document.createElement("select"),
                        opt = select.appendChild(document.createElement("option"));

                    input.type = "checkbox";

                    // Support: Android <=4.3 only
                    // Default value for a checkbox should be "on"
                    support.checkOn = input.value !== "";

                    // Support: IE <=11 only
                    // Must access selectedIndex to make default options select
                    support.optSelected = opt.selected;

                    // Support: IE <=11 only
                    // An input loses its value after becoming a radio
                    input = document.createElement("input");
                    input.value = "t";
                    input.type = "radio";
                    support.radioValue = input.value === "t";
                })();

                var boolHook,
                    attrHandle = jQuery.expr.attrHandle;

                jQuery.fn.extend({
                    attr: function(name, value) {
                        return access(this, jQuery.attr, name, value, arguments.length > 1);
                    },

                    removeAttr: function(name) {
                        return this.each(function() {
                            jQuery.removeAttr(this, name);
                        });
                    }
                });

                jQuery.extend({
                    attr: function(elem, name, value) {
                        var ret, hooks,
                            nType = elem.nodeType;

                        // Don't get/set attributes on text, comment and attribute nodes
                        if (nType === 3 || nType === 8 || nType === 2) {
                            return;
                        }

                        // Fallback to prop when attributes are not supported
                        if (typeof elem.getAttribute === "undefined") {
                            return jQuery.prop(elem, name, value);
                        }

                        // Attribute hooks are determined by the lowercase version
                        // Grab necessary hook if one is defined
                        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                            hooks = jQuery.attrHooks[name.toLowerCase()] ||
                                (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
                        }

                        if (value !== undefined) {
                            if (value === null) {
                                jQuery.removeAttr(elem, name);
                                return;
                            }

                            if (hooks && "set" in hooks &&
                                (ret = hooks.set(elem, value, name)) !== undefined) {
                                return ret;
                            }

                            elem.setAttribute(name, value + "");
                            return value;
                        }

                        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                            return ret;
                        }

                        ret = jQuery.find.attr(elem, name);

                        // Non-existent attributes return null, we normalize to undefined
                        return ret == null ? undefined : ret;
                    },

                    attrHooks: {
                        type: {
                            set: function(elem, value) {
                                if (!support.radioValue && value === "radio" &&
                                    jQuery.nodeName(elem, "input")) {
                                    var val = elem.value;
                                    elem.setAttribute("type", value);
                                    if (val) {
                                        elem.value = val;
                                    }
                                    return value;
                                }
                            }
                        }
                    },

                    removeAttr: function(elem, value) {
                        var name,
                            i = 0,

                            // Attribute names can contain non-HTML whitespace characters
                            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                            attrNames = value && value.match(rnothtmlwhite);

                        if (attrNames && elem.nodeType === 1) {
                            while ((name = attrNames[i++])) {
                                elem.removeAttribute(name);
                            }
                        }
                    }
                });

                // Hooks for boolean attributes
                boolHook = {
                    set: function(elem, value, name) {
                        if (value === false) {

                            // Remove boolean attributes when set to false
                            jQuery.removeAttr(elem, name);
                        } else {
                            elem.setAttribute(name, name);
                        }
                        return name;
                    }
                };

                jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
                    var getter = attrHandle[name] || jQuery.find.attr;

                    attrHandle[name] = function(elem, name, isXML) {
                        var ret, handle,
                            lowercaseName = name.toLowerCase();

                        if (!isXML) {

                            // Avoid an infinite loop by temporarily removing this function from the getter
                            handle = attrHandle[lowercaseName];
                            attrHandle[lowercaseName] = ret;
                            ret = getter(elem, name, isXML) != null ?
                                lowercaseName :
                                null;
                            attrHandle[lowercaseName] = handle;
                        }
                        return ret;
                    };
                });

                var rfocusable = /^(?:input|select|textarea|button)$/i,
                    rclickable = /^(?:a|area)$/i;

                jQuery.fn.extend({
                    prop: function(name, value) {
                        return access(this, jQuery.prop, name, value, arguments.length > 1);
                    },

                    removeProp: function(name) {
                        return this.each(function() {
                            delete this[jQuery.propFix[name] || name];
                        });
                    }
                });

                jQuery.extend({
                    prop: function(elem, name, value) {
                        var ret, hooks,
                            nType = elem.nodeType;

                        // Don't get/set properties on text, comment and attribute nodes
                        if (nType === 3 || nType === 8 || nType === 2) {
                            return;
                        }

                        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                            // Fix name and attach hooks
                            name = jQuery.propFix[name] || name;
                            hooks = jQuery.propHooks[name];
                        }

                        if (value !== undefined) {
                            if (hooks && "set" in hooks &&
                                (ret = hooks.set(elem, value, name)) !== undefined) {
                                return ret;
                            }

                            return (elem[name] = value);
                        }

                        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                            return ret;
                        }

                        return elem[name];
                    },

                    propHooks: {
                        tabIndex: {
                            get: function(elem) {

                                // Support: IE <=9 - 11 only
                                // elem.tabIndex doesn't always return the
                                // correct value when it hasn't been explicitly set
                                // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                                // Use proper attribute retrieval(#12072)
                                var tabindex = jQuery.find.attr(elem, "tabindex");

                                if (tabindex) {
                                    return parseInt(tabindex, 10);
                                }

                                if (
                                    rfocusable.test(elem.nodeName) ||
                                    rclickable.test(elem.nodeName) &&
                                    elem.href
                                ) {
                                    return 0;
                                }

                                return -1;
                            }
                        }
                    },

                    propFix: {
                        "for": "htmlFor",
                        "class": "className"
                    }
                });

                // Support: IE <=11 only
                // Accessing the selectedIndex property
                // forces the browser to respect setting selected
                // on the option
                // The getter ensures a default option is selected
                // when in an optgroup
                // eslint rule "no-unused-expressions" is disabled for this code
                // since it considers such accessions noop
                if (!support.optSelected) {
                    jQuery.propHooks.selected = {
                        get: function(elem) {



                            var parent = elem.parentNode;
                            if (parent && parent.parentNode) {
                                parent.parentNode.selectedIndex;
                            }
                            return null;
                        },
                        set: function(elem) {



                            var parent = elem.parentNode;
                            if (parent) {
                                parent.selectedIndex;

                                if (parent.parentNode) {
                                    parent.parentNode.selectedIndex;
                                }
                            }
                        }
                    };
                }

                jQuery.each([
                    "tabIndex",
                    "readOnly",
                    "maxLength",
                    "cellSpacing",
                    "cellPadding",
                    "rowSpan",
                    "colSpan",
                    "useMap",
                    "frameBorder",
                    "contentEditable"
                ], function() {
                    jQuery.propFix[this.toLowerCase()] = this;
                });

                // Strip and collapse whitespace according to HTML spec
                // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
                function stripAndCollapse(value) {
                    var tokens = value.match(rnothtmlwhite) || [];
                    return tokens.join(" ");
                }

                function getClass(elem) {
                    return elem.getAttribute && elem.getAttribute("class") || "";
                }

                jQuery.fn.extend({
                    addClass: function(value) {
                        var classes, elem, cur, curValue, clazz, j, finalValue,
                            i = 0;

                        if (jQuery.isFunction(value)) {
                            return this.each(function(j) {
                                jQuery(this).addClass(value.call(this, j, getClass(this)));
                            });
                        }

                        if (typeof value === "string" && value) {
                            classes = value.match(rnothtmlwhite) || [];

                            while ((elem = this[i++])) {
                                curValue = getClass(elem);
                                cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                                if (cur) {
                                    j = 0;
                                    while ((clazz = classes[j++])) {
                                        if (cur.indexOf(" " + clazz + " ") < 0) {
                                            cur += clazz + " ";
                                        }
                                    }

                                    // Only assign if different to avoid unneeded rendering.
                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue) {
                                        elem.setAttribute("class", finalValue);
                                    }
                                }
                            }
                        }

                        return this;
                    },

                    removeClass: function(value) {
                        var classes, elem, cur, curValue, clazz, j, finalValue,
                            i = 0;

                        if (jQuery.isFunction(value)) {
                            return this.each(function(j) {
                                jQuery(this).removeClass(value.call(this, j, getClass(this)));
                            });
                        }

                        if (!arguments.length) {
                            return this.attr("class", "");
                        }

                        if (typeof value === "string" && value) {
                            classes = value.match(rnothtmlwhite) || [];

                            while ((elem = this[i++])) {
                                curValue = getClass(elem);

                                // This expression is here for better compressibility (see addClass)
                                cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                                if (cur) {
                                    j = 0;
                                    while ((clazz = classes[j++])) {

                                        // Remove *all* instances
                                        while (cur.indexOf(" " + clazz + " ") > -1) {
                                            cur = cur.replace(" " + clazz + " ", " ");
                                        }
                                    }

                                    // Only assign if different to avoid unneeded rendering.
                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue) {
                                        elem.setAttribute("class", finalValue);
                                    }
                                }
                            }
                        }

                        return this;
                    },

                    toggleClass: function(value, stateVal) {
                        var type = typeof value;

                        if (typeof stateVal === "boolean" && type === "string") {
                            return stateVal ? this.addClass(value) : this.removeClass(value);
                        }

                        if (jQuery.isFunction(value)) {
                            return this.each(function(i) {
                                jQuery(this).toggleClass(
                                    value.call(this, i, getClass(this), stateVal),
                                    stateVal
                                );
                            });
                        }

                        return this.each(function() {
                            var className, i, self, classNames;

                            if (type === "string") {

                                // Toggle individual class names
                                i = 0;
                                self = jQuery(this);
                                classNames = value.match(rnothtmlwhite) || [];

                                while ((className = classNames[i++])) {

                                    // Check each className given, space separated list
                                    if (self.hasClass(className)) {
                                        self.removeClass(className);
                                    } else {
                                        self.addClass(className);
                                    }
                                }

                                // Toggle whole class name
                            } else if (value === undefined || type === "boolean") {
                                className = getClass(this);
                                if (className) {

                                    // Store className if set
                                    dataPriv.set(this, "__className__", className);
                                }

                                // If the element has a class name or if we're passed `false`,
                                // then remove the whole classname (if there was one, the above saved it).
                                // Otherwise bring back whatever was previously saved (if anything),
                                // falling back to the empty string if nothing was stored.
                                if (this.setAttribute) {
                                    this.setAttribute("class",
                                        className || value === false ?
                                        "" :
                                        dataPriv.get(this, "__className__") || ""
                                    );
                                }
                            }
                        });
                    },

                    hasClass: function(selector) {
                        var className, elem,
                            i = 0;

                        className = " " + selector + " ";
                        while ((elem = this[i++])) {
                            if (elem.nodeType === 1 &&
                                (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                                return true;
                            }
                        }

                        return false;
                    }
                });

                var rreturn = /\r/g;

                jQuery.fn.extend({
                    val: function(value) {
                        var hooks, ret, isFunction,
                            elem = this[0];

                        if (!arguments.length) {
                            if (elem) {
                                hooks = jQuery.valHooks[elem.type] ||
                                    jQuery.valHooks[elem.nodeName.toLowerCase()];

                                if (hooks &&
                                    "get" in hooks &&
                                    (ret = hooks.get(elem, "value")) !== undefined
                                ) {
                                    return ret;
                                }

                                ret = elem.value;

                                // Handle most common string cases
                                if (typeof ret === "string") {
                                    return ret.replace(rreturn, "");
                                }

                                // Handle cases where value is null/undef or number
                                return ret == null ? "" : ret;
                            }

                            return;
                        }

                        isFunction = jQuery.isFunction(value);

                        return this.each(function(i) {
                            var val;

                            if (this.nodeType !== 1) {
                                return;
                            }

                            if (isFunction) {
                                val = value.call(this, i, jQuery(this).val());
                            } else {
                                val = value;
                            }

                            // Treat null/undefined as ""; convert numbers to string
                            if (val == null) {
                                val = "";

                            } else if (typeof val === "number") {
                                val += "";

                            } else if (jQuery.isArray(val)) {
                                val = jQuery.map(val, function(value) {
                                    return value == null ? "" : value + "";
                                });
                            }

                            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                            // If set returns undefined, fall back to normal setting
                            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                                this.value = val;
                            }
                        });
                    }
                });

                jQuery.extend({
                    valHooks: {
                        option: {
                            get: function(elem) {

                                var val = jQuery.find.attr(elem, "value");
                                return val != null ?
                                    val :

                                    // Support: IE <=10 - 11 only
                                    // option.text throws exceptions (#14686, #14858)
                                    // Strip and collapse whitespace
                                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                                    stripAndCollapse(jQuery.text(elem));
                            }
                        },
                        select: {
                            get: function(elem) {
                                var value, option, i,
                                    options = elem.options,
                                    index = elem.selectedIndex,
                                    one = elem.type === "select-one",
                                    values = one ? null : [],
                                    max = one ? index + 1 : options.length;

                                if (index < 0) {
                                    i = max;

                                } else {
                                    i = one ? index : 0;
                                }

                                // Loop through all the selected options
                                for (; i < max; i++) {
                                    option = options[i];

                                    // Support: IE <=9 only
                                    // IE8-9 doesn't update selected after form reset (#2551)
                                    if ((option.selected || i === index) &&

                                        // Don't return options that are disabled or in a disabled optgroup
                                        !option.disabled &&
                                        (!option.parentNode.disabled ||
                                            !jQuery.nodeName(option.parentNode, "optgroup"))) {

                                        // Get the specific value for the option
                                        value = jQuery(option).val();

                                        // We don't need an array for one selects
                                        if (one) {
                                            return value;
                                        }

                                        // Multi-Selects return an array
                                        values.push(value);
                                    }
                                }

                                return values;
                            },

                            set: function(elem, value) {
                                var optionSet, option,
                                    options = elem.options,
                                    values = jQuery.makeArray(value),
                                    i = options.length;

                                while (i--) {
                                    option = options[i];



                                    if (option.selected =
                                        jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
                                    ) {
                                        optionSet = true;
                                    }


                                }

                                // Force browsers to behave consistently when non-matching value is set
                                if (!optionSet) {
                                    elem.selectedIndex = -1;
                                }
                                return values;
                            }
                        }
                    }
                });

                // Radios and checkboxes getter/setter
                jQuery.each(["radio", "checkbox"], function() {
                    jQuery.valHooks[this] = {
                        set: function(elem, value) {
                            if (jQuery.isArray(value)) {
                                return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                            }
                        }
                    };
                    if (!support.checkOn) {
                        jQuery.valHooks[this].get = function(elem) {
                            return elem.getAttribute("value") === null ? "on" : elem.value;
                        };
                    }
                });

                // Return jQuery for attributes-only inclusion

                var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

                jQuery.extend(jQuery.event, {

                    trigger: function(event, data, elem, onlyHandlers) {

                        var i, cur, tmp, bubbleType, ontype, handle, special,
                            eventPath = [elem || document],
                            type = hasOwn.call(event, "type") ? event.type : event,
                            namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

                        cur = tmp = elem = elem || document;

                        // Don't do events on text and comment nodes
                        if (elem.nodeType === 3 || elem.nodeType === 8) {
                            return;
                        }

                        // focus/blur morphs to focusin/out; ensure we're not firing them right now
                        if (rfocusMorph.test(type + jQuery.event.triggered)) {
                            return;
                        }

                        if (type.indexOf(".") > -1) {

                            // Namespaced trigger; create a regexp to match event type in handle()
                            namespaces = type.split(".");
                            type = namespaces.shift();
                            namespaces.sort();
                        }
                        ontype = type.indexOf(":") < 0 && "on" + type;

                        // Caller can pass in a jQuery.Event object, Object, or just an event type string
                        event = event[jQuery.expando] ?
                            event :
                            new jQuery.Event(type, typeof event === "object" && event);

                        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                        event.isTrigger = onlyHandlers ? 2 : 3;
                        event.namespace = namespaces.join(".");
                        event.rnamespace = event.namespace ?
                            new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                            null;

                        // Clean up the event in case it is being reused
                        event.result = undefined;
                        if (!event.target) {
                            event.target = elem;
                        }

                        // Clone any incoming data and prepend the event, creating the handler arg list
                        data = data == null ? [event] :
                            jQuery.makeArray(data, [event]);

                        // Allow special events to draw outside the lines
                        special = jQuery.event.special[type] || {};
                        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                            return;
                        }

                        // Determine event propagation path in advance, per W3C events spec (#9951)
                        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                        if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                            bubbleType = special.delegateType || type;
                            if (!rfocusMorph.test(bubbleType + type)) {
                                cur = cur.parentNode;
                            }
                            for (; cur; cur = cur.parentNode) {
                                eventPath.push(cur);
                                tmp = cur;
                            }

                            // Only add window if we got to document (e.g., not plain obj or detached DOM)
                            if (tmp === (elem.ownerDocument || document)) {
                                eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                            }
                        }

                        // Fire handlers on the event path
                        i = 0;
                        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                            event.type = i > 1 ?
                                bubbleType :
                                special.bindType || type;

                            // jQuery handler
                            handle = (dataPriv.get(cur, "events") || {})[event.type] &&
                                dataPriv.get(cur, "handle");
                            if (handle) {
                                handle.apply(cur, data);
                            }

                            // Native handler
                            handle = ontype && cur[ontype];
                            if (handle && handle.apply && acceptData(cur)) {
                                event.result = handle.apply(cur, data);
                                if (event.result === false) {
                                    event.preventDefault();
                                }
                            }
                        }
                        event.type = type;

                        // If nobody prevented the default action, do it now
                        if (!onlyHandlers && !event.isDefaultPrevented()) {

                            if ((!special._default ||
                                    special._default.apply(eventPath.pop(), data) === false) &&
                                acceptData(elem)) {

                                // Call a native DOM method on the target with the same name as the event.
                                // Don't do default actions on window, that's where global variables be (#6170)
                                if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

                                    // Don't re-trigger an onFOO event when we call its FOO() method
                                    tmp = elem[ontype];

                                    if (tmp) {
                                        elem[ontype] = null;
                                    }

                                    // Prevent re-triggering of the same event, since we already bubbled it above
                                    jQuery.event.triggered = type;
                                    elem[type]();
                                    jQuery.event.triggered = undefined;

                                    if (tmp) {
                                        elem[ontype] = tmp;
                                    }
                                }
                            }
                        }

                        return event.result;
                    },

                    // Piggyback on a donor event to simulate a different one
                    // Used only for `focus(in | out)` events
                    simulate: function(type, elem, event) {
                        var e = jQuery.extend(
                            new jQuery.Event(),
                            event, {
                                type: type,
                                isSimulated: true
                            }
                        );

                        jQuery.event.trigger(e, null, elem);
                    }

                });

                jQuery.fn.extend({

                    trigger: function(type, data) {
                        return this.each(function() {
                            jQuery.event.trigger(type, data, this);
                        });
                    },
                    triggerHandler: function(type, data) {
                        var elem = this[0];
                        if (elem) {
                            return jQuery.event.trigger(type, data, elem, true);
                        }
                    }
                });

                jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
                        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                        "change select submit keydown keypress keyup contextmenu").split(" "),
                    function(i, name) {

                        // Handle event binding
                        jQuery.fn[name] = function(data, fn) {
                            return arguments.length > 0 ?
                                this.on(name, null, data, fn) :
                                this.trigger(name);
                        };
                    });

                jQuery.fn.extend({
                    hover: function(fnOver, fnOut) {
                        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                    }
                });

                support.focusin = "onfocusin" in window;

                // Support: Firefox <=44
                // Firefox doesn't have focus(in | out) events
                // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
                //
                // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
                // focus(in | out) events fire after focus & blur events,
                // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
                // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
                if (!support.focusin) {
                    jQuery.each({
                        focus: "focusin",
                        blur: "focusout"
                    }, function(orig, fix) {

                        // Attach a single capturing handler on the document while someone wants focusin/focusout
                        var handler = function(event) {
                            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
                        };

                        jQuery.event.special[fix] = {
                            setup: function() {
                                var doc = this.ownerDocument || this,
                                    attaches = dataPriv.access(doc, fix);

                                if (!attaches) {
                                    doc.addEventListener(orig, handler, true);
                                }
                                dataPriv.access(doc, fix, (attaches || 0) + 1);
                            },
                            teardown: function() {
                                var doc = this.ownerDocument || this,
                                    attaches = dataPriv.access(doc, fix) - 1;

                                if (!attaches) {
                                    doc.removeEventListener(orig, handler, true);
                                    dataPriv.remove(doc, fix);

                                } else {
                                    dataPriv.access(doc, fix, attaches);
                                }
                            }
                        };
                    });
                }
                var location = window.location;

                var nonce = jQuery.now();

                var rquery = (/\?/);

                // Cross-browser xml parsing
                jQuery.parseXML = function(data) {
                    var xml;
                    if (!data || typeof data !== "string") {
                        return null;
                    }

                    // Support: IE 9 - 11 only
                    // IE throws on parseFromString with invalid input.
                    try {
                        xml = (new window.DOMParser()).parseFromString(data, "text/xml");
                    } catch (e) {
                        xml = undefined;
                    }

                    if (!xml || xml.getElementsByTagName("parsererror").length) {
                        jQuery.error("Invalid XML: " + data);
                    }
                    return xml;
                };

                var
                    rbracket = /\[\]$/,
                    rCRLF = /\r?\n/g,
                    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                    rsubmittable = /^(?:input|select|textarea|keygen)/i;

                function buildParams(prefix, obj, traditional, add) {
                    var name;

                    if (jQuery.isArray(obj)) {

                        // Serialize array item.
                        jQuery.each(obj, function(i, v) {
                            if (traditional || rbracket.test(prefix)) {

                                // Treat each array item as a scalar.
                                add(prefix, v);

                            } else {

                                // Item is non-scalar (array or object), encode its numeric index.
                                buildParams(
                                    prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                                    v,
                                    traditional,
                                    add
                                );
                            }
                        });

                    } else if (!traditional && jQuery.type(obj) === "object") {

                        // Serialize object item.
                        for (name in obj) {
                            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                        }

                    } else {

                        // Serialize scalar item.
                        add(prefix, obj);
                    }
                }

                // Serialize an array of form elements or a set of
                // key/values into a query string
                jQuery.param = function(a, traditional) {
                    var prefix,
                        s = [],
                        add = function(key, valueOrFunction) {

                            // If value is a function, invoke it and use its return value
                            var value = jQuery.isFunction(valueOrFunction) ?
                                valueOrFunction() :
                                valueOrFunction;

                            s[s.length] = encodeURIComponent(key) + "=" +
                                encodeURIComponent(value == null ? "" : value);
                        };

                    // If an array was passed in, assume that it is an array of form elements.
                    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

                        // Serialize the form elements
                        jQuery.each(a, function() {
                            add(this.name, this.value);
                        });

                    } else {

                        // If traditional, encode the "old" way (the way 1.3.2 or older
                        // did it), otherwise encode params recursively.
                        for (prefix in a) {
                            buildParams(prefix, a[prefix], traditional, add);
                        }
                    }

                    // Return the resulting serialization
                    return s.join("&");
                };

                jQuery.fn.extend({
                    serialize: function() {
                        return jQuery.param(this.serializeArray());
                    },
                    serializeArray: function() {
                        return this.map(function() {

                                // Can add propHook for "elements" to filter or add form elements
                                var elements = jQuery.prop(this, "elements");
                                return elements ? jQuery.makeArray(elements) : this;
                            })
                            .filter(function() {
                                var type = this.type;

                                // Use .is( ":disabled" ) so that fieldset[disabled] works
                                return this.name && !jQuery(this).is(":disabled") &&
                                    rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                                    (this.checked || !rcheckableType.test(type));
                            })
                            .map(function(i, elem) {
                                var val = jQuery(this).val();

                                if (val == null) {
                                    return null;
                                }

                                if (jQuery.isArray(val)) {
                                    return jQuery.map(val, function(val) {
                                        return {
                                            name: elem.name,
                                            value: val.replace(rCRLF, "\r\n")
                                        };
                                    });
                                }

                                return {
                                    name: elem.name,
                                    value: val.replace(rCRLF, "\r\n")
                                };
                            }).get();
                    }
                });

                var
                    r20 = /%20/g,
                    rhash = /#.*$/,
                    rantiCache = /([?&])_=[^&]*/,
                    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

                    // #7653, #8125, #8152: local protocol detection
                    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                    rnoContent = /^(?:GET|HEAD)$/,
                    rprotocol = /^\/\//,


                    prefilters = {},


                    transports = {},

                    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                    allTypes = "*/".concat("*"),

                    // Anchor tag for parsing the document origin
                    originAnchor = document.createElement("a");
                originAnchor.href = location.href;

                // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
                function addToPrefiltersOrTransports(structure) {

                    // dataTypeExpression is optional and defaults to "*"
                    return function(dataTypeExpression, func) {

                        if (typeof dataTypeExpression !== "string") {
                            func = dataTypeExpression;
                            dataTypeExpression = "*";
                        }

                        var dataType,
                            i = 0,
                            dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

                        if (jQuery.isFunction(func)) {

                            // For each dataType in the dataTypeExpression
                            while ((dataType = dataTypes[i++])) {

                                // Prepend if requested
                                if (dataType[0] === "+") {
                                    dataType = dataType.slice(1) || "*";
                                    (structure[dataType] = structure[dataType] || []).unshift(func);

                                    // Otherwise append
                                } else {
                                    (structure[dataType] = structure[dataType] || []).push(func);
                                }
                            }
                        }
                    };
                }

                // Base inspection function for prefilters and transports
                function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

                    var inspected = {},
                        seekingTransport = (structure === transports);

                    function inspect(dataType) {
                        var selected;
                        inspected[dataType] = true;
                        jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                            if (typeof dataTypeOrTransport === "string" &&
                                !seekingTransport && !inspected[dataTypeOrTransport]) {

                                options.dataTypes.unshift(dataTypeOrTransport);
                                inspect(dataTypeOrTransport);
                                return false;
                            } else if (seekingTransport) {
                                return !(selected = dataTypeOrTransport);
                            }
                        });
                        return selected;
                    }

                    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
                }

                // A special extend for ajax options
                // that takes "flat" options (not to be deep extended)
                // Fixes #9887
                function ajaxExtend(target, src) {
                    var key, deep,
                        flatOptions = jQuery.ajaxSettings.flatOptions || {};

                    for (key in src) {
                        if (src[key] !== undefined) {
                            (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
                        }
                    }
                    if (deep) {
                        jQuery.extend(true, target, deep);
                    }

                    return target;
                }

                function ajaxHandleResponses(s, jqXHR, responses) {

                    var ct, type, finalDataType, firstDataType,
                        contents = s.contents,
                        dataTypes = s.dataTypes;

                    // Remove auto dataType and get content-type in the process
                    while (dataTypes[0] === "*") {
                        dataTypes.shift();
                        if (ct === undefined) {
                            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                        }
                    }

                    // Check if we're dealing with a known content-type
                    if (ct) {
                        for (type in contents) {
                            if (contents[type] && contents[type].test(ct)) {
                                dataTypes.unshift(type);
                                break;
                            }
                        }
                    }

                    // Check to see if we have a response for the expected dataType
                    if (dataTypes[0] in responses) {
                        finalDataType = dataTypes[0];
                    } else {

                        // Try convertible dataTypes
                        for (type in responses) {
                            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                                finalDataType = type;
                                break;
                            }
                            if (!firstDataType) {
                                firstDataType = type;
                            }
                        }

                        // Or just use first one
                        finalDataType = finalDataType || firstDataType;
                    }

                    // If we found a dataType
                    // We add the dataType to the list if needed
                    // and return the corresponding response
                    if (finalDataType) {
                        if (finalDataType !== dataTypes[0]) {
                            dataTypes.unshift(finalDataType);
                        }
                        return responses[finalDataType];
                    }
                }

                function ajaxConvert(s, response, jqXHR, isSuccess) {
                    var conv2, current, conv, tmp, prev,
                        converters = {},

                        // Work with a copy of dataTypes in case we need to modify it for conversion
                        dataTypes = s.dataTypes.slice();

                    // Create converters map with lowercased keys
                    if (dataTypes[1]) {
                        for (conv in s.converters) {
                            converters[conv.toLowerCase()] = s.converters[conv];
                        }
                    }

                    current = dataTypes.shift();

                    // Convert to each sequential dataType
                    while (current) {

                        if (s.responseFields[current]) {
                            jqXHR[s.responseFields[current]] = response;
                        }

                        // Apply the dataFilter if provided
                        if (!prev && isSuccess && s.dataFilter) {
                            response = s.dataFilter(response, s.dataType);
                        }

                        prev = current;
                        current = dataTypes.shift();

                        if (current) {

                            // There's only work to do if current dataType is non-auto
                            if (current === "*") {

                                current = prev;

                                // Convert response if prev dataType is non-auto and differs from current
                            } else if (prev !== "*" && prev !== current) {

                                // Seek a direct converter
                                conv = converters[prev + " " + current] || converters["* " + current];

                                // If none found, seek a pair
                                if (!conv) {
                                    for (conv2 in converters) {

                                        // If conv2 outputs current
                                        tmp = conv2.split(" ");
                                        if (tmp[1] === current) {

                                            // If prev can be converted to accepted input
                                            conv = converters[prev + " " + tmp[0]] ||
                                                converters["* " + tmp[0]];
                                            if (conv) {

                                                // Condense equivalence converters
                                                if (conv === true) {
                                                    conv = converters[conv2];

                                                    // Otherwise, insert the intermediate dataType
                                                } else if (converters[conv2] !== true) {
                                                    current = tmp[0];
                                                    dataTypes.unshift(tmp[1]);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }

                                // Apply converter (if not an equivalence)
                                if (conv !== true) {

                                    // Unless errors are allowed to bubble, catch and return them
                                    if (conv && s.throws) {
                                        response = conv(response);
                                    } else {
                                        try {
                                            response = conv(response);
                                        } catch (e) {
                                            return {
                                                state: "parsererror",
                                                error: conv ? e : "No conversion from " + prev + " to " + current
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return {
                        state: "success",
                        data: response
                    };
                }

                jQuery.extend({

                    // Counter for holding the number of active queries
                    active: 0,

                    // Last-Modified header cache for next request
                    lastModified: {},
                    etag: {},

                    ajaxSettings: {
                        url: location.href,
                        type: "GET",
                        isLocal: rlocalProtocol.test(location.protocol),
                        global: true,
                        processData: true,
                        async: true,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",



                        accepts: {
                            "*": allTypes,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },

                        contents: {
                            xml: /\bxml\b/,
                            html: /\bhtml/,
                            json: /\bjson\b/
                        },

                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },

                        // Data converters
                        // Keys separate source (or catchall "*") and destination types with a single space
                        converters: {

                            // Convert anything to text
                            "* text": String,

                            // Text to html (true = no transformation)
                            "text html": true,

                            // Evaluate text as a json expression
                            "text json": JSON.parse,

                            // Parse text as xml
                            "text xml": jQuery.parseXML
                        },

                        // For options that shouldn't be deep extended:
                        // you can add your own custom options here if
                        // and when you create one that shouldn't be
                        // deep extended (see ajaxExtend)
                        flatOptions: {
                            url: true,
                            context: true
                        }
                    },

                    // Creates a full fledged settings object into target
                    // with both ajaxSettings and settings fields.
                    // If target is omitted, writes into ajaxSettings.
                    ajaxSetup: function(target, settings) {
                        return settings ?

                            // Building a settings object
                            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                            // Extending ajaxSettings
                            ajaxExtend(jQuery.ajaxSettings, target);
                    },

                    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                    ajaxTransport: addToPrefiltersOrTransports(transports),

                    // Main method
                    ajax: function(url, options) {

                        // If url is an object, simulate pre-1.5 signature
                        if (typeof url === "object") {
                            options = url;
                            url = undefined;
                        }

                        // Force options to be an object
                        options = options || {};

                        var transport,

                            // URL without anti-cache param
                            cacheURL,

                            // Response headers
                            responseHeadersString,
                            responseHeaders,

                            // timeout handle
                            timeoutTimer,

                            // Url cleanup var
                            urlAnchor,

                            // Request state (becomes false upon send and true upon completion)
                            completed,

                            // To know if global events are to be dispatched
                            fireGlobals,

                            // Loop variable
                            i,

                            // uncached part of the url
                            uncached,

                            // Create the final options object
                            s = jQuery.ajaxSetup({}, options),

                            // Callbacks context
                            callbackContext = s.context || s,

                            // Context for global events is callbackContext if it is a DOM node or jQuery collection
                            globalEventContext = s.context &&
                            (callbackContext.nodeType || callbackContext.jquery) ?
                            jQuery(callbackContext) :
                            jQuery.event,

                            // Deferreds
                            deferred = jQuery.Deferred(),
                            completeDeferred = jQuery.Callbacks("once memory"),

                            // Status-dependent callbacks
                            statusCode = s.statusCode || {},

                            // Headers (they are sent all at once)
                            requestHeaders = {},
                            requestHeadersNames = {},

                            // Default abort message
                            strAbort = "canceled",

                            // Fake xhr
                            jqXHR = {
                                readyState: 0,

                                // Builds headers hashtable if needed
                                getResponseHeader: function(key) {
                                    var match;
                                    if (completed) {
                                        if (!responseHeaders) {
                                            responseHeaders = {};
                                            while ((match = rheaders.exec(responseHeadersString))) {
                                                responseHeaders[match[1].toLowerCase()] = match[2];
                                            }
                                        }
                                        match = responseHeaders[key.toLowerCase()];
                                    }
                                    return match == null ? null : match;
                                },

                                // Raw string
                                getAllResponseHeaders: function() {
                                    return completed ? responseHeadersString : null;
                                },

                                // Caches the header
                                setRequestHeader: function(name, value) {
                                    if (completed == null) {
                                        name = requestHeadersNames[name.toLowerCase()] =
                                            requestHeadersNames[name.toLowerCase()] || name;
                                        requestHeaders[name] = value;
                                    }
                                    return this;
                                },

                                // Overrides response content-type header
                                overrideMimeType: function(type) {
                                    if (completed == null) {
                                        s.mimeType = type;
                                    }
                                    return this;
                                },

                                // Status-dependent callbacks
                                statusCode: function(map) {
                                    var code;
                                    if (map) {
                                        if (completed) {

                                            // Execute the appropriate callbacks
                                            jqXHR.always(map[jqXHR.status]);
                                        } else {

                                            // Lazy-add the new callbacks in a way that preserves old ones
                                            for (code in map) {
                                                statusCode[code] = [statusCode[code], map[code]];
                                            }
                                        }
                                    }
                                    return this;
                                },

                                // Cancel the request
                                abort: function(statusText) {
                                    var finalText = statusText || strAbort;
                                    if (transport) {
                                        transport.abort(finalText);
                                    }
                                    done(0, finalText);
                                    return this;
                                }
                            };

                        // Attach deferreds
                        deferred.promise(jqXHR);

                        // Add protocol if not provided (prefilters might expect it)
                        // Handle falsy url in the settings object (#10093: consistency with old signature)
                        // We also use the url parameter if available
                        s.url = ((url || s.url || location.href) + "")
                            .replace(rprotocol, location.protocol + "//");

                        // Alias method option to type as per ticket #12004
                        s.type = options.method || options.type || s.method || s.type;

                        // Extract dataTypes list
                        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

                        // A cross-domain request is in order when the origin doesn't match the current origin.
                        if (s.crossDomain == null) {
                            urlAnchor = document.createElement("a");

                            // Support: IE <=8 - 11, Edge 12 - 13
                            // IE throws exception on accessing the href property if url is malformed,
                            // e.g. http://example.com:80x/
                            try {
                                urlAnchor.href = s.url;

                                // Support: IE <=8 - 11 only
                                // Anchor's host property isn't correctly set when s.url is relative
                                urlAnchor.href = urlAnchor.href;
                                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                                    urlAnchor.protocol + "//" + urlAnchor.host;
                            } catch (e) {

                                // If there is an error parsing the URL, assume it is crossDomain,
                                // it can be rejected by the transport if it is invalid
                                s.crossDomain = true;
                            }
                        }

                        // Convert data if not already a string
                        if (s.data && s.processData && typeof s.data !== "string") {
                            s.data = jQuery.param(s.data, s.traditional);
                        }

                        // Apply prefilters
                        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                        // If request was aborted inside a prefilter, stop there
                        if (completed) {
                            return jqXHR;
                        }

                        // We can fire global events as of now if asked to
                        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                        fireGlobals = jQuery.event && s.global;

                        // Watch for a new set of requests
                        if (fireGlobals && jQuery.active++ === 0) {
                            jQuery.event.trigger("ajaxStart");
                        }

                        // Uppercase the type
                        s.type = s.type.toUpperCase();

                        // Determine if request has content
                        s.hasContent = !rnoContent.test(s.type);

                        // Save the URL in case we're toying with the If-Modified-Since
                        // and/or If-None-Match header later on
                        // Remove hash to simplify url manipulation
                        cacheURL = s.url.replace(rhash, "");

                        // More options handling for requests with no content
                        if (!s.hasContent) {

                            // Remember the hash so we can put it back
                            uncached = s.url.slice(cacheURL.length);

                            // If data is available, append data to url
                            if (s.data) {
                                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

                                // #9682: remove data so that it's not used in an eventual retry
                                delete s.data;
                            }

                            // Add or update anti-cache param if needed
                            if (s.cache === false) {
                                cacheURL = cacheURL.replace(rantiCache, "$1");
                                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
                            }

                            // Put hash and anti-cache on the URL that will be requested (gh-1732)
                            s.url = cacheURL + uncached;

                            // Change '%20' to '+' if this is encoded form body content (gh-2658)
                        } else if (s.data && s.processData &&
                            (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                            s.data = s.data.replace(r20, "+");
                        }

                        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                        if (s.ifModified) {
                            if (jQuery.lastModified[cacheURL]) {
                                jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                            }
                            if (jQuery.etag[cacheURL]) {
                                jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                            }
                        }

                        // Set the correct header, if data is being sent
                        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                            jqXHR.setRequestHeader("Content-Type", s.contentType);
                        }

                        // Set the Accepts header for the server, depending on the dataType
                        jqXHR.setRequestHeader(
                            "Accept",
                            s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                            s.accepts[s.dataTypes[0]] +
                            (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                            s.accepts["*"]
                        );

                        // Check for headers option
                        for (i in s.headers) {
                            jqXHR.setRequestHeader(i, s.headers[i]);
                        }

                        // Allow custom headers/mimetypes and early abort
                        if (s.beforeSend &&
                            (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

                            // Abort if not done already and return
                            return jqXHR.abort();
                        }

                        // Aborting is no longer a cancellation
                        strAbort = "abort";

                        // Install callbacks on deferreds
                        completeDeferred.add(s.complete);
                        jqXHR.done(s.success);
                        jqXHR.fail(s.error);

                        // Get transport
                        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

                        // If no transport, we auto-abort
                        if (!transport) {
                            done(-1, "No Transport");
                        } else {
                            jqXHR.readyState = 1;

                            // Send global event
                            if (fireGlobals) {
                                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                            }

                            // If request was aborted inside ajaxSend, stop there
                            if (completed) {
                                return jqXHR;
                            }

                            // Timeout
                            if (s.async && s.timeout > 0) {
                                timeoutTimer = window.setTimeout(function() {
                                    jqXHR.abort("timeout");
                                }, s.timeout);
                            }

                            try {
                                completed = false;
                                transport.send(requestHeaders, done);
                            } catch (e) {

                                // Rethrow post-completion exceptions
                                if (completed) {
                                    throw e;
                                }

                                // Propagate others as results
                                done(-1, e);
                            }
                        }

                        // Callback for when everything is done
                        function done(status, nativeStatusText, responses, headers) {
                            var isSuccess, success, error, response, modified,
                                statusText = nativeStatusText;

                            // Ignore repeat invocations
                            if (completed) {
                                return;
                            }

                            completed = true;

                            // Clear timeout if it exists
                            if (timeoutTimer) {
                                window.clearTimeout(timeoutTimer);
                            }

                            // Dereference transport for early garbage collection
                            // (no matter how long the jqXHR object will be used)
                            transport = undefined;

                            // Cache response headers
                            responseHeadersString = headers || "";

                            // Set readyState
                            jqXHR.readyState = status > 0 ? 4 : 0;

                            // Determine if successful
                            isSuccess = status >= 200 && status < 300 || status === 304;

                            // Get response data
                            if (responses) {
                                response = ajaxHandleResponses(s, jqXHR, responses);
                            }

                            // Convert no matter what (that way responseXXX fields are always set)
                            response = ajaxConvert(s, response, jqXHR, isSuccess);

                            // If successful, handle type chaining
                            if (isSuccess) {

                                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                if (s.ifModified) {
                                    modified = jqXHR.getResponseHeader("Last-Modified");
                                    if (modified) {
                                        jQuery.lastModified[cacheURL] = modified;
                                    }
                                    modified = jqXHR.getResponseHeader("etag");
                                    if (modified) {
                                        jQuery.etag[cacheURL] = modified;
                                    }
                                }

                                // if no content
                                if (status === 204 || s.type === "HEAD") {
                                    statusText = "nocontent";

                                    // if not modified
                                } else if (status === 304) {
                                    statusText = "notmodified";

                                    // If we have data, let's convert it
                                } else {
                                    statusText = response.state;
                                    success = response.data;
                                    error = response.error;
                                    isSuccess = !error;
                                }
                            } else {

                                // Extract error from statusText and normalize for non-aborts
                                error = statusText;
                                if (status || !statusText) {
                                    statusText = "error";
                                    if (status < 0) {
                                        status = 0;
                                    }
                                }
                            }

                            // Set data for the fake xhr object
                            jqXHR.status = status;
                            jqXHR.statusText = (nativeStatusText || statusText) + "";

                            // Success/Error
                            if (isSuccess) {
                                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                            } else {
                                deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                            }

                            // Status-dependent callbacks
                            jqXHR.statusCode(statusCode);
                            statusCode = undefined;

                            if (fireGlobals) {
                                globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                            }

                            // Complete
                            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                            if (fireGlobals) {
                                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                                // Handle the global AJAX counter
                                if (!(--jQuery.active)) {
                                    jQuery.event.trigger("ajaxStop");
                                }
                            }
                        }

                        return jqXHR;
                    },

                    getJSON: function(url, data, callback) {
                        return jQuery.get(url, data, callback, "json");
                    },

                    getScript: function(url, callback) {
                        return jQuery.get(url, undefined, callback, "script");
                    }
                });

                jQuery.each(["get", "post"], function(i, method) {
                    jQuery[method] = function(url, data, callback, type) {

                        // Shift arguments if data argument was omitted
                        if (jQuery.isFunction(data)) {
                            type = type || callback;
                            callback = data;
                            data = undefined;
                        }

                        // The url can be an options object (which then must have .url)
                        return jQuery.ajax(jQuery.extend({
                            url: url,
                            type: method,
                            dataType: type,
                            data: data,
                            success: callback
                        }, jQuery.isPlainObject(url) && url));
                    };
                });

                jQuery._evalUrl = function(url) {
                    return jQuery.ajax({
                        url: url,

                        // Make this explicit, since user can override this through ajaxSetup (#11264)
                        type: "GET",
                        dataType: "script",
                        cache: true,
                        async: false,
                        global: false,
                        "throws": true
                    });
                };

                jQuery.fn.extend({
                    wrapAll: function(html) {
                        var wrap;

                        if (this[0]) {
                            if (jQuery.isFunction(html)) {
                                html = html.call(this[0]);
                            }

                            // The elements to wrap the target around
                            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                            if (this[0].parentNode) {
                                wrap.insertBefore(this[0]);
                            }

                            wrap.map(function() {
                                var elem = this;

                                while (elem.firstElementChild) {
                                    elem = elem.firstElementChild;
                                }

                                return elem;
                            }).append(this);
                        }

                        return this;
                    },

                    wrapInner: function(html) {
                        if (jQuery.isFunction(html)) {
                            return this.each(function(i) {
                                jQuery(this).wrapInner(html.call(this, i));
                            });
                        }

                        return this.each(function() {
                            var self = jQuery(this),
                                contents = self.contents();

                            if (contents.length) {
                                contents.wrapAll(html);

                            } else {
                                self.append(html);
                            }
                        });
                    },

                    wrap: function(html) {
                        var isFunction = jQuery.isFunction(html);

                        return this.each(function(i) {
                            jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                        });
                    },

                    unwrap: function(selector) {
                        this.parent(selector).not("body").each(function() {
                            jQuery(this).replaceWith(this.childNodes);
                        });
                        return this;
                    }
                });

                jQuery.expr.pseudos.hidden = function(elem) {
                    return !jQuery.expr.pseudos.visible(elem);
                };
                jQuery.expr.pseudos.visible = function(elem) {
                    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
                };

                jQuery.ajaxSettings.xhr = function() {
                    try {
                        return new window.XMLHttpRequest();
                    } catch (e) {}
                };

                var xhrSuccessStatus = {

                        // File protocol always yields status code 0, assume 200
                        0: 200,

                        // Support: IE <=9 only
                        // #1450: sometimes IE returns 1223 when it should be 204
                        1223: 204
                    },
                    xhrSupported = jQuery.ajaxSettings.xhr();

                support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
                support.ajax = xhrSupported = !!xhrSupported;

                jQuery.ajaxTransport(function(options) {
                    var callback, errorCallback;

                    // Cross domain only allowed if supported through XMLHttpRequest
                    if (support.cors || xhrSupported && !options.crossDomain) {
                        return {
                            send: function(headers, complete) {
                                var i,
                                    xhr = options.xhr();

                                xhr.open(
                                    options.type,
                                    options.url,
                                    options.async,
                                    options.username,
                                    options.password
                                );

                                // Apply custom fields if provided
                                if (options.xhrFields) {
                                    for (i in options.xhrFields) {
                                        xhr[i] = options.xhrFields[i];
                                    }
                                }

                                // Override mime type if needed
                                if (options.mimeType && xhr.overrideMimeType) {
                                    xhr.overrideMimeType(options.mimeType);
                                }

                                // X-Requested-With header
                                // For cross-domain requests, seeing as conditions for a preflight are
                                // akin to a jigsaw puzzle, we simply never set it to be sure.
                                // (it can always be set on a per-request basis or even using ajaxSetup)
                                // For same-domain requests, won't change header if already provided.
                                if (!options.crossDomain && !headers["X-Requested-With"]) {
                                    headers["X-Requested-With"] = "XMLHttpRequest";
                                }

                                // Set headers
                                for (i in headers) {
                                    xhr.setRequestHeader(i, headers[i]);
                                }

                                // Callback
                                callback = function(type) {
                                    return function() {
                                        if (callback) {
                                            callback = errorCallback = xhr.onload =
                                                xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                                            if (type === "abort") {
                                                xhr.abort();
                                            } else if (type === "error") {

                                                // Support: IE <=9 only
                                                // On a manual native abort, IE9 throws
                                                // errors on any property access that is not readyState
                                                if (typeof xhr.status !== "number") {
                                                    complete(0, "error");
                                                } else {
                                                    complete(

                                                        // File: protocol always yields status 0; see #8605, #14207
                                                        xhr.status,
                                                        xhr.statusText
                                                    );
                                                }
                                            } else {
                                                complete(
                                                    xhrSuccessStatus[xhr.status] || xhr.status,
                                                    xhr.statusText,

                                                    // Support: IE <=9 only
                                                    // IE9 has no XHR2 but throws on binary (trac-11426)
                                                    // For XHR2 non-text, let the caller handle it (gh-2498)
                                                    (xhr.responseType || "text") !== "text" ||
                                                    typeof xhr.responseText !== "string" ? {
                                                        binary: xhr.response
                                                    } : {
                                                        text: xhr.responseText
                                                    },
                                                    xhr.getAllResponseHeaders()
                                                );
                                            }
                                        }
                                    };
                                };

                                // Listen to events
                                xhr.onload = callback();
                                errorCallback = xhr.onerror = callback("error");

                                // Support: IE 9 only
                                // Use onreadystatechange to replace onabort
                                // to handle uncaught aborts
                                if (xhr.onabort !== undefined) {
                                    xhr.onabort = errorCallback;
                                } else {
                                    xhr.onreadystatechange = function() {

                                        // Check readyState before timeout as it changes
                                        if (xhr.readyState === 4) {

                                            // Allow onerror to be called first,
                                            // but that will not handle a native abort
                                            // Also, save errorCallback to a variable
                                            // as xhr.onerror cannot be accessed
                                            window.setTimeout(function() {
                                                if (callback) {
                                                    errorCallback();
                                                }
                                            });
                                        }
                                    };
                                }

                                // Create the abort callback
                                callback = callback("abort");

                                try {

                                    // Do send the request (this may raise an exception)
                                    xhr.send(options.hasContent && options.data || null);
                                } catch (e) {

                                    // #14683: Only rethrow if this hasn't been notified as an error yet
                                    if (callback) {
                                        throw e;
                                    }
                                }
                            },

                            abort: function() {
                                if (callback) {
                                    callback();
                                }
                            }
                        };
                    }
                });

                // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
                jQuery.ajaxPrefilter(function(s) {
                    if (s.crossDomain) {
                        s.contents.script = false;
                    }
                });

                // Install script dataType
                jQuery.ajaxSetup({
                    accepts: {
                        script: "text/javascript, application/javascript, " +
                            "application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /\b(?:java|ecma)script\b/
                    },
                    converters: {
                        "text script": function(text) {
                            jQuery.globalEval(text);
                            return text;
                        }
                    }
                });

                // Handle cache's special case and crossDomain
                jQuery.ajaxPrefilter("script", function(s) {
                    if (s.cache === undefined) {
                        s.cache = false;
                    }
                    if (s.crossDomain) {
                        s.type = "GET";
                    }
                });

                // Bind script tag hack transport
                jQuery.ajaxTransport("script", function(s) {

                    // This transport only deals with cross domain requests
                    if (s.crossDomain) {
                        var script, callback;
                        return {
                            send: function(_, complete) {
                                script = jQuery("<script>").prop({
                                    charset: s.scriptCharset,
                                    src: s.url
                                }).on(
                                    "load error",
                                    callback = function(evt) {
                                        script.remove();
                                        callback = null;
                                        if (evt) {
                                            complete(evt.type === "error" ? 404 : 200, evt.type);
                                        }
                                    }
                                );

                                // Use native DOM manipulation to avoid our domManip AJAX trickery
                                document.head.appendChild(script[0]);
                            },
                            abort: function() {
                                if (callback) {
                                    callback();
                                }
                            }
                        };
                    }
                });

                var oldCallbacks = [],
                    rjsonp = /(=)\?(?=&|$)|\?\?/;

                // Default jsonp settings
                jQuery.ajaxSetup({
                    jsonp: "callback",
                    jsonpCallback: function() {
                        var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
                        this[callback] = true;
                        return callback;
                    }
                });

                // Detect, normalize options and install callbacks for jsonp requests
                jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

                    var callbackName, overwritten, responseContainer,
                        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                            "url" :
                            typeof s.data === "string" &&
                            (s.contentType || "")
                            .indexOf("application/x-www-form-urlencoded") === 0 &&
                            rjsonp.test(s.data) && "data"
                        );

                    // Handle iff the expected data type is "jsonp" or we have a parameter to set
                    if (jsonProp || s.dataTypes[0] === "jsonp") {

                        // Get callback name, remembering preexisting value associated with it
                        callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                            s.jsonpCallback() :
                            s.jsonpCallback;

                        // Insert callback into url or form data
                        if (jsonProp) {
                            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                        } else if (s.jsonp !== false) {
                            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                        }

                        // Use data converter to retrieve json after script execution
                        s.converters["script json"] = function() {
                            if (!responseContainer) {
                                jQuery.error(callbackName + " was not called");
                            }
                            return responseContainer[0];
                        };

                        // Force json dataType
                        s.dataTypes[0] = "json";

                        // Install callback
                        overwritten = window[callbackName];
                        window[callbackName] = function() {
                            responseContainer = arguments;
                        };

                        // Clean-up function (fires after converters)
                        jqXHR.always(function() {

                            // If previous value didn't exist - remove it
                            if (overwritten === undefined) {
                                jQuery(window).removeProp(callbackName);

                                // Otherwise restore preexisting value
                            } else {
                                window[callbackName] = overwritten;
                            }

                            // Save back as free
                            if (s[callbackName]) {

                                // Make sure that re-using the options doesn't screw things around
                                s.jsonpCallback = originalSettings.jsonpCallback;

                                // Save the callback name for future use
                                oldCallbacks.push(callbackName);
                            }

                            // Call if it was a function and we have a response
                            if (responseContainer && jQuery.isFunction(overwritten)) {
                                overwritten(responseContainer[0]);
                            }

                            responseContainer = overwritten = undefined;
                        });

                        // Delegate to script
                        return "script";
                    }
                });

                // Support: Safari 8 only
                // In Safari 8 documents created via document.implementation.createHTMLDocument
                // collapse sibling forms: the second one becomes a child of the first one.
                // Because of that, this security measure has to be disabled in Safari 8.
                // https://bugs.webkit.org/show_bug.cgi?id=137337
                support.createHTMLDocument = (function() {
                    var body = document.implementation.createHTMLDocument("").body;
                    body.innerHTML = "<form></form><form></form>";
                    return body.childNodes.length === 2;
                })();

                // Argument "data" should be string of html
                // context (optional): If specified, the fragment will be created in this context,
                // defaults to document
                // keepScripts (optional): If true, will include scripts passed in the html string
                jQuery.parseHTML = function(data, context, keepScripts) {
                    if (typeof data !== "string") {
                        return [];
                    }
                    if (typeof context === "boolean") {
                        keepScripts = context;
                        context = false;
                    }

                    var base, parsed, scripts;

                    if (!context) {

                        // Stop scripts or inline event handlers from being executed immediately
                        // by using document.implementation
                        if (support.createHTMLDocument) {
                            context = document.implementation.createHTMLDocument("");

                            // Set the base href for the created document
                            // so any parsed elements with URLs
                            // are based on the document's URL (gh-2965)
                            base = context.createElement("base");
                            base.href = document.location.href;
                            context.head.appendChild(base);
                        } else {
                            context = document;
                        }
                    }

                    parsed = rsingleTag.exec(data);
                    scripts = !keepScripts && [];

                    // Single tag
                    if (parsed) {
                        return [context.createElement(parsed[1])];
                    }

                    parsed = buildFragment([data], context, scripts);

                    if (scripts && scripts.length) {
                        jQuery(scripts).remove();
                    }

                    return jQuery.merge([], parsed.childNodes);
                };

                jQuery.fn.load = function(url, params, callback) {
                    var selector, type, response,
                        self = this,
                        off = url.indexOf(" ");

                    if (off > -1) {
                        selector = stripAndCollapse(url.slice(off));
                        url = url.slice(0, off);
                    }

                    // If it's a function
                    if (jQuery.isFunction(params)) {

                        // We assume that it's the callback
                        callback = params;
                        params = undefined;

                        // Otherwise, build a param string
                    } else if (params && typeof params === "object") {
                        type = "POST";
                    }

                    // If we have elements to modify, make the request
                    if (self.length > 0) {
                        jQuery.ajax({
                            url: url,

                            // If "type" variable is undefined, then "GET" method will be used.
                            // Make value of this field explicit since
                            // user can override it through ajaxSetup method
                            type: type || "GET",
                            dataType: "html",
                            data: params
                        }).done(function(responseText) {

                            // Save response for use in complete callback
                            response = arguments;

                            self.html(selector ?

                                // If a selector was specified, locate the right elements in a dummy div
                                // Exclude scripts to avoid IE 'Permission Denied' errors
                                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                                // Otherwise use the full result
                                responseText);

                            // If the request succeeds, this function gets "data", "status", "jqXHR"
                            // but they are ignored because response was set above.
                            // If it fails, this function gets "jqXHR", "status", "error"
                        }).always(callback && function(jqXHR, status) {
                            self.each(function() {
                                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                            });
                        });
                    }

                    return this;
                };

                // Attach a bunch of functions for handling common AJAX events
                jQuery.each([
                    "ajaxStart",
                    "ajaxStop",
                    "ajaxComplete",
                    "ajaxError",
                    "ajaxSuccess",
                    "ajaxSend"
                ], function(i, type) {
                    jQuery.fn[type] = function(fn) {
                        return this.on(type, fn);
                    };
                });

                jQuery.expr.pseudos.animated = function(elem) {
                    return jQuery.grep(jQuery.timers, function(fn) {
                        return elem === fn.elem;
                    }).length;
                };

                function getWindow(elem) {
                    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
                }

                jQuery.offset = {
                    setOffset: function(elem, options, i) {
                        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                            position = jQuery.css(elem, "position"),
                            curElem = jQuery(elem),
                            props = {};

                        // Set position first, in-case top/left are set even on static elem
                        if (position === "static") {
                            elem.style.position = "relative";
                        }

                        curOffset = curElem.offset();
                        curCSSTop = jQuery.css(elem, "top");
                        curCSSLeft = jQuery.css(elem, "left");
                        calculatePosition = (position === "absolute" || position === "fixed") &&
                            (curCSSTop + curCSSLeft).indexOf("auto") > -1;

                        // Need to be able to calculate position if either
                        // top or left is auto and position is either absolute or fixed
                        if (calculatePosition) {
                            curPosition = curElem.position();
                            curTop = curPosition.top;
                            curLeft = curPosition.left;

                        } else {
                            curTop = parseFloat(curCSSTop) || 0;
                            curLeft = parseFloat(curCSSLeft) || 0;
                        }

                        if (jQuery.isFunction(options)) {

                            // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                            options = options.call(elem, i, jQuery.extend({}, curOffset));
                        }

                        if (options.top != null) {
                            props.top = (options.top - curOffset.top) + curTop;
                        }
                        if (options.left != null) {
                            props.left = (options.left - curOffset.left) + curLeft;
                        }

                        if ("using" in options) {
                            options.using.call(elem, props);

                        } else {
                            curElem.css(props);
                        }
                    }
                };

                jQuery.fn.extend({
                    offset: function(options) {

                        // Preserve chaining for setter
                        if (arguments.length) {
                            return options === undefined ?
                                this :
                                this.each(function(i) {
                                    jQuery.offset.setOffset(this, options, i);
                                });
                        }

                        var docElem, win, rect, doc,
                            elem = this[0];

                        if (!elem) {
                            return;
                        }

                        // Support: IE <=11 only
                        // Running getBoundingClientRect on a
                        // disconnected node in IE throws an error
                        if (!elem.getClientRects().length) {
                            return {
                                top: 0,
                                left: 0
                            };
                        }

                        rect = elem.getBoundingClientRect();

                        // Make sure element is not hidden (display: none)
                        if (rect.width || rect.height) {
                            doc = elem.ownerDocument;
                            win = getWindow(doc);
                            docElem = doc.documentElement;

                            return {
                                top: rect.top + win.pageYOffset - docElem.clientTop,
                                left: rect.left + win.pageXOffset - docElem.clientLeft
                            };
                        }

                        // Return zeros for disconnected and hidden elements (gh-2310)
                        return rect;
                    },

                    position: function() {
                        if (!this[0]) {
                            return;
                        }

                        var offsetParent, offset,
                            elem = this[0],
                            parentOffset = {
                                top: 0,
                                left: 0
                            };

                        // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                        // because it is its only offset parent
                        if (jQuery.css(elem, "position") === "fixed") {

                            // Assume getBoundingClientRect is there when computed position is fixed
                            offset = elem.getBoundingClientRect();

                        } else {

                            // Get *real* offsetParent
                            offsetParent = this.offsetParent();

                            // Get correct offsets
                            offset = this.offset();
                            if (!jQuery.nodeName(offsetParent[0], "html")) {
                                parentOffset = offsetParent.offset();
                            }

                            // Add offsetParent borders
                            parentOffset = {
                                top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
                                left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
                            };
                        }

                        // Subtract parent offsets and element margins
                        return {
                            top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                            left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                        };
                    },

                    // This method will return documentElement in the following cases:
                    // 1) For the element inside the iframe without offsetParent, this method will return
                    //    documentElement of the parent window
                    // 2) For the hidden or detached element
                    // 3) For body or html element, i.e. in case of the html node - it will return itself
                    //
                    // but those exceptions were never presented as a real life use-cases
                    // and might be considered as more preferable results.
                    //
                    // This logic, however, is not guaranteed and can change at any point in the future
                    offsetParent: function() {
                        return this.map(function() {
                            var offsetParent = this.offsetParent;

                            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                                offsetParent = offsetParent.offsetParent;
                            }

                            return offsetParent || documentElement;
                        });
                    }
                });

                // Create scrollLeft and scrollTop methods
                jQuery.each({
                    scrollLeft: "pageXOffset",
                    scrollTop: "pageYOffset"
                }, function(method, prop) {
                    var top = "pageYOffset" === prop;

                    jQuery.fn[method] = function(val) {
                        return access(this, function(elem, method, val) {
                            var win = getWindow(elem);

                            if (val === undefined) {
                                return win ? win[prop] : elem[method];
                            }

                            if (win) {
                                win.scrollTo(!top ? val : win.pageXOffset,
                                    top ? val : win.pageYOffset
                                );

                            } else {
                                elem[method] = val;
                            }
                        }, method, val, arguments.length);
                    };
                });

                // Support: Safari <=7 - 9.1, Chrome <=37 - 49
                // Add the top/left cssHooks using jQuery.fn.position
                // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
                // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
                // getComputedStyle returns percent when specified for top/left/bottom/right;
                // rather than make the css module depend on the offset module, just check for it here
                jQuery.each(["top", "left"], function(i, prop) {
                    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
                        function(elem, computed) {
                            if (computed) {
                                computed = curCSS(elem, prop);

                                // If curCSS returns percentage, fallback to offset
                                return rnumnonpx.test(computed) ?
                                    jQuery(elem).position()[prop] + "px" :
                                    computed;
                            }
                        }
                    );
                });

                // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
                jQuery.each({
                    Height: "height",
                    Width: "width"
                }, function(name, type) {
                    jQuery.each({
                            padding: "inner" + name,
                            content: type,
                            "": "outer" + name
                        },
                        function(defaultExtra, funcName) {

                            // Margin is only for outerHeight, outerWidth
                            jQuery.fn[funcName] = function(margin, value) {
                                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                                return access(this, function(elem, type, value) {
                                    var doc;

                                    if (jQuery.isWindow(elem)) {

                                        // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                                        return funcName.indexOf("outer") === 0 ?
                                            elem["inner" + name] :
                                            elem.document.documentElement["client" + name];
                                    }

                                    // Get document width or height
                                    if (elem.nodeType === 9) {
                                        doc = elem.documentElement;

                                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                        // whichever is greatest
                                        return Math.max(
                                            elem.body["scroll" + name], doc["scroll" + name],
                                            elem.body["offset" + name], doc["offset" + name],
                                            doc["client" + name]
                                        );
                                    }

                                    return value === undefined ?

                                        // Get width or height on the element, requesting but not forcing parseFloat
                                        jQuery.css(elem, type, extra) :

                                        // Set width or height on the element
                                        jQuery.style(elem, type, value, extra);
                                }, type, chainable ? margin : undefined, chainable);
                            };
                        });
                });

                jQuery.fn.extend({

                    bind: function(types, data, fn) {
                        return this.on(types, null, data, fn);
                    },
                    unbind: function(types, fn) {
                        return this.off(types, null, fn);
                    },

                    delegate: function(selector, types, data, fn) {
                        return this.on(types, selector, data, fn);
                    },
                    undelegate: function(selector, types, fn) {

                        // ( namespace ) or ( selector, types [, fn] )
                        return arguments.length === 1 ?
                            this.off(selector, "**") :
                            this.off(types, selector || "**", fn);
                    }
                });

                jQuery.parseJSON = JSON.parse;

                // Register as a named AMD module, since jQuery can be concatenated with other
                // files that may use define, but not via a proper concatenation script that
                // understands anonymous AMD modules. A named AMD is safest and most robust
                // way to register. Lowercase jquery is used because AMD module names are
                // derived from file names, and jQuery is normally delivered in a lowercase
                // file name. Do this after creating the global so that if an AMD module wants
                // to call noConflict to hide this version of jQuery, it will work.

                // Note that for maximum portability, libraries that are not jQuery should
                // declare themselves as anonymous modules, and avoid setting a global if an
                // AMD loader is present. jQuery is a special case. For more information, see
                // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

                if (typeof define === "function" && define.amd) {
                    define("jquery", [], function() {
                        return jQuery;
                    });
                }

                var

                // Map over jQuery in case of overwrite
                    _jQuery = window.jQuery,

                    // Map over the $ in case of overwrite
                    _$ = window.$;

                jQuery.noConflict = function(deep) {
                    if (window.$ === jQuery) {
                        window.$ = _$;
                    }

                    if (deep && window.jQuery === jQuery) {
                        window.jQuery = _jQuery;
                    }

                    return jQuery;
                };

                // Expose jQuery and $ identifiers, even in AMD
                // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
                // and CommonJS for browser emulators (#13566)
                if (!noGlobal) {
                    window.jQuery = window.$ = jQuery;
                }

                return jQuery;
            });

        }, {}],
        26: [function(_dereq_, module, exports) {
            (function(global) {

                ;
                (function() {


                    var undefined;


                    var VERSION = '4.17.2';


                    var LARGE_ARRAY_SIZE = 200;


                    var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
                        FUNC_ERROR_TEXT = 'Expected a function';


                    var HASH_UNDEFINED = '__lodash_hash_undefined__';


                    var MAX_MEMOIZE_SIZE = 500;


                    var PLACEHOLDER = '__lodash_placeholder__';


                    var CLONE_DEEP_FLAG = 1,
                        CLONE_FLAT_FLAG = 2,
                        CLONE_SYMBOLS_FLAG = 4;


                    var COMPARE_PARTIAL_FLAG = 1,
                        COMPARE_UNORDERED_FLAG = 2;


                    var WRAP_BIND_FLAG = 1,
                        WRAP_BIND_KEY_FLAG = 2,
                        WRAP_CURRY_BOUND_FLAG = 4,
                        WRAP_CURRY_FLAG = 8,
                        WRAP_CURRY_RIGHT_FLAG = 16,
                        WRAP_PARTIAL_FLAG = 32,
                        WRAP_PARTIAL_RIGHT_FLAG = 64,
                        WRAP_ARY_FLAG = 128,
                        WRAP_REARG_FLAG = 256,
                        WRAP_FLIP_FLAG = 512;


                    var DEFAULT_TRUNC_LENGTH = 30,
                        DEFAULT_TRUNC_OMISSION = '...';


                    var HOT_COUNT = 800,
                        HOT_SPAN = 16;


                    var LAZY_FILTER_FLAG = 1,
                        LAZY_MAP_FLAG = 2,
                        LAZY_WHILE_FLAG = 3;


                    var INFINITY = 1 / 0,
                        MAX_SAFE_INTEGER = 9007199254740991,
                        MAX_INTEGER = 1.7976931348623157e+308,
                        NAN = 0 / 0;


                    var MAX_ARRAY_LENGTH = 4294967295,
                        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;


                    var wrapFlags = [
                        ['ary', WRAP_ARY_FLAG],
                        ['bind', WRAP_BIND_FLAG],
                        ['bindKey', WRAP_BIND_KEY_FLAG],
                        ['curry', WRAP_CURRY_FLAG],
                        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
                        ['flip', WRAP_FLIP_FLAG],
                        ['partial', WRAP_PARTIAL_FLAG],
                        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
                        ['rearg', WRAP_REARG_FLAG]
                    ];


                    var argsTag = '[object Arguments]',
                        arrayTag = '[object Array]',
                        asyncTag = '[object AsyncFunction]',
                        boolTag = '[object Boolean]',
                        dateTag = '[object Date]',
                        domExcTag = '[object DOMException]',
                        errorTag = '[object Error]',
                        funcTag = '[object Function]',
                        genTag = '[object GeneratorFunction]',
                        mapTag = '[object Map]',
                        numberTag = '[object Number]',
                        nullTag = '[object Null]',
                        objectTag = '[object Object]',
                        promiseTag = '[object Promise]',
                        proxyTag = '[object Proxy]',
                        regexpTag = '[object RegExp]',
                        setTag = '[object Set]',
                        stringTag = '[object String]',
                        symbolTag = '[object Symbol]',
                        undefinedTag = '[object Undefined]',
                        weakMapTag = '[object WeakMap]',
                        weakSetTag = '[object WeakSet]';

                    var arrayBufferTag = '[object ArrayBuffer]',
                        dataViewTag = '[object DataView]',
                        float32Tag = '[object Float32Array]',
                        float64Tag = '[object Float64Array]',
                        int8Tag = '[object Int8Array]',
                        int16Tag = '[object Int16Array]',
                        int32Tag = '[object Int32Array]',
                        uint8Tag = '[object Uint8Array]',
                        uint8ClampedTag = '[object Uint8ClampedArray]',
                        uint16Tag = '[object Uint16Array]',
                        uint32Tag = '[object Uint32Array]';


                    var reEmptyStringLeading = /\b__p \+= '';/g,
                        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;


                    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
                        reUnescapedHtml = /[&<>"']/g,
                        reHasEscapedHtml = RegExp(reEscapedHtml.source),
                        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);


                    var reEscape = /<%-([\s\S]+?)%>/g,
                        reEvaluate = /<%([\s\S]+?)%>/g,
                        reInterpolate = /<%=([\s\S]+?)%>/g;


                    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                        reIsPlainProp = /^\w*$/,
                        reLeadingDot = /^\./,
                        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;


                    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
                        reHasRegExpChar = RegExp(reRegExpChar.source);


                    var reTrim = /^\s+|\s+$/g,
                        reTrimStart = /^\s+/,
                        reTrimEnd = /\s+$/;


                    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
                        reSplitDetails = /,? & /;


                    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;


                    var reEscapeChar = /\\(\\)?/g;


                    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;


                    var reFlags = /\w*$/;


                    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;


                    var reIsBinary = /^0b[01]+$/i;


                    var reIsHostCtor = /^\[object .+?Constructor\]$/;


                    var reIsOctal = /^0o[0-7]+$/i;


                    var reIsUint = /^(?:0|[1-9]\d*)$/;


                    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;


                    var reNoMatch = /($^)/;


                    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;


                    var rsAstralRange = '\\ud800-\\udfff',
                        rsComboMarksRange = '\\u0300-\\u036f',
                        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
                        rsComboSymbolsRange = '\\u20d0-\\u20ff',
                        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
                        rsDingbatRange = '\\u2700-\\u27bf',
                        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
                        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
                        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
                        rsPunctuationRange = '\\u2000-\\u206f',
                        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
                        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
                        rsVarRange = '\\ufe0e\\ufe0f',
                        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;


                    var rsApos = "['\u2019]",
                        rsAstral = '[' + rsAstralRange + ']',
                        rsBreak = '[' + rsBreakRange + ']',
                        rsCombo = '[' + rsComboRange + ']',
                        rsDigits = '\\d+',
                        rsDingbat = '[' + rsDingbatRange + ']',
                        rsLower = '[' + rsLowerRange + ']',
                        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
                        rsFitz = '\\ud83c[\\udffb-\\udfff]',
                        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
                        rsNonAstral = '[^' + rsAstralRange + ']',
                        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
                        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
                        rsUpper = '[' + rsUpperRange + ']',
                        rsZWJ = '\\u200d';


                    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
                        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
                        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
                        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
                        reOptMod = rsModifier + '?',
                        rsOptVar = '[' + rsVarRange + ']?',
                        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
                        rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
                        rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
                        rsSeq = rsOptVar + reOptMod + rsOptJoin,
                        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
                        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';


                    var reApos = RegExp(rsApos, 'g');


                    var reComboMark = RegExp(rsCombo, 'g');


                    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');


                    var reUnicodeWord = RegExp([
                        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
                        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
                        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
                        rsUpper + '+' + rsOptContrUpper,
                        rsOrdUpper,
                        rsOrdLower,
                        rsDigits,
                        rsEmoji
                    ].join('|'), 'g');


                    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');


                    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;


                    var contextProps = [
                        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
                        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
                        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
                        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
                        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
                    ];


                    var templateCounter = -1;


                    var typedArrayTags = {};
                    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                        typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                        typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                        typedArrayTags[uint32Tag] = true;
                    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                        typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                        typedArrayTags[errorTag] = typedArrayTags[funcTag] =
                        typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                        typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                        typedArrayTags[setTag] = typedArrayTags[stringTag] =
                        typedArrayTags[weakMapTag] = false;


                    var cloneableTags = {};
                    cloneableTags[argsTag] = cloneableTags[arrayTag] =
                        cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
                        cloneableTags[boolTag] = cloneableTags[dateTag] =
                        cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                        cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                        cloneableTags[int32Tag] = cloneableTags[mapTag] =
                        cloneableTags[numberTag] = cloneableTags[objectTag] =
                        cloneableTags[regexpTag] = cloneableTags[setTag] =
                        cloneableTags[stringTag] = cloneableTags[symbolTag] =
                        cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                        cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                    cloneableTags[errorTag] = cloneableTags[funcTag] =
                        cloneableTags[weakMapTag] = false;


                    var deburredLetters = {
                        // Latin-1 Supplement block.
                        '\xc0': 'A',
                        '\xc1': 'A',
                        '\xc2': 'A',
                        '\xc3': 'A',
                        '\xc4': 'A',
                        '\xc5': 'A',
                        '\xe0': 'a',
                        '\xe1': 'a',
                        '\xe2': 'a',
                        '\xe3': 'a',
                        '\xe4': 'a',
                        '\xe5': 'a',
                        '\xc7': 'C',
                        '\xe7': 'c',
                        '\xd0': 'D',
                        '\xf0': 'd',
                        '\xc8': 'E',
                        '\xc9': 'E',
                        '\xca': 'E',
                        '\xcb': 'E',
                        '\xe8': 'e',
                        '\xe9': 'e',
                        '\xea': 'e',
                        '\xeb': 'e',
                        '\xcc': 'I',
                        '\xcd': 'I',
                        '\xce': 'I',
                        '\xcf': 'I',
                        '\xec': 'i',
                        '\xed': 'i',
                        '\xee': 'i',
                        '\xef': 'i',
                        '\xd1': 'N',
                        '\xf1': 'n',
                        '\xd2': 'O',
                        '\xd3': 'O',
                        '\xd4': 'O',
                        '\xd5': 'O',
                        '\xd6': 'O',
                        '\xd8': 'O',
                        '\xf2': 'o',
                        '\xf3': 'o',
                        '\xf4': 'o',
                        '\xf5': 'o',
                        '\xf6': 'o',
                        '\xf8': 'o',
                        '\xd9': 'U',
                        '\xda': 'U',
                        '\xdb': 'U',
                        '\xdc': 'U',
                        '\xf9': 'u',
                        '\xfa': 'u',
                        '\xfb': 'u',
                        '\xfc': 'u',
                        '\xdd': 'Y',
                        '\xfd': 'y',
                        '\xff': 'y',
                        '\xc6': 'Ae',
                        '\xe6': 'ae',
                        '\xde': 'Th',
                        '\xfe': 'th',
                        '\xdf': 'ss',
                        // Latin Extended-A block.
                        '\u0100': 'A',
                        '\u0102': 'A',
                        '\u0104': 'A',
                        '\u0101': 'a',
                        '\u0103': 'a',
                        '\u0105': 'a',
                        '\u0106': 'C',
                        '\u0108': 'C',
                        '\u010a': 'C',
                        '\u010c': 'C',
                        '\u0107': 'c',
                        '\u0109': 'c',
                        '\u010b': 'c',
                        '\u010d': 'c',
                        '\u010e': 'D',
                        '\u0110': 'D',
                        '\u010f': 'd',
                        '\u0111': 'd',
                        '\u0112': 'E',
                        '\u0114': 'E',
                        '\u0116': 'E',
                        '\u0118': 'E',
                        '\u011a': 'E',
                        '\u0113': 'e',
                        '\u0115': 'e',
                        '\u0117': 'e',
                        '\u0119': 'e',
                        '\u011b': 'e',
                        '\u011c': 'G',
                        '\u011e': 'G',
                        '\u0120': 'G',
                        '\u0122': 'G',
                        '\u011d': 'g',
                        '\u011f': 'g',
                        '\u0121': 'g',
                        '\u0123': 'g',
                        '\u0124': 'H',
                        '\u0126': 'H',
                        '\u0125': 'h',
                        '\u0127': 'h',
                        '\u0128': 'I',
                        '\u012a': 'I',
                        '\u012c': 'I',
                        '\u012e': 'I',
                        '\u0130': 'I',
                        '\u0129': 'i',
                        '\u012b': 'i',
                        '\u012d': 'i',
                        '\u012f': 'i',
                        '\u0131': 'i',
                        '\u0134': 'J',
                        '\u0135': 'j',
                        '\u0136': 'K',
                        '\u0137': 'k',
                        '\u0138': 'k',
                        '\u0139': 'L',
                        '\u013b': 'L',
                        '\u013d': 'L',
                        '\u013f': 'L',
                        '\u0141': 'L',
                        '\u013a': 'l',
                        '\u013c': 'l',
                        '\u013e': 'l',
                        '\u0140': 'l',
                        '\u0142': 'l',
                        '\u0143': 'N',
                        '\u0145': 'N',
                        '\u0147': 'N',
                        '\u014a': 'N',
                        '\u0144': 'n',
                        '\u0146': 'n',
                        '\u0148': 'n',
                        '\u014b': 'n',
                        '\u014c': 'O',
                        '\u014e': 'O',
                        '\u0150': 'O',
                        '\u014d': 'o',
                        '\u014f': 'o',
                        '\u0151': 'o',
                        '\u0154': 'R',
                        '\u0156': 'R',
                        '\u0158': 'R',
                        '\u0155': 'r',
                        '\u0157': 'r',
                        '\u0159': 'r',
                        '\u015a': 'S',
                        '\u015c': 'S',
                        '\u015e': 'S',
                        '\u0160': 'S',
                        '\u015b': 's',
                        '\u015d': 's',
                        '\u015f': 's',
                        '\u0161': 's',
                        '\u0162': 'T',
                        '\u0164': 'T',
                        '\u0166': 'T',
                        '\u0163': 't',
                        '\u0165': 't',
                        '\u0167': 't',
                        '\u0168': 'U',
                        '\u016a': 'U',
                        '\u016c': 'U',
                        '\u016e': 'U',
                        '\u0170': 'U',
                        '\u0172': 'U',
                        '\u0169': 'u',
                        '\u016b': 'u',
                        '\u016d': 'u',
                        '\u016f': 'u',
                        '\u0171': 'u',
                        '\u0173': 'u',
                        '\u0174': 'W',
                        '\u0175': 'w',
                        '\u0176': 'Y',
                        '\u0177': 'y',
                        '\u0178': 'Y',
                        '\u0179': 'Z',
                        '\u017b': 'Z',
                        '\u017d': 'Z',
                        '\u017a': 'z',
                        '\u017c': 'z',
                        '\u017e': 'z',
                        '\u0132': 'IJ',
                        '\u0133': 'ij',
                        '\u0152': 'Oe',
                        '\u0153': 'oe',
                        '\u0149': "'n",
                        '\u017f': 's'
                    };


                    var htmlEscapes = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    };


                    var htmlUnescapes = {
                        '&amp;': '&',
                        '&lt;': '<',
                        '&gt;': '>',
                        '&quot;': '"',
                        '&#39;': "'"
                    };


                    var stringEscapes = {
                        '\\': '\\',
                        "'": "'",
                        '\n': 'n',
                        '\r': 'r',
                        '\u2028': 'u2028',
                        '\u2029': 'u2029'
                    };


                    var freeParseFloat = parseFloat,
                        freeParseInt = parseInt;


                    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;


                    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;


                    var root = freeGlobal || freeSelf || Function('return this')();


                    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;


                    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;


                    var moduleExports = freeModule && freeModule.exports === freeExports;


                    var freeProcess = moduleExports && freeGlobal.process;


                    var nodeUtil = (function() {
                        try {
                            return freeProcess && freeProcess.binding && freeProcess.binding('util');
                        } catch (e) {}
                    }());


                    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
                        nodeIsDate = nodeUtil && nodeUtil.isDate,
                        nodeIsMap = nodeUtil && nodeUtil.isMap,
                        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
                        nodeIsSet = nodeUtil && nodeUtil.isSet,
                        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;




                    function addMapEntry(map, pair) {
                        // Don't return `map.set` because it's not chainable in IE 11.
                        map.set(pair[0], pair[1]);
                        return map;
                    }


                    function addSetEntry(set, value) {
                        // Don't return `set.add` because it's not chainable in IE 11.
                        set.add(value);
                        return set;
                    }


                    function apply(func, thisArg, args) {
                        switch (args.length) {
                            case 0:
                                return func.call(thisArg);
                            case 1:
                                return func.call(thisArg, args[0]);
                            case 2:
                                return func.call(thisArg, args[0], args[1]);
                            case 3:
                                return func.call(thisArg, args[0], args[1], args[2]);
                        }
                        return func.apply(thisArg, args);
                    }


                    function arrayAggregator(array, setter, iteratee, accumulator) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            var value = array[index];
                            setter(accumulator, value, iteratee(value), array);
                        }
                        return accumulator;
                    }


                    function arrayEach(array, iteratee) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }


                    function arrayEachRight(array, iteratee) {
                        var length = array == null ? 0 : array.length;

                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }


                    function arrayEvery(array, predicate) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false;
                            }
                        }
                        return true;
                    }


                    function arrayFilter(array, predicate) {
                        var index = -1,
                            length = array == null ? 0 : array.length,
                            resIndex = 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[resIndex++] = value;
                            }
                        }
                        return result;
                    }


                    function arrayIncludes(array, value) {
                        var length = array == null ? 0 : array.length;
                        return !!length && baseIndexOf(array, value, 0) > -1;
                    }


                    function arrayIncludesWith(array, value, comparator) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (comparator(value, array[index])) {
                                return true;
                            }
                        }
                        return false;
                    }


                    function arrayMap(array, iteratee) {
                        var index = -1,
                            length = array == null ? 0 : array.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array);
                        }
                        return result;
                    }


                    function arrayPush(array, values) {
                        var index = -1,
                            length = values.length,
                            offset = array.length;

                        while (++index < length) {
                            array[offset + index] = values[index];
                        }
                        return array;
                    }


                    function arrayReduce(array, iteratee, accumulator, initAccum) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        if (initAccum && length) {
                            accumulator = array[++index];
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array);
                        }
                        return accumulator;
                    }


                    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                        var length = array == null ? 0 : array.length;
                        if (initAccum && length) {
                            accumulator = array[--length];
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array);
                        }
                        return accumulator;
                    }


                    function arraySome(array, predicate) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true;
                            }
                        }
                        return false;
                    }


                    var asciiSize = baseProperty('length');


                    function asciiToArray(string) {
                        return string.split('');
                    }


                    function asciiWords(string) {
                        return string.match(reAsciiWord) || [];
                    }


                    function baseFindKey(collection, predicate, eachFunc) {
                        var result;
                        eachFunc(collection, function(value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }


                    function baseFindIndex(array, predicate, fromIndex, fromRight) {
                        var length = array.length,
                            index = fromIndex + (fromRight ? 1 : -1);

                        while ((fromRight ? index-- : ++index < length)) {
                            if (predicate(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }


                    function baseIndexOf(array, value, fromIndex) {
                        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
                    }


                    function baseIndexOfWith(array, value, fromIndex, comparator) {
                        var index = fromIndex - 1,
                            length = array.length;

                        while (++index < length) {
                            if (comparator(array[index], value)) {
                                return index;
                            }
                        }
                        return -1;
                    }


                    function baseIsNaN(value) {
                        return value !== value;
                    }


                    function baseMean(array, iteratee) {
                        var length = array == null ? 0 : array.length;
                        return length ? (baseSum(array, iteratee) / length) : NAN;
                    }


                    function baseProperty(key) {
                        return function(object) {
                            return object == null ? undefined : object[key];
                        };
                    }


                    function basePropertyOf(object) {
                        return function(key) {
                            return object == null ? undefined : object[key];
                        };
                    }


                    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                        eachFunc(collection, function(value, index, collection) {
                            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }


                    function baseSortBy(array, comparer) {
                        var length = array.length;

                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value;
                        }
                        return array;
                    }


                    function baseSum(array, iteratee) {
                        var result,
                            index = -1,
                            length = array.length;

                        while (++index < length) {
                            var current = iteratee(array[index]);
                            if (current !== undefined) {
                                result = result === undefined ? current : (result + current);
                            }
                        }
                        return result;
                    }


                    function baseTimes(n, iteratee) {
                        var index = -1,
                            result = Array(n);

                        while (++index < n) {
                            result[index] = iteratee(index);
                        }
                        return result;
                    }


                    function baseToPairs(object, props) {
                        return arrayMap(props, function(key) {
                            return [key, object[key]];
                        });
                    }


                    function baseUnary(func) {
                        return function(value) {
                            return func(value);
                        };
                    }


                    function baseValues(object, props) {
                        return arrayMap(props, function(key) {
                            return object[key];
                        });
                    }


                    function cacheHas(cache, key) {
                        return cache.has(key);
                    }


                    function charsStartIndex(strSymbols, chrSymbols) {
                        var index = -1,
                            length = strSymbols.length;

                        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                        return index;
                    }


                    function charsEndIndex(strSymbols, chrSymbols) {
                        var index = strSymbols.length;

                        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                        return index;
                    }


                    function countHolders(array, placeholder) {
                        var length = array.length,
                            result = 0;

                        while (length--) {
                            if (array[length] === placeholder) {
                                ++result;
                            }
                        }
                        return result;
                    }


                    var deburrLetter = basePropertyOf(deburredLetters);


                    var escapeHtmlChar = basePropertyOf(htmlEscapes);


                    function escapeStringChar(chr) {
                        return '\\' + stringEscapes[chr];
                    }


                    function getValue(object, key) {
                        return object == null ? undefined : object[key];
                    }


                    function hasUnicode(string) {
                        return reHasUnicode.test(string);
                    }


                    function hasUnicodeWord(string) {
                        return reHasUnicodeWord.test(string);
                    }


                    function iteratorToArray(iterator) {
                        var data,
                            result = [];

                        while (!(data = iterator.next()).done) {
                            result.push(data.value);
                        }
                        return result;
                    }


                    function mapToArray(map) {
                        var index = -1,
                            result = Array(map.size);

                        map.forEach(function(value, key) {
                            result[++index] = [key, value];
                        });
                        return result;
                    }


                    function overArg(func, transform) {
                        return function(arg) {
                            return func(transform(arg));
                        };
                    }


                    function replaceHolders(array, placeholder) {
                        var index = -1,
                            length = array.length,
                            resIndex = 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (value === placeholder || value === PLACEHOLDER) {
                                array[index] = PLACEHOLDER;
                                result[resIndex++] = index;
                            }
                        }
                        return result;
                    }


                    function setToArray(set) {
                        var index = -1,
                            result = Array(set.size);

                        set.forEach(function(value) {
                            result[++index] = value;
                        });
                        return result;
                    }


                    function setToPairs(set) {
                        var index = -1,
                            result = Array(set.size);

                        set.forEach(function(value) {
                            result[++index] = [value, value];
                        });
                        return result;
                    }


                    function strictIndexOf(array, value, fromIndex) {
                        var index = fromIndex - 1,
                            length = array.length;

                        while (++index < length) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }


                    function strictLastIndexOf(array, value, fromIndex) {
                        var index = fromIndex + 1;
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return index;
                    }


                    function stringSize(string) {
                        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
                    }


                    function stringToArray(string) {
                        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
                    }


                    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);


                    function unicodeSize(string) {
                        var result = reUnicode.lastIndex = 0;
                        while (reUnicode.test(string)) {
                            ++result;
                        }
                        return result;
                    }


                    function unicodeToArray(string) {
                        return string.match(reUnicode) || [];
                    }


                    function unicodeWords(string) {
                        return string.match(reUnicodeWord) || [];
                    }




                    var runInContext = (function runInContext(context) {
                        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));


                        var Array = context.Array,
                            Date = context.Date,
                            Error = context.Error,
                            Function = context.Function,
                            Math = context.Math,
                            Object = context.Object,
                            RegExp = context.RegExp,
                            String = context.String,
                            TypeError = context.TypeError;


                        var arrayProto = Array.prototype,
                            funcProto = Function.prototype,
                            objectProto = Object.prototype;


                        var coreJsData = context['__core-js_shared__'];


                        var funcToString = funcProto.toString;


                        var hasOwnProperty = objectProto.hasOwnProperty;


                        var idCounter = 0;


                        var maskSrcKey = (function() {
                            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                            return uid ? ('Symbol(src)_1.' + uid) : '';
                        }());


                        var nativeObjectToString = objectProto.toString;


                        var objectCtorString = funcToString.call(Object);


                        var oldDash = root._;


                        var reIsNative = RegExp('^' +
                            funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
                            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                        );


                        var Buffer = moduleExports ? context.Buffer : undefined,
                            Symbol = context.Symbol,
                            Uint8Array = context.Uint8Array,
                            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
                            getPrototype = overArg(Object.getPrototypeOf, Object),
                            objectCreate = Object.create,
                            propertyIsEnumerable = objectProto.propertyIsEnumerable,
                            splice = arrayProto.splice,
                            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
                            symIterator = Symbol ? Symbol.iterator : undefined,
                            symToStringTag = Symbol ? Symbol.toStringTag : undefined;

                        var defineProperty = (function() {
                            try {
                                var func = getNative(Object, 'defineProperty');
                                func({}, '', {});
                                return func;
                            } catch (e) {}
                        }());


                        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
                            ctxNow = Date && Date.now !== root.Date.now && Date.now,
                            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;


                        var nativeCeil = Math.ceil,
                            nativeFloor = Math.floor,
                            nativeGetSymbols = Object.getOwnPropertySymbols,
                            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
                            nativeIsFinite = context.isFinite,
                            nativeJoin = arrayProto.join,
                            nativeKeys = overArg(Object.keys, Object),
                            nativeMax = Math.max,
                            nativeMin = Math.min,
                            nativeNow = Date.now,
                            nativeParseInt = context.parseInt,
                            nativeRandom = Math.random,
                            nativeReverse = arrayProto.reverse;


                        var DataView = getNative(context, 'DataView'),
                            Map = getNative(context, 'Map'),
                            Promise = getNative(context, 'Promise'),
                            Set = getNative(context, 'Set'),
                            WeakMap = getNative(context, 'WeakMap'),
                            nativeCreate = getNative(Object, 'create');


                        var metaMap = WeakMap && new WeakMap;


                        var realNames = {};


                        var dataViewCtorString = toSource(DataView),
                            mapCtorString = toSource(Map),
                            promiseCtorString = toSource(Promise),
                            setCtorString = toSource(Set),
                            weakMapCtorString = toSource(WeakMap);


                        var symbolProto = Symbol ? Symbol.prototype : undefined,
                            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                            symbolToString = symbolProto ? symbolProto.toString : undefined;




                        function lodash(value) {
                            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                                if (value instanceof LodashWrapper) {
                                    return value;
                                }
                                if (hasOwnProperty.call(value, '__wrapped__')) {
                                    return wrapperClone(value);
                                }
                            }
                            return new LodashWrapper(value);
                        }


                        var baseCreate = (function() {
                            function object() {}
                            return function(proto) {
                                if (!isObject(proto)) {
                                    return {};
                                }
                                if (objectCreate) {
                                    return objectCreate(proto);
                                }
                                object.prototype = proto;
                                var result = new object;
                                object.prototype = undefined;
                                return result;
                            };
                        }());


                        function baseLodash() {
                            // No operation performed.
                        }


                        function LodashWrapper(value, chainAll) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__chain__ = !!chainAll;
                            this.__index__ = 0;
                            this.__values__ = undefined;
                        }


                        lodash.templateSettings = {


                            'escape': reEscape,


                            'evaluate': reEvaluate,


                            'interpolate': reInterpolate,


                            'variable': '',


                            'imports': {


                                '_': lodash
                            }
                        };

                        // Ensure wrappers are instances of `baseLodash`.
                        lodash.prototype = baseLodash.prototype;
                        lodash.prototype.constructor = lodash;

                        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                        LodashWrapper.prototype.constructor = LodashWrapper;




                        function LazyWrapper(value) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__dir__ = 1;
                            this.__filtered__ = false;
                            this.__iteratees__ = [];
                            this.__takeCount__ = MAX_ARRAY_LENGTH;
                            this.__views__ = [];
                        }


                        function lazyClone() {
                            var result = new LazyWrapper(this.__wrapped__);
                            result.__actions__ = copyArray(this.__actions__);
                            result.__dir__ = this.__dir__;
                            result.__filtered__ = this.__filtered__;
                            result.__iteratees__ = copyArray(this.__iteratees__);
                            result.__takeCount__ = this.__takeCount__;
                            result.__views__ = copyArray(this.__views__);
                            return result;
                        }


                        function lazyReverse() {
                            if (this.__filtered__) {
                                var result = new LazyWrapper(this);
                                result.__dir__ = -1;
                                result.__filtered__ = true;
                            } else {
                                result = this.clone();
                                result.__dir__ *= -1;
                            }
                            return result;
                        }


                        function lazyValue() {
                            var array = this.__wrapped__.value(),
                                dir = this.__dir__,
                                isArr = isArray(array),
                                isRight = dir < 0,
                                arrLength = isArr ? array.length : 0,
                                view = getView(0, arrLength, this.__views__),
                                start = view.start,
                                end = view.end,
                                length = end - start,
                                index = isRight ? end : (start - 1),
                                iteratees = this.__iteratees__,
                                iterLength = iteratees.length,
                                resIndex = 0,
                                takeCount = nativeMin(length, this.__takeCount__);

                            if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
                                (arrLength == length && takeCount == length)) {
                                return baseWrapperValue(array, this.__actions__);
                            }
                            var result = [];

                            outer:
                                while (length-- && resIndex < takeCount) {
                                    index += dir;

                                    var iterIndex = -1,
                                        value = array[index];

                                    while (++iterIndex < iterLength) {
                                        var data = iteratees[iterIndex],
                                            iteratee = data.iteratee,
                                            type = data.type,
                                            computed = iteratee(value);

                                        if (type == LAZY_MAP_FLAG) {
                                            value = computed;
                                        } else if (!computed) {
                                            if (type == LAZY_FILTER_FLAG) {
                                                continue outer;
                                            } else {
                                                break outer;
                                            }
                                        }
                                    }
                                    result[resIndex++] = value;
                                }
                            return result;
                        }

                        // Ensure `LazyWrapper` is an instance of `baseLodash`.
                        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                        LazyWrapper.prototype.constructor = LazyWrapper;




                        function Hash(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;

                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }


                        function hashClear() {
                            this.__data__ = nativeCreate ? nativeCreate(null) : {};
                            this.size = 0;
                        }


                        function hashDelete(key) {
                            var result = this.has(key) && delete this.__data__[key];
                            this.size -= result ? 1 : 0;
                            return result;
                        }


                        function hashGet(key) {
                            var data = this.__data__;
                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED ? undefined : result;
                            }
                            return hasOwnProperty.call(data, key) ? data[key] : undefined;
                        }


                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
                        }


                        function hashSet(key, value) {
                            var data = this.__data__;
                            this.size += this.has(key) ? 0 : 1;
                            data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
                            return this;
                        }

                        // Add methods to `Hash`.
                        Hash.prototype.clear = hashClear;
                        Hash.prototype['delete'] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;




                        function ListCache(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;

                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }


                        function listCacheClear() {
                            this.__data__ = [];
                            this.size = 0;
                        }


                        function listCacheDelete(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                return false;
                            }
                            var lastIndex = data.length - 1;
                            if (index == lastIndex) {
                                data.pop();
                            } else {
                                splice.call(data, index, 1);
                            }
                            --this.size;
                            return true;
                        }


                        function listCacheGet(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            return index < 0 ? undefined : data[index][1];
                        }


                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1;
                        }


                        function listCacheSet(key, value) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                ++this.size;
                                data.push([key, value]);
                            } else {
                                data[index][1] = value;
                            }
                            return this;
                        }

                        // Add methods to `ListCache`.
                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype['delete'] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;




                        function MapCache(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;

                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }


                        function mapCacheClear() {
                            this.size = 0;
                            this.__data__ = {
                                'hash': new Hash,
                                'map': new(Map || ListCache),
                                'string': new Hash
                            };
                        }


                        function mapCacheDelete(key) {
                            var result = getMapData(this, key)['delete'](key);
                            this.size -= result ? 1 : 0;
                            return result;
                        }


                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key);
                        }


                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key);
                        }


                        function mapCacheSet(key, value) {
                            var data = getMapData(this, key),
                                size = data.size;

                            data.set(key, value);
                            this.size += data.size == size ? 0 : 1;
                            return this;
                        }

                        // Add methods to `MapCache`.
                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype['delete'] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;




                        function SetCache(values) {
                            var index = -1,
                                length = values == null ? 0 : values.length;

                            this.__data__ = new MapCache;
                            while (++index < length) {
                                this.add(values[index]);
                            }
                        }


                        function setCacheAdd(value) {
                            this.__data__.set(value, HASH_UNDEFINED);
                            return this;
                        }


                        function setCacheHas(value) {
                            return this.__data__.has(value);
                        }

                        // Add methods to `SetCache`.
                        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                        SetCache.prototype.has = setCacheHas;




                        function Stack(entries) {
                            var data = this.__data__ = new ListCache(entries);
                            this.size = data.size;
                        }


                        function stackClear() {
                            this.__data__ = new ListCache;
                            this.size = 0;
                        }


                        function stackDelete(key) {
                            var data = this.__data__,
                                result = data['delete'](key);

                            this.size = data.size;
                            return result;
                        }


                        function stackGet(key) {
                            return this.__data__.get(key);
                        }


                        function stackHas(key) {
                            return this.__data__.has(key);
                        }


                        function stackSet(key, value) {
                            var data = this.__data__;
                            if (data instanceof ListCache) {
                                var pairs = data.__data__;
                                if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                                    pairs.push([key, value]);
                                    this.size = ++data.size;
                                    return this;
                                }
                                data = this.__data__ = new MapCache(pairs);
                            }
                            data.set(key, value);
                            this.size = data.size;
                            return this;
                        }

                        // Add methods to `Stack`.
                        Stack.prototype.clear = stackClear;
                        Stack.prototype['delete'] = stackDelete;
                        Stack.prototype.get = stackGet;
                        Stack.prototype.has = stackHas;
                        Stack.prototype.set = stackSet;




                        function arrayLikeKeys(value, inherited) {
                            var isArr = isArray(value),
                                isArg = !isArr && isArguments(value),
                                isBuff = !isArr && !isArg && isBuffer(value),
                                isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                                skipIndexes = isArr || isArg || isBuff || isType,
                                result = skipIndexes ? baseTimes(value.length, String) : [],
                                length = result.length;

                            for (var key in value) {
                                if ((inherited || hasOwnProperty.call(value, key)) &&
                                    !(skipIndexes && (
                                        // Safari 9 has enumerable `arguments.length` in strict mode.
                                        key == 'length' ||
                                        // Node.js 0.10 has enumerable non-index properties on buffers.
                                        (isBuff && (key == 'offset' || key == 'parent')) ||
                                        // PhantomJS 2 has enumerable non-index properties on typed arrays.
                                        (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                                        // Skip index properties.
                                        isIndex(key, length)
                                    ))) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }


                        function arraySample(array) {
                            var length = array.length;
                            return length ? array[baseRandom(0, length - 1)] : undefined;
                        }


                        function arraySampleSize(array, n) {
                            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                        }


                        function arrayShuffle(array) {
                            return shuffleSelf(copyArray(array));
                        }


                        function assignInDefaults(objValue, srcValue, key, object) {
                            if (objValue === undefined ||
                                (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                                return srcValue;
                            }
                            return objValue;
                        }


                        function assignMergeValue(object, key, value) {
                            if ((value !== undefined && !eq(object[key], value)) ||
                                (value === undefined && !(key in object))) {
                                baseAssignValue(object, key, value);
                            }
                        }


                        function assignValue(object, key, value) {
                            var objValue = object[key];
                            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                                (value === undefined && !(key in object))) {
                                baseAssignValue(object, key, value);
                            }
                        }


                        function assocIndexOf(array, key) {
                            var length = array.length;
                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length;
                                }
                            }
                            return -1;
                        }


                        function baseAggregator(collection, setter, iteratee, accumulator) {
                            baseEach(collection, function(value, key, collection) {
                                setter(accumulator, value, iteratee(value), collection);
                            });
                            return accumulator;
                        }


                        function baseAssign(object, source) {
                            return object && copyObject(source, keys(source), object);
                        }


                        function baseAssignIn(object, source) {
                            return object && copyObject(source, keysIn(source), object);
                        }


                        function baseAssignValue(object, key, value) {
                            if (key == '__proto__' && defineProperty) {
                                defineProperty(object, key, {
                                    'configurable': true,
                                    'enumerable': true,
                                    'value': value,
                                    'writable': true
                                });
                            } else {
                                object[key] = value;
                            }
                        }


                        function baseAt(object, paths) {
                            var index = -1,
                                length = paths.length,
                                result = Array(length),
                                skip = object == null;

                            while (++index < length) {
                                result[index] = skip ? undefined : get(object, paths[index]);
                            }
                            return result;
                        }


                        function baseClamp(number, lower, upper) {
                            if (number === number) {
                                if (upper !== undefined) {
                                    number = number <= upper ? number : upper;
                                }
                                if (lower !== undefined) {
                                    number = number >= lower ? number : lower;
                                }
                            }
                            return number;
                        }


                        function baseClone(value, bitmask, customizer, key, object, stack) {
                            var result,
                                isDeep = bitmask & CLONE_DEEP_FLAG,
                                isFlat = bitmask & CLONE_FLAT_FLAG,
                                isFull = bitmask & CLONE_SYMBOLS_FLAG;

                            if (customizer) {
                                result = object ? customizer(value, key, object, stack) : customizer(value);
                            }
                            if (result !== undefined) {
                                return result;
                            }
                            if (!isObject(value)) {
                                return value;
                            }
                            var isArr = isArray(value);
                            if (isArr) {
                                result = initCloneArray(value);
                                if (!isDeep) {
                                    return copyArray(value, result);
                                }
                            } else {
                                var tag = getTag(value),
                                    isFunc = tag == funcTag || tag == genTag;

                                if (isBuffer(value)) {
                                    return cloneBuffer(value, isDeep);
                                }
                                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                    result = (isFlat || isFunc) ? {} : initCloneObject(value);
                                    if (!isDeep) {
                                        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                                    }
                                } else {
                                    if (!cloneableTags[tag]) {
                                        return object ? value : {};
                                    }
                                    result = initCloneByTag(value, tag, baseClone, isDeep);
                                }
                            }
                            // Check for circular references and return its corresponding clone.
                            stack || (stack = new Stack);
                            var stacked = stack.get(value);
                            if (stacked) {
                                return stacked;
                            }
                            stack.set(value, result);

                            var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys);

                            var props = isArr ? undefined : keysFunc(value);
                            arrayEach(props || value, function(subValue, key) {
                                if (props) {
                                    key = subValue;
                                    subValue = value[key];
                                }
                                // Recursively populate clone (susceptible to call stack limits).
                                assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                            });
                            return result;
                        }


                        function baseConforms(source) {
                            var props = keys(source);
                            return function(object) {
                                return baseConformsTo(object, source, props);
                            };
                        }


                        function baseConformsTo(object, source, props) {
                            var length = props.length;
                            if (object == null) {
                                return !length;
                            }
                            object = Object(object);
                            while (length--) {
                                var key = props[length],
                                    predicate = source[key],
                                    value = object[key];

                                if ((value === undefined && !(key in object)) || !predicate(value)) {
                                    return false;
                                }
                            }
                            return true;
                        }


                        function baseDelay(func, wait, args) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return setTimeout(function() {
                                func.apply(undefined, args);
                            }, wait);
                        }


                        function baseDifference(array, values, iteratee, comparator) {
                            var index = -1,
                                includes = arrayIncludes,
                                isCommon = true,
                                length = array.length,
                                result = [],
                                valuesLength = values.length;

                            if (!length) {
                                return result;
                            }
                            if (iteratee) {
                                values = arrayMap(values, baseUnary(iteratee));
                            }
                            if (comparator) {
                                includes = arrayIncludesWith;
                                isCommon = false;
                            } else if (values.length >= LARGE_ARRAY_SIZE) {
                                includes = cacheHas;
                                isCommon = false;
                                values = new SetCache(values);
                            }
                            outer:
                                while (++index < length) {
                                    var value = array[index],
                                        computed = iteratee == null ? value : iteratee(value);

                                    value = (comparator || value !== 0) ? value : 0;
                                    if (isCommon && computed === computed) {
                                        var valuesIndex = valuesLength;
                                        while (valuesIndex--) {
                                            if (values[valuesIndex] === computed) {
                                                continue outer;
                                            }
                                        }
                                        result.push(value);
                                    } else if (!includes(values, computed, comparator)) {
                                        result.push(value);
                                    }
                                }
                            return result;
                        }


                        var baseEach = createBaseEach(baseForOwn);


                        var baseEachRight = createBaseEach(baseForOwnRight, true);


                        function baseEvery(collection, predicate) {
                            var result = true;
                            baseEach(collection, function(value, index, collection) {
                                result = !!predicate(value, index, collection);
                                return result;
                            });
                            return result;
                        }


                        function baseExtremum(array, iteratee, comparator) {
                            var index = -1,
                                length = array.length;

                            while (++index < length) {
                                var value = array[index],
                                    current = iteratee(value);

                                if (current != null && (computed === undefined ? (current === current && !isSymbol(current)) : comparator(current, computed))) {
                                    var computed = current,
                                        result = value;
                                }
                            }
                            return result;
                        }


                        function baseFill(array, value, start, end) {
                            var length = array.length;

                            start = toInteger(start);
                            if (start < 0) {
                                start = -start > length ? 0 : (length + start);
                            }
                            end = (end === undefined || end > length) ? length : toInteger(end);
                            if (end < 0) {
                                end += length;
                            }
                            end = start > end ? 0 : toLength(end);
                            while (start < end) {
                                array[start++] = value;
                            }
                            return array;
                        }


                        function baseFilter(collection, predicate) {
                            var result = [];
                            baseEach(collection, function(value, index, collection) {
                                if (predicate(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                            return result;
                        }


                        function baseFlatten(array, depth, predicate, isStrict, result) {
                            var index = -1,
                                length = array.length;

                            predicate || (predicate = isFlattenable);
                            result || (result = []);

                            while (++index < length) {
                                var value = array[index];
                                if (depth > 0 && predicate(value)) {
                                    if (depth > 1) {
                                        // Recursively flatten arrays (susceptible to call stack limits).
                                        baseFlatten(value, depth - 1, predicate, isStrict, result);
                                    } else {
                                        arrayPush(result, value);
                                    }
                                } else if (!isStrict) {
                                    result[result.length] = value;
                                }
                            }
                            return result;
                        }


                        var baseFor = createBaseFor();


                        var baseForRight = createBaseFor(true);


                        function baseForOwn(object, iteratee) {
                            return object && baseFor(object, iteratee, keys);
                        }


                        function baseForOwnRight(object, iteratee) {
                            return object && baseForRight(object, iteratee, keys);
                        }


                        function baseFunctions(object, props) {
                            return arrayFilter(props, function(key) {
                                return isFunction(object[key]);
                            });
                        }


                        function baseGet(object, path) {
                            path = castPath(path, object);

                            var index = 0,
                                length = path.length;

                            while (object != null && index < length) {
                                object = object[toKey(path[index++])];
                            }
                            return (index && index == length) ? object : undefined;
                        }


                        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                            var result = keysFunc(object);
                            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                        }


                        function baseGetTag(value) {
                            if (value == null) {
                                return value === undefined ? undefinedTag : nullTag;
                            }
                            value = Object(value);
                            return (symToStringTag && symToStringTag in value) ? getRawTag(value) : objectToString(value);
                        }


                        function baseGt(value, other) {
                            return value > other;
                        }


                        function baseHas(object, key) {
                            return object != null && hasOwnProperty.call(object, key);
                        }


                        function baseHasIn(object, key) {
                            return object != null && key in Object(object);
                        }


                        function baseInRange(number, start, end) {
                            return number >= nativeMin(start, end) && number < nativeMax(start, end);
                        }


                        function baseIntersection(arrays, iteratee, comparator) {
                            var includes = comparator ? arrayIncludesWith : arrayIncludes,
                                length = arrays[0].length,
                                othLength = arrays.length,
                                othIndex = othLength,
                                caches = Array(othLength),
                                maxLength = Infinity,
                                result = [];

                            while (othIndex--) {
                                var array = arrays[othIndex];
                                if (othIndex && iteratee) {
                                    array = arrayMap(array, baseUnary(iteratee));
                                }
                                maxLength = nativeMin(array.length, maxLength);
                                caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120)) ? new SetCache(othIndex && array) : undefined;
                            }
                            array = arrays[0];

                            var index = -1,
                                seen = caches[0];

                            outer:
                                while (++index < length && result.length < maxLength) {
                                    var value = array[index],
                                        computed = iteratee ? iteratee(value) : value;

                                    value = (comparator || value !== 0) ? value : 0;
                                    if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                                        othIndex = othLength;
                                        while (--othIndex) {
                                            var cache = caches[othIndex];
                                            if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                                                continue outer;
                                            }
                                        }
                                        if (seen) {
                                            seen.push(computed);
                                        }
                                        result.push(value);
                                    }
                                }
                            return result;
                        }


                        function baseInverter(object, setter, iteratee, accumulator) {
                            baseForOwn(object, function(value, key, object) {
                                setter(accumulator, iteratee(value), key, object);
                            });
                            return accumulator;
                        }


                        function baseInvoke(object, path, args) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            var func = object == null ? object : object[toKey(last(path))];
                            return func == null ? undefined : apply(func, object, args);
                        }


                        function baseIsArguments(value) {
                            return isObjectLike(value) && baseGetTag(value) == argsTag;
                        }


                        function baseIsArrayBuffer(value) {
                            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                        }


                        function baseIsDate(value) {
                            return isObjectLike(value) && baseGetTag(value) == dateTag;
                        }


                        function baseIsEqual(value, other, bitmask, customizer, stack) {
                            if (value === other) {
                                return true;
                            }
                            if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                                return value !== value && other !== other;
                            }
                            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                        }


                        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                            var objIsArr = isArray(object),
                                othIsArr = isArray(other),
                                objTag = arrayTag,
                                othTag = arrayTag;

                            if (!objIsArr) {
                                objTag = getTag(object);
                                objTag = objTag == argsTag ? objectTag : objTag;
                            }
                            if (!othIsArr) {
                                othTag = getTag(other);
                                othTag = othTag == argsTag ? objectTag : othTag;
                            }
                            var objIsObj = objTag == objectTag,
                                othIsObj = othTag == objectTag,
                                isSameTag = objTag == othTag;

                            if (isSameTag && isBuffer(object)) {
                                if (!isBuffer(other)) {
                                    return false;
                                }
                                objIsArr = true;
                                objIsObj = false;
                            }
                            if (isSameTag && !objIsObj) {
                                stack || (stack = new Stack);
                                return (objIsArr || isTypedArray(object)) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                            }
                            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                                    othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                                if (objIsWrapped || othIsWrapped) {
                                    var objUnwrapped = objIsWrapped ? object.value() : object,
                                        othUnwrapped = othIsWrapped ? other.value() : other;

                                    stack || (stack = new Stack);
                                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                                }
                            }
                            if (!isSameTag) {
                                return false;
                            }
                            stack || (stack = new Stack);
                            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                        }


                        function baseIsMap(value) {
                            return isObjectLike(value) && getTag(value) == mapTag;
                        }


                        function baseIsMatch(object, source, matchData, customizer) {
                            var index = matchData.length,
                                length = index,
                                noCustomizer = !customizer;

                            if (object == null) {
                                return !length;
                            }
                            object = Object(object);
                            while (index--) {
                                var data = matchData[index];
                                if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
                                    return false;
                                }
                            }
                            while (++index < length) {
                                data = matchData[index];
                                var key = data[0],
                                    objValue = object[key],
                                    srcValue = data[1];

                                if (noCustomizer && data[2]) {
                                    if (objValue === undefined && !(key in object)) {
                                        return false;
                                    }
                                } else {
                                    var stack = new Stack;
                                    if (customizer) {
                                        var result = customizer(objValue, srcValue, key, object, source, stack);
                                    }
                                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }


                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }
                            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }


                        function baseIsRegExp(value) {
                            return isObjectLike(value) && baseGetTag(value) == regexpTag;
                        }


                        function baseIsSet(value) {
                            return isObjectLike(value) && getTag(value) == setTag;
                        }


                        function baseIsTypedArray(value) {
                            return isObjectLike(value) &&
                                isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                        }


                        function baseIteratee(value) {
                            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                            if (typeof value == 'function') {
                                return value;
                            }
                            if (value == null) {
                                return identity;
                            }
                            if (typeof value == 'object') {
                                return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                            }
                            return property(value);
                        }


                        function baseKeys(object) {
                            if (!isPrototype(object)) {
                                return nativeKeys(object);
                            }
                            var result = [];
                            for (var key in Object(object)) {
                                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                                    result.push(key);
                                }
                            }
                            return result;
                        }


                        function baseKeysIn(object) {
                            if (!isObject(object)) {
                                return nativeKeysIn(object);
                            }
                            var isProto = isPrototype(object),
                                result = [];

                            for (var key in object) {
                                if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }


                        function baseLt(value, other) {
                            return value < other;
                        }


                        function baseMap(collection, iteratee) {
                            var index = -1,
                                result = isArrayLike(collection) ? Array(collection.length) : [];

                            baseEach(collection, function(value, key, collection) {
                                result[++index] = iteratee(value, key, collection);
                            });
                            return result;
                        }


                        function baseMatches(source) {
                            var matchData = getMatchData(source);
                            if (matchData.length == 1 && matchData[0][2]) {
                                return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                            }
                            return function(object) {
                                return object === source || baseIsMatch(object, source, matchData);
                            };
                        }


                        function baseMatchesProperty(path, srcValue) {
                            if (isKey(path) && isStrictComparable(srcValue)) {
                                return matchesStrictComparable(toKey(path), srcValue);
                            }
                            return function(object) {
                                var objValue = get(object, path);
                                return (objValue === undefined && objValue === srcValue) ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                            };
                        }


                        function baseMerge(object, source, srcIndex, customizer, stack) {
                            if (object === source) {
                                return;
                            }
                            baseFor(source, function(srcValue, key) {
                                if (isObject(srcValue)) {
                                    stack || (stack = new Stack);
                                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                                } else {
                                    var newValue = customizer ? customizer(object[key], srcValue, (key + ''), object, source, stack) : undefined;

                                    if (newValue === undefined) {
                                        newValue = srcValue;
                                    }
                                    assignMergeValue(object, key, newValue);
                                }
                            }, keysIn);
                        }


                        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                            var objValue = object[key],
                                srcValue = source[key],
                                stacked = stack.get(srcValue);

                            if (stacked) {
                                assignMergeValue(object, key, stacked);
                                return;
                            }
                            var newValue = customizer ? customizer(objValue, srcValue, (key + ''), object, source, stack) : undefined;

                            var isCommon = newValue === undefined;

                            if (isCommon) {
                                var isArr = isArray(srcValue),
                                    isBuff = !isArr && isBuffer(srcValue),
                                    isTyped = !isArr && !isBuff && isTypedArray(srcValue);

                                newValue = srcValue;
                                if (isArr || isBuff || isTyped) {
                                    if (isArray(objValue)) {
                                        newValue = objValue;
                                    } else if (isArrayLikeObject(objValue)) {
                                        newValue = copyArray(objValue);
                                    } else if (isBuff) {
                                        isCommon = false;
                                        newValue = cloneBuffer(srcValue, true);
                                    } else if (isTyped) {
                                        isCommon = false;
                                        newValue = cloneTypedArray(srcValue, true);
                                    } else {
                                        newValue = [];
                                    }
                                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                    newValue = objValue;
                                    if (isArguments(objValue)) {
                                        newValue = toPlainObject(objValue);
                                    } else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
                                        newValue = initCloneObject(srcValue);
                                    }
                                } else {
                                    isCommon = false;
                                }
                            }
                            if (isCommon) {
                                // Recursively merge objects and arrays (susceptible to call stack limits).
                                stack.set(srcValue, newValue);
                                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                                stack['delete'](srcValue);
                            }
                            assignMergeValue(object, key, newValue);
                        }


                        function baseNth(array, n) {
                            var length = array.length;
                            if (!length) {
                                return;
                            }
                            n += n < 0 ? length : 0;
                            return isIndex(n, length) ? array[n] : undefined;
                        }


                        function baseOrderBy(collection, iteratees, orders) {
                            var index = -1;
                            iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

                            var result = baseMap(collection, function(value, key, collection) {
                                var criteria = arrayMap(iteratees, function(iteratee) {
                                    return iteratee(value);
                                });
                                return {
                                    'criteria': criteria,
                                    'index': ++index,
                                    'value': value
                                };
                            });

                            return baseSortBy(result, function(object, other) {
                                return compareMultiple(object, other, orders);
                            });
                        }


                        function basePick(object, paths) {
                            object = Object(object);
                            return basePickBy(object, paths, function(value, path) {
                                return hasIn(object, path);
                            });
                        }


                        function basePickBy(object, paths, predicate) {
                            var index = -1,
                                length = paths.length,
                                result = {};

                            while (++index < length) {
                                var path = paths[index],
                                    value = baseGet(object, path);

                                if (predicate(value, path)) {
                                    baseSet(result, castPath(path, object), value);
                                }
                            }
                            return result;
                        }


                        function basePropertyDeep(path) {
                            return function(object) {
                                return baseGet(object, path);
                            };
                        }


                        function basePullAll(array, values, iteratee, comparator) {
                            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                                index = -1,
                                length = values.length,
                                seen = array;

                            if (array === values) {
                                values = copyArray(values);
                            }
                            if (iteratee) {
                                seen = arrayMap(array, baseUnary(iteratee));
                            }
                            while (++index < length) {
                                var fromIndex = 0,
                                    value = values[index],
                                    computed = iteratee ? iteratee(value) : value;

                                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                                    if (seen !== array) {
                                        splice.call(seen, fromIndex, 1);
                                    }
                                    splice.call(array, fromIndex, 1);
                                }
                            }
                            return array;
                        }


                        function basePullAt(array, indexes) {
                            var length = array ? indexes.length : 0,
                                lastIndex = length - 1;

                            while (length--) {
                                var index = indexes[length];
                                if (length == lastIndex || index !== previous) {
                                    var previous = index;
                                    if (isIndex(index)) {
                                        splice.call(array, index, 1);
                                    } else {
                                        baseUnset(array, index);
                                    }
                                }
                            }
                            return array;
                        }


                        function baseRandom(lower, upper) {
                            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                        }


                        function baseRange(start, end, step, fromRight) {
                            var index = -1,
                                length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                                result = Array(length);

                            while (length--) {
                                result[fromRight ? length : ++index] = start;
                                start += step;
                            }
                            return result;
                        }


                        function baseRepeat(string, n) {
                            var result = '';
                            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                                return result;
                            }
                            // Leverage the exponentiation by squaring algorithm for a faster repeat.
                            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                            do {
                                if (n % 2) {
                                    result += string;
                                }
                                n = nativeFloor(n / 2);
                                if (n) {
                                    string += string;
                                }
                            } while (n);

                            return result;
                        }


                        function baseRest(func, start) {
                            return setToString(overRest(func, start, identity), func + '');
                        }


                        function baseSample(collection) {
                            return arraySample(values(collection));
                        }


                        function baseSampleSize(collection, n) {
                            var array = values(collection);
                            return shuffleSelf(array, baseClamp(n, 0, array.length));
                        }


                        function baseSet(object, path, value, customizer) {
                            if (!isObject(object)) {
                                return object;
                            }
                            path = castPath(path, object);

                            var index = -1,
                                length = path.length,
                                lastIndex = length - 1,
                                nested = object;

                            while (nested != null && ++index < length) {
                                var key = toKey(path[index]),
                                    newValue = value;

                                if (index != lastIndex) {
                                    var objValue = nested[key];
                                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                                    if (newValue === undefined) {
                                        newValue = isObject(objValue) ? objValue : (isIndex(path[index + 1]) ? [] : {});
                                    }
                                }
                                assignValue(nested, key, newValue);
                                nested = nested[key];
                            }
                            return object;
                        }


                        var baseSetData = !metaMap ? identity : function(func, data) {
                            metaMap.set(func, data);
                            return func;
                        };


                        var baseSetToString = !defineProperty ? identity : function(func, string) {
                            return defineProperty(func, 'toString', {
                                'configurable': true,
                                'enumerable': false,
                                'value': constant(string),
                                'writable': true
                            });
                        };


                        function baseShuffle(collection) {
                            return shuffleSelf(values(collection));
                        }


                        function baseSlice(array, start, end) {
                            var index = -1,
                                length = array.length;

                            if (start < 0) {
                                start = -start > length ? 0 : (length + start);
                            }
                            end = end > length ? length : end;
                            if (end < 0) {
                                end += length;
                            }
                            length = start > end ? 0 : ((end - start) >>> 0);
                            start >>>= 0;

                            var result = Array(length);
                            while (++index < length) {
                                result[index] = array[index + start];
                            }
                            return result;
                        }


                        function baseSome(collection, predicate) {
                            var result;

                            baseEach(collection, function(value, index, collection) {
                                result = predicate(value, index, collection);
                                return !result;
                            });
                            return !!result;
                        }


                        function baseSortedIndex(array, value, retHighest) {
                            var low = 0,
                                high = array == null ? low : array.length;

                            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                                while (low < high) {
                                    var mid = (low + high) >>> 1,
                                        computed = array[mid];

                                    if (computed !== null && !isSymbol(computed) &&
                                        (retHighest ? (computed <= value) : (computed < value))) {
                                        low = mid + 1;
                                    } else {
                                        high = mid;
                                    }
                                }
                                return high;
                            }
                            return baseSortedIndexBy(array, value, identity, retHighest);
                        }


                        function baseSortedIndexBy(array, value, iteratee, retHighest) {
                            value = iteratee(value);

                            var low = 0,
                                high = array == null ? 0 : array.length,
                                valIsNaN = value !== value,
                                valIsNull = value === null,
                                valIsSymbol = isSymbol(value),
                                valIsUndefined = value === undefined;

                            while (low < high) {
                                var mid = nativeFloor((low + high) / 2),
                                    computed = iteratee(array[mid]),
                                    othIsDefined = computed !== undefined,
                                    othIsNull = computed === null,
                                    othIsReflexive = computed === computed,
                                    othIsSymbol = isSymbol(computed);

                                if (valIsNaN) {
                                    var setLow = retHighest || othIsReflexive;
                                } else if (valIsUndefined) {
                                    setLow = othIsReflexive && (retHighest || othIsDefined);
                                } else if (valIsNull) {
                                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                                } else if (valIsSymbol) {
                                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                                } else if (othIsNull || othIsSymbol) {
                                    setLow = false;
                                } else {
                                    setLow = retHighest ? (computed <= value) : (computed < value);
                                }
                                if (setLow) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return nativeMin(high, MAX_ARRAY_INDEX);
                        }


                        function baseSortedUniq(array, iteratee) {
                            var index = -1,
                                length = array.length,
                                resIndex = 0,
                                result = [];

                            while (++index < length) {
                                var value = array[index],
                                    computed = iteratee ? iteratee(value) : value;

                                if (!index || !eq(computed, seen)) {
                                    var seen = computed;
                                    result[resIndex++] = value === 0 ? 0 : value;
                                }
                            }
                            return result;
                        }


                        function baseToNumber(value) {
                            if (typeof value == 'number') {
                                return value;
                            }
                            if (isSymbol(value)) {
                                return NAN;
                            }
                            return +value;
                        }


                        function baseToString(value) {
                            // Exit early for strings to avoid a performance hit in some environments.
                            if (typeof value == 'string') {
                                return value;
                            }
                            if (isArray(value)) {
                                // Recursively convert values (susceptible to call stack limits).
                                return arrayMap(value, baseToString) + '';
                            }
                            if (isSymbol(value)) {
                                return symbolToString ? symbolToString.call(value) : '';
                            }
                            var result = (value + '');
                            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                        }


                        function baseUniq(array, iteratee, comparator) {
                            var index = -1,
                                includes = arrayIncludes,
                                length = array.length,
                                isCommon = true,
                                result = [],
                                seen = result;

                            if (comparator) {
                                isCommon = false;
                                includes = arrayIncludesWith;
                            } else if (length >= LARGE_ARRAY_SIZE) {
                                var set = iteratee ? null : createSet(array);
                                if (set) {
                                    return setToArray(set);
                                }
                                isCommon = false;
                                includes = cacheHas;
                                seen = new SetCache;
                            } else {
                                seen = iteratee ? [] : result;
                            }
                            outer:
                                while (++index < length) {
                                    var value = array[index],
                                        computed = iteratee ? iteratee(value) : value;

                                    value = (comparator || value !== 0) ? value : 0;
                                    if (isCommon && computed === computed) {
                                        var seenIndex = seen.length;
                                        while (seenIndex--) {
                                            if (seen[seenIndex] === computed) {
                                                continue outer;
                                            }
                                        }
                                        if (iteratee) {
                                            seen.push(computed);
                                        }
                                        result.push(value);
                                    } else if (!includes(seen, computed, comparator)) {
                                        if (seen !== result) {
                                            seen.push(computed);
                                        }
                                        result.push(value);
                                    }
                                }
                            return result;
                        }


                        function baseUnset(object, path) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            return object == null || delete object[toKey(last(path))];
                        }


                        function baseUpdate(object, path, updater, customizer) {
                            return baseSet(object, path, updater(baseGet(object, path)), customizer);
                        }


                        function baseWhile(array, predicate, isDrop, fromRight) {
                            var length = array.length,
                                index = fromRight ? length : -1;

                            while ((fromRight ? index-- : ++index < length) &&
                                predicate(array[index], index, array)) {}

                            return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                        }


                        function baseWrapperValue(value, actions) {
                            var result = value;
                            if (result instanceof LazyWrapper) {
                                result = result.value();
                            }
                            return arrayReduce(actions, function(result, action) {
                                return action.func.apply(action.thisArg, arrayPush([result], action.args));
                            }, result);
                        }


                        function baseXor(arrays, iteratee, comparator) {
                            var length = arrays.length;
                            if (length < 2) {
                                return length ? baseUniq(arrays[0]) : [];
                            }
                            var index = -1,
                                result = Array(length);

                            while (++index < length) {
                                var array = arrays[index],
                                    othIndex = -1;

                                while (++othIndex < length) {
                                    if (othIndex != index) {
                                        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                                    }
                                }
                            }
                            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
                        }


                        function baseZipObject(props, values, assignFunc) {
                            var index = -1,
                                length = props.length,
                                valsLength = values.length,
                                result = {};

                            while (++index < length) {
                                var value = index < valsLength ? values[index] : undefined;
                                assignFunc(result, props[index], value);
                            }
                            return result;
                        }


                        function castArrayLikeObject(value) {
                            return isArrayLikeObject(value) ? value : [];
                        }


                        function castFunction(value) {
                            return typeof value == 'function' ? value : identity;
                        }


                        function castPath(value, object) {
                            if (isArray(value)) {
                                return value;
                            }
                            return isKey(value, object) ? [value] : stringToPath(toString(value));
                        }


                        var castRest = baseRest;


                        function castSlice(array, start, end) {
                            var length = array.length;
                            end = end === undefined ? length : end;
                            return (!start && end >= length) ? array : baseSlice(array, start, end);
                        }


                        var clearTimeout = ctxClearTimeout || function(id) {
                            return root.clearTimeout(id);
                        };


                        function cloneBuffer(buffer, isDeep) {
                            if (isDeep) {
                                return buffer.slice();
                            }
                            var length = buffer.length,
                                result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

                            buffer.copy(result);
                            return result;
                        }


                        function cloneArrayBuffer(arrayBuffer) {
                            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                            return result;
                        }


                        function cloneDataView(dataView, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                        }


                        function cloneMap(map, isDeep, cloneFunc) {
                            var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
                            return arrayReduce(array, addMapEntry, new map.constructor);
                        }


                        function cloneRegExp(regexp) {
                            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                            result.lastIndex = regexp.lastIndex;
                            return result;
                        }


                        function cloneSet(set, isDeep, cloneFunc) {
                            var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
                            return arrayReduce(array, addSetEntry, new set.constructor);
                        }


                        function cloneSymbol(symbol) {
                            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                        }


                        function cloneTypedArray(typedArray, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                        }


                        function compareAscending(value, other) {
                            if (value !== other) {
                                var valIsDefined = value !== undefined,
                                    valIsNull = value === null,
                                    valIsReflexive = value === value,
                                    valIsSymbol = isSymbol(value);

                                var othIsDefined = other !== undefined,
                                    othIsNull = other === null,
                                    othIsReflexive = other === other,
                                    othIsSymbol = isSymbol(other);

                                if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                                    (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                                    (valIsNull && othIsDefined && othIsReflexive) ||
                                    (!valIsDefined && othIsReflexive) ||
                                    !valIsReflexive) {
                                    return 1;
                                }
                                if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                                    (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                                    (othIsNull && valIsDefined && valIsReflexive) ||
                                    (!othIsDefined && valIsReflexive) ||
                                    !othIsReflexive) {
                                    return -1;
                                }
                            }
                            return 0;
                        }


                        function compareMultiple(object, other, orders) {
                            var index = -1,
                                objCriteria = object.criteria,
                                othCriteria = other.criteria,
                                length = objCriteria.length,
                                ordersLength = orders.length;

                            while (++index < length) {
                                var result = compareAscending(objCriteria[index], othCriteria[index]);
                                if (result) {
                                    if (index >= ordersLength) {
                                        return result;
                                    }
                                    var order = orders[index];
                                    return result * (order == 'desc' ? -1 : 1);
                                }
                            }
                            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                            // that causes it, under certain circumstances, to provide the same value for
                            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                            // for more details.
                            //
                            // This also ensures a stable sort in V8 and other engines.
                            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                            return object.index - other.index;
                        }


                        function composeArgs(args, partials, holders, isCurried) {
                            var argsIndex = -1,
                                argsLength = args.length,
                                holdersLength = holders.length,
                                leftIndex = -1,
                                leftLength = partials.length,
                                rangeLength = nativeMax(argsLength - holdersLength, 0),
                                result = Array(leftLength + rangeLength),
                                isUncurried = !isCurried;

                            while (++leftIndex < leftLength) {
                                result[leftIndex] = partials[leftIndex];
                            }
                            while (++argsIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[holders[argsIndex]] = args[argsIndex];
                                }
                            }
                            while (rangeLength--) {
                                result[leftIndex++] = args[argsIndex++];
                            }
                            return result;
                        }


                        function composeArgsRight(args, partials, holders, isCurried) {
                            var argsIndex = -1,
                                argsLength = args.length,
                                holdersIndex = -1,
                                holdersLength = holders.length,
                                rightIndex = -1,
                                rightLength = partials.length,
                                rangeLength = nativeMax(argsLength - holdersLength, 0),
                                result = Array(rangeLength + rightLength),
                                isUncurried = !isCurried;

                            while (++argsIndex < rangeLength) {
                                result[argsIndex] = args[argsIndex];
                            }
                            var offset = argsIndex;
                            while (++rightIndex < rightLength) {
                                result[offset + rightIndex] = partials[rightIndex];
                            }
                            while (++holdersIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                                }
                            }
                            return result;
                        }


                        function copyArray(source, array) {
                            var index = -1,
                                length = source.length;

                            array || (array = Array(length));
                            while (++index < length) {
                                array[index] = source[index];
                            }
                            return array;
                        }


                        function copyObject(source, props, object, customizer) {
                            var isNew = !object;
                            object || (object = {});

                            var index = -1,
                                length = props.length;

                            while (++index < length) {
                                var key = props[index];

                                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

                                if (newValue === undefined) {
                                    newValue = source[key];
                                }
                                if (isNew) {
                                    baseAssignValue(object, key, newValue);
                                } else {
                                    assignValue(object, key, newValue);
                                }
                            }
                            return object;
                        }


                        function copySymbols(source, object) {
                            return copyObject(source, getSymbols(source), object);
                        }


                        function copySymbolsIn(source, object) {
                            return copyObject(source, getSymbolsIn(source), object);
                        }


                        function createAggregator(setter, initializer) {
                            return function(collection, iteratee) {
                                var func = isArray(collection) ? arrayAggregator : baseAggregator,
                                    accumulator = initializer ? initializer() : {};

                                return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                            };
                        }


                        function createAssigner(assigner) {
                            return baseRest(function(object, sources) {
                                var index = -1,
                                    length = sources.length,
                                    customizer = length > 1 ? sources[length - 1] : undefined,
                                    guard = length > 2 ? sources[2] : undefined;

                                customizer = (assigner.length > 3 && typeof customizer == 'function') ? (length--, customizer) : undefined;

                                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                    customizer = length < 3 ? undefined : customizer;
                                    length = 1;
                                }
                                object = Object(object);
                                while (++index < length) {
                                    var source = sources[index];
                                    if (source) {
                                        assigner(object, source, index, customizer);
                                    }
                                }
                                return object;
                            });
                        }


                        function createBaseEach(eachFunc, fromRight) {
                            return function(collection, iteratee) {
                                if (collection == null) {
                                    return collection;
                                }
                                if (!isArrayLike(collection)) {
                                    return eachFunc(collection, iteratee);
                                }
                                var length = collection.length,
                                    index = fromRight ? length : -1,
                                    iterable = Object(collection);

                                while ((fromRight ? index-- : ++index < length)) {
                                    if (iteratee(iterable[index], index, iterable) === false) {
                                        break;
                                    }
                                }
                                return collection;
                            };
                        }


                        function createBaseFor(fromRight) {
                            return function(object, iteratee, keysFunc) {
                                var index = -1,
                                    iterable = Object(object),
                                    props = keysFunc(object),
                                    length = props.length;

                                while (length--) {
                                    var key = props[fromRight ? length : ++index];
                                    if (iteratee(iterable[key], key, iterable) === false) {
                                        break;
                                    }
                                }
                                return object;
                            };
                        }


                        function createBind(func, bitmask, thisArg) {
                            var isBind = bitmask & WRAP_BIND_FLAG,
                                Ctor = createCtor(func);

                            function wrapper() {
                                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                return fn.apply(isBind ? thisArg : this, arguments);
                            }
                            return wrapper;
                        }


                        function createCaseFirst(methodName) {
                            return function(string) {
                                string = toString(string);

                                var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;

                                var chr = strSymbols ? strSymbols[0] : string.charAt(0);

                                var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);

                                return chr[methodName]() + trailing;
                            };
                        }


                        function createCompounder(callback) {
                            return function(string) {
                                return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                            };
                        }


                        function createCtor(Ctor) {
                            return function() {
                                // Use a `switch` statement to work with class constructors. See
                                // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                                // for more details.
                                var args = arguments;
                                switch (args.length) {
                                    case 0:
                                        return new Ctor;
                                    case 1:
                                        return new Ctor(args[0]);
                                    case 2:
                                        return new Ctor(args[0], args[1]);
                                    case 3:
                                        return new Ctor(args[0], args[1], args[2]);
                                    case 4:
                                        return new Ctor(args[0], args[1], args[2], args[3]);
                                    case 5:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                    case 6:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                    case 7:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                                }
                                var thisBinding = baseCreate(Ctor.prototype),
                                    result = Ctor.apply(thisBinding, args);

                                // Mimic the constructor's `return` behavior.
                                // See https://es5.github.io/#x13.2.2 for more details.
                                return isObject(result) ? result : thisBinding;
                            };
                        }


                        function createCurry(func, bitmask, arity) {
                            var Ctor = createCtor(func);

                            function wrapper() {
                                var length = arguments.length,
                                    args = Array(length),
                                    index = length,
                                    placeholder = getHolder(wrapper);

                                while (index--) {
                                    args[index] = arguments[index];
                                }
                                var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder) ? [] : replaceHolders(args, placeholder);

                                length -= holders.length;
                                if (length < arity) {
                                    return createRecurry(
                                        func, bitmask, createHybrid, wrapper.placeholder, undefined,
                                        args, holders, undefined, undefined, arity - length);
                                }
                                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                return apply(fn, this, args);
                            }
                            return wrapper;
                        }


                        function createFind(findIndexFunc) {
                            return function(collection, predicate, fromIndex) {
                                var iterable = Object(collection);
                                if (!isArrayLike(collection)) {
                                    var iteratee = getIteratee(predicate, 3);
                                    collection = keys(collection);
                                    predicate = function(key) {
                                        return iteratee(iterable[key], key, iterable);
                                    };
                                }
                                var index = findIndexFunc(collection, predicate, fromIndex);
                                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                            };
                        }


                        function createFlow(fromRight) {
                            return flatRest(function(funcs) {
                                var length = funcs.length,
                                    index = length,
                                    prereq = LodashWrapper.prototype.thru;

                                if (fromRight) {
                                    funcs.reverse();
                                }
                                while (index--) {
                                    var func = funcs[index];
                                    if (typeof func != 'function') {
                                        throw new TypeError(FUNC_ERROR_TEXT);
                                    }
                                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                                        var wrapper = new LodashWrapper([], true);
                                    }
                                }
                                index = wrapper ? index : length;
                                while (++index < length) {
                                    func = funcs[index];

                                    var funcName = getFuncName(func),
                                        data = funcName == 'wrapper' ? getData(func) : undefined;

                                    if (data && isLaziable(data[0]) &&
                                        data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                                        !data[4].length && data[9] == 1
                                    ) {
                                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                    } else {
                                        wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                                    }
                                }
                                return function() {
                                    var args = arguments,
                                        value = args[0];

                                    if (wrapper && args.length == 1 &&
                                        isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                                        return wrapper.plant(value).value();
                                    }
                                    var index = 0,
                                        result = length ? funcs[index].apply(this, args) : value;

                                    while (++index < length) {
                                        result = funcs[index].call(this, result);
                                    }
                                    return result;
                                };
                            });
                        }


                        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                            var isAry = bitmask & WRAP_ARY_FLAG,
                                isBind = bitmask & WRAP_BIND_FLAG,
                                isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                                isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                                isFlip = bitmask & WRAP_FLIP_FLAG,
                                Ctor = isBindKey ? undefined : createCtor(func);

                            function wrapper() {
                                var length = arguments.length,
                                    args = Array(length),
                                    index = length;

                                while (index--) {
                                    args[index] = arguments[index];
                                }
                                if (isCurried) {
                                    var placeholder = getHolder(wrapper),
                                        holdersCount = countHolders(args, placeholder);
                                }
                                if (partials) {
                                    args = composeArgs(args, partials, holders, isCurried);
                                }
                                if (partialsRight) {
                                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                                }
                                length -= holdersCount;
                                if (isCurried && length < arity) {
                                    var newHolders = replaceHolders(args, placeholder);
                                    return createRecurry(
                                        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                                        args, newHolders, argPos, ary, arity - length
                                    );
                                }
                                var thisBinding = isBind ? thisArg : this,
                                    fn = isBindKey ? thisBinding[func] : func;

                                length = args.length;
                                if (argPos) {
                                    args = reorder(args, argPos);
                                } else if (isFlip && length > 1) {
                                    args.reverse();
                                }
                                if (isAry && ary < length) {
                                    args.length = ary;
                                }
                                if (this && this !== root && this instanceof wrapper) {
                                    fn = Ctor || createCtor(fn);
                                }
                                return fn.apply(thisBinding, args);
                            }
                            return wrapper;
                        }


                        function createInverter(setter, toIteratee) {
                            return function(object, iteratee) {
                                return baseInverter(object, setter, toIteratee(iteratee), {});
                            };
                        }


                        function createMathOperation(operator, defaultValue) {
                            return function(value, other) {
                                var result;
                                if (value === undefined && other === undefined) {
                                    return defaultValue;
                                }
                                if (value !== undefined) {
                                    result = value;
                                }
                                if (other !== undefined) {
                                    if (result === undefined) {
                                        return other;
                                    }
                                    if (typeof value == 'string' || typeof other == 'string') {
                                        value = baseToString(value);
                                        other = baseToString(other);
                                    } else {
                                        value = baseToNumber(value);
                                        other = baseToNumber(other);
                                    }
                                    result = operator(value, other);
                                }
                                return result;
                            };
                        }


                        function createOver(arrayFunc) {
                            return flatRest(function(iteratees) {
                                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                                return baseRest(function(args) {
                                    var thisArg = this;
                                    return arrayFunc(iteratees, function(iteratee) {
                                        return apply(iteratee, thisArg, args);
                                    });
                                });
                            });
                        }


                        function createPadding(length, chars) {
                            chars = chars === undefined ? ' ' : baseToString(chars);

                            var charsLength = chars.length;
                            if (charsLength < 2) {
                                return charsLength ? baseRepeat(chars, length) : chars;
                            }
                            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
                        }


                        function createPartial(func, bitmask, thisArg, partials) {
                            var isBind = bitmask & WRAP_BIND_FLAG,
                                Ctor = createCtor(func);

                            function wrapper() {
                                var argsIndex = -1,
                                    argsLength = arguments.length,
                                    leftIndex = -1,
                                    leftLength = partials.length,
                                    args = Array(leftLength + argsLength),
                                    fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

                                while (++leftIndex < leftLength) {
                                    args[leftIndex] = partials[leftIndex];
                                }
                                while (argsLength--) {
                                    args[leftIndex++] = arguments[++argsIndex];
                                }
                                return apply(fn, isBind ? thisArg : this, args);
                            }
                            return wrapper;
                        }


                        function createRange(fromRight) {
                            return function(start, end, step) {
                                if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                                    end = step = undefined;
                                }
                                // Ensure the sign of `-0` is preserved.
                                start = toFinite(start);
                                if (end === undefined) {
                                    end = start;
                                    start = 0;
                                } else {
                                    end = toFinite(end);
                                }
                                step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
                                return baseRange(start, end, step, fromRight);
                            };
                        }


                        function createRelationalOperation(operator) {
                            return function(value, other) {
                                if (!(typeof value == 'string' && typeof other == 'string')) {
                                    value = toNumber(value);
                                    other = toNumber(other);
                                }
                                return operator(value, other);
                            };
                        }


                        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                            var isCurry = bitmask & WRAP_CURRY_FLAG,
                                newHolders = isCurry ? holders : undefined,
                                newHoldersRight = isCurry ? undefined : holders,
                                newPartials = isCurry ? partials : undefined,
                                newPartialsRight = isCurry ? undefined : partials;

                            bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
                            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

                            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                                bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                            }
                            var newData = [
                                func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
                                newHoldersRight, argPos, ary, arity
                            ];

                            var result = wrapFunc.apply(undefined, newData);
                            if (isLaziable(func)) {
                                setData(result, newData);
                            }
                            result.placeholder = placeholder;
                            return setWrapToString(result, func, bitmask);
                        }


                        function createRound(methodName) {
                            var func = Math[methodName];
                            return function(number, precision) {
                                number = toNumber(number);
                                precision = nativeMin(toInteger(precision), 292);
                                if (precision) {
                                    // Shift with exponential notation to avoid floating-point issues.
                                    // See [MDN](https://mdn.io/round#Examples) for more details.
                                    var pair = (toString(number) + 'e').split('e'),
                                        value = func(pair[0] + 'e' + (+pair[1] + precision));

                                    pair = (toString(value) + 'e').split('e');
                                    return +(pair[0] + 'e' + (+pair[1] - precision));
                                }
                                return func(number);
                            };
                        }


                        var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function(values) {
                            return new Set(values);
                        };


                        function createToPairs(keysFunc) {
                            return function(object) {
                                var tag = getTag(object);
                                if (tag == mapTag) {
                                    return mapToArray(object);
                                }
                                if (tag == setTag) {
                                    return setToPairs(object);
                                }
                                return baseToPairs(object, keysFunc(object));
                            };
                        }


                        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                            if (!isBindKey && typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            var length = partials ? partials.length : 0;
                            if (!length) {
                                bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                                partials = holders = undefined;
                            }
                            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                            arity = arity === undefined ? arity : toInteger(arity);
                            length -= holders ? holders.length : 0;

                            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                                var partialsRight = partials,
                                    holdersRight = holders;

                                partials = holders = undefined;
                            }
                            var data = isBindKey ? undefined : getData(func);

                            var newData = [
                                func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
                                argPos, ary, arity
                            ];

                            if (data) {
                                mergeData(newData, data);
                            }
                            func = newData[0];
                            bitmask = newData[1];
                            thisArg = newData[2];
                            partials = newData[3];
                            holders = newData[4];
                            arity = newData[9] = newData[9] == null ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0);

                            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                                bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                            }
                            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                                var result = createBind(func, bitmask, thisArg);
                            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                                result = createCurry(func, bitmask, arity);
                            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                                result = createPartial(func, bitmask, thisArg, partials);
                            } else {
                                result = createHybrid.apply(undefined, newData);
                            }
                            var setter = data ? baseSetData : setData;
                            return setWrapToString(setter(result, newData), func, bitmask);
                        }


                        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                                arrLength = array.length,
                                othLength = other.length;

                            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                                return false;
                            }
                            // Assume cyclic values are equal.
                            var stacked = stack.get(array);
                            if (stacked && stack.get(other)) {
                                return stacked == other;
                            }
                            var index = -1,
                                result = true,
                                seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

                            stack.set(array, other);
                            stack.set(other, array);

                            // Ignore non-index properties.
                            while (++index < arrLength) {
                                var arrValue = array[index],
                                    othValue = other[index];

                                if (customizer) {
                                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                                }
                                if (compared !== undefined) {
                                    if (compared) {
                                        continue;
                                    }
                                    result = false;
                                    break;
                                }
                                // Recursively compare arrays (susceptible to call stack limits).
                                if (seen) {
                                    if (!arraySome(other, function(othValue, othIndex) {
                                            if (!cacheHas(seen, othIndex) &&
                                                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                                return seen.push(othIndex);
                                            }
                                        })) {
                                        result = false;
                                        break;
                                    }
                                } else if (!(
                                        arrValue === othValue ||
                                        equalFunc(arrValue, othValue, bitmask, customizer, stack)
                                    )) {
                                    result = false;
                                    break;
                                }
                            }
                            stack['delete'](array);
                            stack['delete'](other);
                            return result;
                        }


                        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                            switch (tag) {
                                case dataViewTag:
                                    if ((object.byteLength != other.byteLength) ||
                                        (object.byteOffset != other.byteOffset)) {
                                        return false;
                                    }
                                    object = object.buffer;
                                    other = other.buffer;

                                case arrayBufferTag:
                                    if ((object.byteLength != other.byteLength) ||
                                        !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                        return false;
                                    }
                                    return true;

                                case boolTag:
                                case dateTag:
                                case numberTag:
                                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                                    // Invalid dates are coerced to `NaN`.
                                    return eq(+object, +other);

                                case errorTag:
                                    return object.name == other.name && object.message == other.message;

                                case regexpTag:
                                case stringTag:
                                    // Coerce regexes to strings and treat strings, primitives and objects,
                                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                                    // for more details.
                                    return object == (other + '');

                                case mapTag:
                                    var convert = mapToArray;

                                case setTag:
                                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                                    convert || (convert = setToArray);

                                    if (object.size != other.size && !isPartial) {
                                        return false;
                                    }
                                    // Assume cyclic values are equal.
                                    var stacked = stack.get(object);
                                    if (stacked) {
                                        return stacked == other;
                                    }
                                    bitmask |= COMPARE_UNORDERED_FLAG;

                                    // Recursively compare objects (susceptible to call stack limits).
                                    stack.set(object, other);
                                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                                    stack['delete'](object);
                                    return result;

                                case symbolTag:
                                    if (symbolValueOf) {
                                        return symbolValueOf.call(object) == symbolValueOf.call(other);
                                    }
                            }
                            return false;
                        }


                        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                                objProps = keys(object),
                                objLength = objProps.length,
                                othProps = keys(other),
                                othLength = othProps.length;

                            if (objLength != othLength && !isPartial) {
                                return false;
                            }
                            var index = objLength;
                            while (index--) {
                                var key = objProps[index];
                                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                                    return false;
                                }
                            }
                            // Assume cyclic values are equal.
                            var stacked = stack.get(object);
                            if (stacked && stack.get(other)) {
                                return stacked == other;
                            }
                            var result = true;
                            stack.set(object, other);
                            stack.set(other, object);

                            var skipCtor = isPartial;
                            while (++index < objLength) {
                                key = objProps[index];
                                var objValue = object[key],
                                    othValue = other[key];

                                if (customizer) {
                                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                                }
                                // Recursively compare objects (susceptible to call stack limits).
                                if (!(compared === undefined ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)) : compared)) {
                                    result = false;
                                    break;
                                }
                                skipCtor || (skipCtor = key == 'constructor');
                            }
                            if (result && !skipCtor) {
                                var objCtor = object.constructor,
                                    othCtor = other.constructor;

                                // Non `Object` object instances with different constructors are not equal.
                                if (objCtor != othCtor &&
                                    ('constructor' in object && 'constructor' in other) &&
                                    !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                        typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                    result = false;
                                }
                            }
                            stack['delete'](object);
                            stack['delete'](other);
                            return result;
                        }


                        function flatRest(func) {
                            return setToString(overRest(func, undefined, flatten), func + '');
                        }


                        function getAllKeys(object) {
                            return baseGetAllKeys(object, keys, getSymbols);
                        }


                        function getAllKeysIn(object) {
                            return baseGetAllKeys(object, keysIn, getSymbolsIn);
                        }


                        var getData = !metaMap ? noop : function(func) {
                            return metaMap.get(func);
                        };


                        function getFuncName(func) {
                            var result = (func.name + ''),
                                array = realNames[result],
                                length = hasOwnProperty.call(realNames, result) ? array.length : 0;

                            while (length--) {
                                var data = array[length],
                                    otherFunc = data.func;
                                if (otherFunc == null || otherFunc == func) {
                                    return data.name;
                                }
                            }
                            return result;
                        }


                        function getHolder(func) {
                            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                            return object.placeholder;
                        }


                        function getIteratee() {
                            var result = lodash.iteratee || iteratee;
                            result = result === iteratee ? baseIteratee : result;
                            return arguments.length ? result(arguments[0], arguments[1]) : result;
                        }


                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
                        }


                        function getMatchData(object) {
                            var result = keys(object),
                                length = result.length;

                            while (length--) {
                                var key = result[length],
                                    value = object[key];

                                result[length] = [key, value, isStrictComparable(value)];
                            }
                            return result;
                        }


                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }


                        function getRawTag(value) {
                            var isOwn = hasOwnProperty.call(value, symToStringTag),
                                tag = value[symToStringTag];

                            try {
                                value[symToStringTag] = undefined;
                                var unmasked = true;
                            } catch (e) {}

                            var result = nativeObjectToString.call(value);
                            if (unmasked) {
                                if (isOwn) {
                                    value[symToStringTag] = tag;
                                } else {
                                    delete value[symToStringTag];
                                }
                            }
                            return result;
                        }


                        var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;


                        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                            var result = [];
                            while (object) {
                                arrayPush(result, getSymbols(object));
                                object = getPrototype(object);
                            }
                            return result;
                        };


                        var getTag = baseGetTag;

                        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
                        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                            (Map && getTag(new Map) != mapTag) ||
                            (Promise && getTag(Promise.resolve()) != promiseTag) ||
                            (Set && getTag(new Set) != setTag) ||
                            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
                            getTag = function(value) {
                                var result = baseGetTag(value),
                                    Ctor = result == objectTag ? value.constructor : undefined,
                                    ctorString = Ctor ? toSource(Ctor) : '';

                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString:
                                            return dataViewTag;
                                        case mapCtorString:
                                            return mapTag;
                                        case promiseCtorString:
                                            return promiseTag;
                                        case setCtorString:
                                            return setTag;
                                        case weakMapCtorString:
                                            return weakMapTag;
                                    }
                                }
                                return result;
                            };
                        }


                        function getView(start, end, transforms) {
                            var index = -1,
                                length = transforms.length;

                            while (++index < length) {
                                var data = transforms[index],
                                    size = data.size;

                                switch (data.type) {
                                    case 'drop':
                                        start += size;
                                        break;
                                    case 'dropRight':
                                        end -= size;
                                        break;
                                    case 'take':
                                        end = nativeMin(end, start + size);
                                        break;
                                    case 'takeRight':
                                        start = nativeMax(start, end - size);
                                        break;
                                }
                            }
                            return {
                                'start': start,
                                'end': end
                            };
                        }


                        function getWrapDetails(source) {
                            var match = source.match(reWrapDetails);
                            return match ? match[1].split(reSplitDetails) : [];
                        }


                        function hasPath(object, path, hasFunc) {
                            path = castPath(path, object);

                            var index = -1,
                                length = path.length,
                                result = false;

                            while (++index < length) {
                                var key = toKey(path[index]);
                                if (!(result = object != null && hasFunc(object, key))) {
                                    break;
                                }
                                object = object[key];
                            }
                            if (result || ++index != length) {
                                return result;
                            }
                            length = object == null ? 0 : object.length;
                            return !!length && isLength(length) && isIndex(key, length) &&
                                (isArray(object) || isArguments(object));
                        }


                        function initCloneArray(array) {
                            var length = array.length,
                                result = array.constructor(length);

                            // Add properties assigned by `RegExp#exec`.
                            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                                result.index = array.index;
                                result.input = array.input;
                            }
                            return result;
                        }


                        function initCloneObject(object) {
                            return (typeof object.constructor == 'function' && !isPrototype(object)) ? baseCreate(getPrototype(object)) : {};
                        }


                        function initCloneByTag(object, tag, cloneFunc, isDeep) {
                            var Ctor = object.constructor;
                            switch (tag) {
                                case arrayBufferTag:
                                    return cloneArrayBuffer(object);

                                case boolTag:
                                case dateTag:
                                    return new Ctor(+object);

                                case dataViewTag:
                                    return cloneDataView(object, isDeep);

                                case float32Tag:
                                case float64Tag:
                                case int8Tag:
                                case int16Tag:
                                case int32Tag:
                                case uint8Tag:
                                case uint8ClampedTag:
                                case uint16Tag:
                                case uint32Tag:
                                    return cloneTypedArray(object, isDeep);

                                case mapTag:
                                    return cloneMap(object, isDeep, cloneFunc);

                                case numberTag:
                                case stringTag:
                                    return new Ctor(object);

                                case regexpTag:
                                    return cloneRegExp(object);

                                case setTag:
                                    return cloneSet(object, isDeep, cloneFunc);

                                case symbolTag:
                                    return cloneSymbol(object);
                            }
                        }


                        function insertWrapDetails(source, details) {
                            var length = details.length;
                            if (!length) {
                                return source;
                            }
                            var lastIndex = length - 1;
                            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
                            details = details.join(length > 2 ? ', ' : ' ');
                            return source.replace(reWrapComment, '{\n\n');
                        }


                        function isFlattenable(value) {
                            return isArray(value) || isArguments(value) ||
                                !!(spreadableSymbol && value && value[spreadableSymbol]);
                        }


                        function isIndex(value, length) {
                            length = length == null ? MAX_SAFE_INTEGER : length;
                            return !!length &&
                                (typeof value == 'number' || reIsUint.test(value)) &&
                                (value > -1 && value % 1 == 0 && value < length);
                        }


                        function isIterateeCall(value, index, object) {
                            if (!isObject(object)) {
                                return false;
                            }
                            var type = typeof index;
                            if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
                                return eq(object[index], value);
                            }
                            return false;
                        }


                        function isKey(value, object) {
                            if (isArray(value)) {
                                return false;
                            }
                            var type = typeof value;
                            if (type == 'number' || type == 'symbol' || type == 'boolean' ||
                                value == null || isSymbol(value)) {
                                return true;
                            }
                            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                                (object != null && value in Object(object));
                        }


                        function isKeyable(value) {
                            var type = typeof value;
                            return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean') ? (value !== '__proto__') : (value === null);
                        }


                        function isLaziable(func) {
                            var funcName = getFuncName(func),
                                other = lodash[funcName];

                            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                                return false;
                            }
                            if (func === other) {
                                return true;
                            }
                            var data = getData(other);
                            return !!data && func === data[0];
                        }


                        function isMasked(func) {
                            return !!maskSrcKey && (maskSrcKey in func);
                        }


                        var isMaskable = coreJsData ? isFunction : stubFalse;


                        function isPrototype(value) {
                            var Ctor = value && value.constructor,
                                proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

                            return value === proto;
                        }


                        function isStrictComparable(value) {
                            return value === value && !isObject(value);
                        }


                        function matchesStrictComparable(key, srcValue) {
                            return function(object) {
                                if (object == null) {
                                    return false;
                                }
                                return object[key] === srcValue &&
                                    (srcValue !== undefined || (key in Object(object)));
                            };
                        }


                        function memoizeCapped(func) {
                            var result = memoize(func, function(key) {
                                if (cache.size === MAX_MEMOIZE_SIZE) {
                                    cache.clear();
                                }
                                return key;
                            });

                            var cache = result.cache;
                            return result;
                        }


                        function mergeData(data, source) {
                            var bitmask = data[1],
                                srcBitmask = source[1],
                                newBitmask = bitmask | srcBitmask,
                                isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

                            var isCombo =
                                ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
                                ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
                                ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

                            // Exit early if metadata can't be merged.
                            if (!(isCommon || isCombo)) {
                                return data;
                            }
                            // Use source `thisArg` if available.
                            if (srcBitmask & WRAP_BIND_FLAG) {
                                data[2] = source[2];
                                // Set when currying a bound function.
                                newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                            }
                            // Compose partial arguments.
                            var value = source[3];
                            if (value) {
                                var partials = data[3];
                                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                            }
                            // Compose partial right arguments.
                            value = source[5];
                            if (value) {
                                partials = data[5];
                                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                            }
                            // Use source `argPos` if available.
                            value = source[7];
                            if (value) {
                                data[7] = value;
                            }
                            // Use source `ary` if it's smaller.
                            if (srcBitmask & WRAP_ARY_FLAG) {
                                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                            }
                            // Use source `arity` if one is not provided.
                            if (data[9] == null) {
                                data[9] = source[9];
                            }
                            // Use source `func` and merge bitmasks.
                            data[0] = source[0];
                            data[1] = newBitmask;

                            return data;
                        }


                        function mergeDefaults(objValue, srcValue, key, object, source, stack) {
                            if (isObject(objValue) && isObject(srcValue)) {
                                // Recursively merge objects and arrays (susceptible to call stack limits).
                                stack.set(srcValue, objValue);
                                baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
                                stack['delete'](srcValue);
                            }
                            return objValue;
                        }


                        function nativeKeysIn(object) {
                            var result = [];
                            if (object != null) {
                                for (var key in Object(object)) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }


                        function objectToString(value) {
                            return nativeObjectToString.call(value);
                        }


                        function overRest(func, start, transform) {
                            start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
                            return function() {
                                var args = arguments,
                                    index = -1,
                                    length = nativeMax(args.length - start, 0),
                                    array = Array(length);

                                while (++index < length) {
                                    array[index] = args[start + index];
                                }
                                index = -1;
                                var otherArgs = Array(start + 1);
                                while (++index < start) {
                                    otherArgs[index] = args[index];
                                }
                                otherArgs[start] = transform(array);
                                return apply(func, this, otherArgs);
                            };
                        }


                        function parent(object, path) {
                            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                        }


                        function reorder(array, indexes) {
                            var arrLength = array.length,
                                length = nativeMin(indexes.length, arrLength),
                                oldArray = copyArray(array);

                            while (length--) {
                                var index = indexes[length];
                                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                            }
                            return array;
                        }


                        var setData = shortOut(baseSetData);


                        var setTimeout = ctxSetTimeout || function(func, wait) {
                            return root.setTimeout(func, wait);
                        };


                        var setToString = shortOut(baseSetToString);


                        function setWrapToString(wrapper, reference, bitmask) {
                            var source = (reference + '');
                            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                        }


                        function shortOut(func) {
                            var count = 0,
                                lastCalled = 0;

                            return function() {
                                var stamp = nativeNow(),
                                    remaining = HOT_SPAN - (stamp - lastCalled);

                                lastCalled = stamp;
                                if (remaining > 0) {
                                    if (++count >= HOT_COUNT) {
                                        return arguments[0];
                                    }
                                } else {
                                    count = 0;
                                }
                                return func.apply(undefined, arguments);
                            };
                        }


                        function shuffleSelf(array, size) {
                            var index = -1,
                                length = array.length,
                                lastIndex = length - 1;

                            size = size === undefined ? length : size;
                            while (++index < size) {
                                var rand = baseRandom(index, lastIndex),
                                    value = array[rand];

                                array[rand] = array[index];
                                array[index] = value;
                            }
                            array.length = size;
                            return array;
                        }


                        var stringToPath = memoizeCapped(function(string) {
                            var result = [];
                            if (reLeadingDot.test(string)) {
                                result.push('');
                            }
                            string.replace(rePropName, function(match, number, quote, string) {
                                result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
                            });
                            return result;
                        });


                        function toKey(value) {
                            if (typeof value == 'string' || isSymbol(value)) {
                                return value;
                            }
                            var result = (value + '');
                            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                        }


                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                } catch (e) {}
                                try {
                                    return (func + '');
                                } catch (e) {}
                            }
                            return '';
                        }


                        function updateWrapDetails(details, bitmask) {
                            arrayEach(wrapFlags, function(pair) {
                                var value = '_.' + pair[0];
                                if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
                                    details.push(value);
                                }
                            });
                            return details.sort();
                        }


                        function wrapperClone(wrapper) {
                            if (wrapper instanceof LazyWrapper) {
                                return wrapper.clone();
                            }
                            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                            result.__actions__ = copyArray(wrapper.__actions__);
                            result.__index__ = wrapper.__index__;
                            result.__values__ = wrapper.__values__;
                            return result;
                        }




                        function chunk(array, size, guard) {
                            if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
                                size = 1;
                            } else {
                                size = nativeMax(toInteger(size), 0);
                            }
                            var length = array == null ? 0 : array.length;
                            if (!length || size < 1) {
                                return [];
                            }
                            var index = 0,
                                resIndex = 0,
                                result = Array(nativeCeil(length / size));

                            while (index < length) {
                                result[resIndex++] = baseSlice(array, index, (index += size));
                            }
                            return result;
                        }


                        function compact(array) {
                            var index = -1,
                                length = array == null ? 0 : array.length,
                                resIndex = 0,
                                result = [];

                            while (++index < length) {
                                var value = array[index];
                                if (value) {
                                    result[resIndex++] = value;
                                }
                            }
                            return result;
                        }


                        function concat() {
                            var length = arguments.length;
                            if (!length) {
                                return [];
                            }
                            var args = Array(length - 1),
                                array = arguments[0],
                                index = length;

                            while (index--) {
                                args[index - 1] = arguments[index];
                            }
                            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                        }


                        var difference = baseRest(function(array, values) {
                            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
                        });


                        var differenceBy = baseRest(function(array, values) {
                            var iteratee = last(values);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
                        });


                        var differenceWith = baseRest(function(array, values) {
                            var comparator = last(values);
                            if (isArrayLikeObject(comparator)) {
                                comparator = undefined;
                            }
                            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
                        });


                        function drop(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            return baseSlice(array, n < 0 ? 0 : n, length);
                        }


                        function dropRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, 0, n < 0 ? 0 : n);
                        }


                        function dropRightWhile(array, predicate) {
                            return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                        }


                        function dropWhile(array, predicate) {
                            return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                        }


                        function fill(array, value, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                                start = 0;
                                end = length;
                            }
                            return baseFill(array, value, start, end);
                        }


                        function findIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0);
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index);
                        }


                        function findLastIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = length - 1;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                        }


                        function flatten(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, 1) : [];
                        }


                        function flattenDeep(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, INFINITY) : [];
                        }


                        function flattenDepth(array, depth) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(array, depth);
                        }


                        function fromPairs(pairs) {
                            var index = -1,
                                length = pairs == null ? 0 : pairs.length,
                                result = {};

                            while (++index < length) {
                                var pair = pairs[index];
                                result[pair[0]] = pair[1];
                            }
                            return result;
                        }


                        function head(array) {
                            return (array && array.length) ? array[0] : undefined;
                        }


                        function indexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0);
                            }
                            return baseIndexOf(array, value, index);
                        }


                        function initial(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 0, -1) : [];
                        }


                        var intersection = baseRest(function(arrays) {
                            var mapped = arrayMap(arrays, castArrayLikeObject);
                            return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped) : [];
                        });


                        var intersectionBy = baseRest(function(arrays) {
                            var iteratee = last(arrays),
                                mapped = arrayMap(arrays, castArrayLikeObject);

                            if (iteratee === last(mapped)) {
                                iteratee = undefined;
                            } else {
                                mapped.pop();
                            }
                            return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
                        });


                        var intersectionWith = baseRest(function(arrays) {
                            var comparator = last(arrays),
                                mapped = arrayMap(arrays, castArrayLikeObject);

                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            if (comparator) {
                                mapped.pop();
                            }
                            return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, undefined, comparator) : [];
                        });


                        function join(array, separator) {
                            return array == null ? '' : nativeJoin.call(array, separator);
                        }


                        function last(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? array[length - 1] : undefined;
                        }


                        function lastIndexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = length;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                            }
                            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                        }


                        function nth(array, n) {
                            return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
                        }


                        var pull = baseRest(pullAll);


                        function pullAll(array, values) {
                            return (array && array.length && values && values.length) ? basePullAll(array, values) : array;
                        }


                        function pullAllBy(array, values, iteratee) {
                            return (array && array.length && values && values.length) ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
                        }


                        function pullAllWith(array, values, comparator) {
                            return (array && array.length && values && values.length) ? basePullAll(array, values, undefined, comparator) : array;
                        }


                        var pullAt = flatRest(function(array, indexes) {
                            var length = array == null ? 0 : array.length,
                                result = baseAt(array, indexes);

                            basePullAt(array, arrayMap(indexes, function(index) {
                                return isIndex(index, length) ? +index : index;
                            }).sort(compareAscending));

                            return result;
                        });


                        function remove(array, predicate) {
                            var result = [];
                            if (!(array && array.length)) {
                                return result;
                            }
                            var index = -1,
                                indexes = [],
                                length = array.length;

                            predicate = getIteratee(predicate, 3);
                            while (++index < length) {
                                var value = array[index];
                                if (predicate(value, index, array)) {
                                    result.push(value);
                                    indexes.push(index);
                                }
                            }
                            basePullAt(array, indexes);
                            return result;
                        }


                        function reverse(array) {
                            return array == null ? array : nativeReverse.call(array);
                        }


                        function slice(array, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                                start = 0;
                                end = length;
                            } else {
                                start = start == null ? 0 : toInteger(start);
                                end = end === undefined ? length : toInteger(end);
                            }
                            return baseSlice(array, start, end);
                        }


                        function sortedIndex(array, value) {
                            return baseSortedIndex(array, value);
                        }


                        function sortedIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
                        }


                        function sortedIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value);
                                if (index < length && eq(array[index], value)) {
                                    return index;
                                }
                            }
                            return -1;
                        }


                        function sortedLastIndex(array, value) {
                            return baseSortedIndex(array, value, true);
                        }


                        function sortedLastIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
                        }


                        function sortedLastIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value, true) - 1;
                                if (eq(array[index], value)) {
                                    return index;
                                }
                            }
                            return -1;
                        }


                        function sortedUniq(array) {
                            return (array && array.length) ? baseSortedUniq(array) : [];
                        }


                        function sortedUniqBy(array, iteratee) {
                            return (array && array.length) ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
                        }


                        function tail(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 1, length) : [];
                        }


                        function take(array, n, guard) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            return baseSlice(array, 0, n < 0 ? 0 : n);
                        }


                        function takeRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, n < 0 ? 0 : n, length);
                        }


                        function takeRightWhile(array, predicate) {
                            return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                        }


                        function takeWhile(array, predicate) {
                            return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3)) : [];
                        }


                        var union = baseRest(function(arrays) {
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                        });


                        var unionBy = baseRest(function(arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
                        });


                        var unionWith = baseRest(function(arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
                        });


                        function uniq(array) {
                            return (array && array.length) ? baseUniq(array) : [];
                        }


                        function uniqBy(array, iteratee) {
                            return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
                        }


                        function uniqWith(array, comparator) {
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
                        }


                        function unzip(array) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            var length = 0;
                            array = arrayFilter(array, function(group) {
                                if (isArrayLikeObject(group)) {
                                    length = nativeMax(group.length, length);
                                    return true;
                                }
                            });
                            return baseTimes(length, function(index) {
                                return arrayMap(array, baseProperty(index));
                            });
                        }


                        function unzipWith(array, iteratee) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            var result = unzip(array);
                            if (iteratee == null) {
                                return result;
                            }
                            return arrayMap(result, function(group) {
                                return apply(iteratee, undefined, group);
                            });
                        }


                        var without = baseRest(function(array, values) {
                            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
                        });


                        var xor = baseRest(function(arrays) {
                            return baseXor(arrayFilter(arrays, isArrayLikeObject));
                        });


                        var xorBy = baseRest(function(arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                        });


                        var xorWith = baseRest(function(arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                        });


                        var zip = baseRest(unzip);


                        function zipObject(props, values) {
                            return baseZipObject(props || [], values || [], assignValue);
                        }


                        function zipObjectDeep(props, values) {
                            return baseZipObject(props || [], values || [], baseSet);
                        }


                        var zipWith = baseRest(function(arrays) {
                            var length = arrays.length,
                                iteratee = length > 1 ? arrays[length - 1] : undefined;

                            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
                            return unzipWith(arrays, iteratee);
                        });




                        function chain(value) {
                            var result = lodash(value);
                            result.__chain__ = true;
                            return result;
                        }


                        function tap(value, interceptor) {
                            interceptor(value);
                            return value;
                        }


                        function thru(value, interceptor) {
                            return interceptor(value);
                        }


                        var wrapperAt = flatRest(function(paths) {
                            var length = paths.length,
                                start = length ? paths[0] : 0,
                                value = this.__wrapped__,
                                interceptor = function(object) {
                                    return baseAt(object, paths);
                                };

                            if (length > 1 || this.__actions__.length ||
                                !(value instanceof LazyWrapper) || !isIndex(start)) {
                                return this.thru(interceptor);
                            }
                            value = value.slice(start, +start + (length ? 1 : 0));
                            value.__actions__.push({
                                'func': thru,
                                'args': [interceptor],
                                'thisArg': undefined
                            });
                            return new LodashWrapper(value, this.__chain__).thru(function(array) {
                                if (length && !array.length) {
                                    array.push(undefined);
                                }
                                return array;
                            });
                        });


                        function wrapperChain() {
                            return chain(this);
                        }


                        function wrapperCommit() {
                            return new LodashWrapper(this.value(), this.__chain__);
                        }


                        function wrapperNext() {
                            if (this.__values__ === undefined) {
                                this.__values__ = toArray(this.value());
                            }
                            var done = this.__index__ >= this.__values__.length,
                                value = done ? undefined : this.__values__[this.__index__++];

                            return {
                                'done': done,
                                'value': value
                            };
                        }


                        function wrapperToIterator() {
                            return this;
                        }


                        function wrapperPlant(value) {
                            var result,
                                parent = this;

                            while (parent instanceof baseLodash) {
                                var clone = wrapperClone(parent);
                                clone.__index__ = 0;
                                clone.__values__ = undefined;
                                if (result) {
                                    previous.__wrapped__ = clone;
                                } else {
                                    result = clone;
                                }
                                var previous = clone;
                                parent = parent.__wrapped__;
                            }
                            previous.__wrapped__ = value;
                            return result;
                        }


                        function wrapperReverse() {
                            var value = this.__wrapped__;
                            if (value instanceof LazyWrapper) {
                                var wrapped = value;
                                if (this.__actions__.length) {
                                    wrapped = new LazyWrapper(this);
                                }
                                wrapped = wrapped.reverse();
                                wrapped.__actions__.push({
                                    'func': thru,
                                    'args': [reverse],
                                    'thisArg': undefined
                                });
                                return new LodashWrapper(wrapped, this.__chain__);
                            }
                            return this.thru(reverse);
                        }


                        function wrapperValue() {
                            return baseWrapperValue(this.__wrapped__, this.__actions__);
                        }




                        var countBy = createAggregator(function(result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                ++result[key];
                            } else {
                                baseAssignValue(result, key, 1);
                            }
                        });


                        function every(collection, predicate, guard) {
                            var func = isArray(collection) ? arrayEvery : baseEvery;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined;
                            }
                            return func(collection, getIteratee(predicate, 3));
                        }


                        function filter(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, getIteratee(predicate, 3));
                        }


                        var find = createFind(findIndex);


                        var findLast = createFind(findLastIndex);


                        function flatMap(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), 1);
                        }


                        function flatMapDeep(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), INFINITY);
                        }


                        function flatMapDepth(collection, iteratee, depth) {
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(map(collection, iteratee), depth);
                        }


                        function forEach(collection, iteratee) {
                            var func = isArray(collection) ? arrayEach : baseEach;
                            return func(collection, getIteratee(iteratee, 3));
                        }


                        function forEachRight(collection, iteratee) {
                            var func = isArray(collection) ? arrayEachRight : baseEachRight;
                            return func(collection, getIteratee(iteratee, 3));
                        }


                        var groupBy = createAggregator(function(result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                result[key].push(value);
                            } else {
                                baseAssignValue(result, key, [value]);
                            }
                        });


                        function includes(collection, value, fromIndex, guard) {
                            collection = isArrayLike(collection) ? collection : values(collection);
                            fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

                            var length = collection.length;
                            if (fromIndex < 0) {
                                fromIndex = nativeMax(length + fromIndex, 0);
                            }
                            return isString(collection) ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1) : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
                        }


                        var invokeMap = baseRest(function(collection, path, args) {
                            var index = -1,
                                isFunc = typeof path == 'function',
                                result = isArrayLike(collection) ? Array(collection.length) : [];

                            baseEach(collection, function(value) {
                                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                            });
                            return result;
                        });


                        var keyBy = createAggregator(function(result, value, key) {
                            baseAssignValue(result, key, value);
                        });


                        function map(collection, iteratee) {
                            var func = isArray(collection) ? arrayMap : baseMap;
                            return func(collection, getIteratee(iteratee, 3));
                        }


                        function orderBy(collection, iteratees, orders, guard) {
                            if (collection == null) {
                                return [];
                            }
                            if (!isArray(iteratees)) {
                                iteratees = iteratees == null ? [] : [iteratees];
                            }
                            orders = guard ? undefined : orders;
                            if (!isArray(orders)) {
                                orders = orders == null ? [] : [orders];
                            }
                            return baseOrderBy(collection, iteratees, orders);
                        }


                        var partition = createAggregator(function(result, value, key) {
                            result[key ? 0 : 1].push(value);
                        }, function() {
                            return [
                                [],
                                []
                            ];
                        });


                        function reduce(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduce : baseReduce,
                                initAccum = arguments.length < 3;

                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                        }


                        function reduceRight(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduceRight : baseReduce,
                                initAccum = arguments.length < 3;

                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
                        }


                        function reject(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, negate(getIteratee(predicate, 3)));
                        }


                        function sample(collection) {
                            var func = isArray(collection) ? arraySample : baseSample;
                            return func(collection);
                        }


                        function sampleSize(collection, n, guard) {
                            if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
                                n = 1;
                            } else {
                                n = toInteger(n);
                            }
                            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                            return func(collection, n);
                        }


                        function shuffle(collection) {
                            var func = isArray(collection) ? arrayShuffle : baseShuffle;
                            return func(collection);
                        }


                        function size(collection) {
                            if (collection == null) {
                                return 0;
                            }
                            if (isArrayLike(collection)) {
                                return isString(collection) ? stringSize(collection) : collection.length;
                            }
                            var tag = getTag(collection);
                            if (tag == mapTag || tag == setTag) {
                                return collection.size;
                            }
                            return baseKeys(collection).length;
                        }


                        function some(collection, predicate, guard) {
                            var func = isArray(collection) ? arraySome : baseSome;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined;
                            }
                            return func(collection, getIteratee(predicate, 3));
                        }


                        var sortBy = baseRest(function(collection, iteratees) {
                            if (collection == null) {
                                return [];
                            }
                            var length = iteratees.length;
                            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                                iteratees = [];
                            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                                iteratees = [iteratees[0]];
                            }
                            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                        });




                        var now = ctxNow || function() {
                            return root.Date.now();
                        };




                        function after(n, func) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            n = toInteger(n);
                            return function() {
                                if (--n < 1) {
                                    return func.apply(this, arguments);
                                }
                            };
                        }


                        function ary(func, n, guard) {
                            n = guard ? undefined : n;
                            n = (func && n == null) ? func.length : n;
                            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
                        }


                        function before(n, func) {
                            var result;
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            n = toInteger(n);
                            return function() {
                                if (--n > 0) {
                                    result = func.apply(this, arguments);
                                }
                                if (n <= 1) {
                                    func = undefined;
                                }
                                return result;
                            };
                        }


                        var bind = baseRest(function(func, thisArg, partials) {
                            var bitmask = WRAP_BIND_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bind));
                                bitmask |= WRAP_PARTIAL_FLAG;
                            }
                            return createWrap(func, bitmask, thisArg, partials, holders);
                        });


                        var bindKey = baseRest(function(object, key, partials) {
                            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bindKey));
                                bitmask |= WRAP_PARTIAL_FLAG;
                            }
                            return createWrap(key, bitmask, object, partials, holders);
                        });


                        function curry(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curry.placeholder;
                            return result;
                        }


                        function curryRight(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curryRight.placeholder;
                            return result;
                        }


                        function debounce(func, wait, options) {
                            var lastArgs,
                                lastThis,
                                maxWait,
                                result,
                                timerId,
                                lastCallTime,
                                lastInvokeTime = 0,
                                leading = false,
                                maxing = false,
                                trailing = true;

                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            wait = toNumber(wait) || 0;
                            if (isObject(options)) {
                                leading = !!options.leading;
                                maxing = 'maxWait' in options;
                                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                                trailing = 'trailing' in options ? !!options.trailing : trailing;
                            }

                            function invokeFunc(time) {
                                var args = lastArgs,
                                    thisArg = lastThis;

                                lastArgs = lastThis = undefined;
                                lastInvokeTime = time;
                                result = func.apply(thisArg, args);
                                return result;
                            }

                            function leadingEdge(time) {
                                // Reset any `maxWait` timer.
                                lastInvokeTime = time;
                                // Start the timer for the trailing edge.
                                timerId = setTimeout(timerExpired, wait);
                                // Invoke the leading edge.
                                return leading ? invokeFunc(time) : result;
                            }

                            function remainingWait(time) {
                                var timeSinceLastCall = time - lastCallTime,
                                    timeSinceLastInvoke = time - lastInvokeTime,
                                    result = wait - timeSinceLastCall;

                                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                            }

                            function shouldInvoke(time) {
                                var timeSinceLastCall = time - lastCallTime,
                                    timeSinceLastInvoke = time - lastInvokeTime;

                                // Either this is the first call, activity has stopped and we're at the
                                // trailing edge, the system time has gone backwards and we're treating
                                // it as the trailing edge, or we've hit the `maxWait` limit.
                                return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                                    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
                            }

                            function timerExpired() {
                                var time = now();
                                if (shouldInvoke(time)) {
                                    return trailingEdge(time);
                                }
                                // Restart the timer.
                                timerId = setTimeout(timerExpired, remainingWait(time));
                            }

                            function trailingEdge(time) {
                                timerId = undefined;

                                // Only invoke if we have `lastArgs` which means `func` has been
                                // debounced at least once.
                                if (trailing && lastArgs) {
                                    return invokeFunc(time);
                                }
                                lastArgs = lastThis = undefined;
                                return result;
                            }

                            function cancel() {
                                if (timerId !== undefined) {
                                    clearTimeout(timerId);
                                }
                                lastInvokeTime = 0;
                                lastArgs = lastCallTime = lastThis = timerId = undefined;
                            }

                            function flush() {
                                return timerId === undefined ? result : trailingEdge(now());
                            }

                            function debounced() {
                                var time = now(),
                                    isInvoking = shouldInvoke(time);

                                lastArgs = arguments;
                                lastThis = this;
                                lastCallTime = time;

                                if (isInvoking) {
                                    if (timerId === undefined) {
                                        return leadingEdge(lastCallTime);
                                    }
                                    if (maxing) {
                                        // Handle invocations in a tight loop.
                                        timerId = setTimeout(timerExpired, wait);
                                        return invokeFunc(lastCallTime);
                                    }
                                }
                                if (timerId === undefined) {
                                    timerId = setTimeout(timerExpired, wait);
                                }
                                return result;
                            }
                            debounced.cancel = cancel;
                            debounced.flush = flush;
                            return debounced;
                        }


                        var defer = baseRest(function(func, args) {
                            return baseDelay(func, 1, args);
                        });


                        var delay = baseRest(function(func, wait, args) {
                            return baseDelay(func, toNumber(wait) || 0, args);
                        });


                        function flip(func) {
                            return createWrap(func, WRAP_FLIP_FLAG);
                        }


                        function memoize(func, resolver) {
                            if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            var memoized = function() {
                                var args = arguments,
                                    key = resolver ? resolver.apply(this, args) : args[0],
                                    cache = memoized.cache;

                                if (cache.has(key)) {
                                    return cache.get(key);
                                }
                                var result = func.apply(this, args);
                                memoized.cache = cache.set(key, result) || cache;
                                return result;
                            };
                            memoized.cache = new(memoize.Cache || MapCache);
                            return memoized;
                        }

                        // Expose `MapCache`.
                        memoize.Cache = MapCache;


                        function negate(predicate) {
                            if (typeof predicate != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return function() {
                                var args = arguments;
                                switch (args.length) {
                                    case 0:
                                        return !predicate.call(this);
                                    case 1:
                                        return !predicate.call(this, args[0]);
                                    case 2:
                                        return !predicate.call(this, args[0], args[1]);
                                    case 3:
                                        return !predicate.call(this, args[0], args[1], args[2]);
                                }
                                return !predicate.apply(this, args);
                            };
                        }


                        function once(func) {
                            return before(2, func);
                        }


                        var overArgs = castRest(function(func, transforms) {
                            transforms = (transforms.length == 1 && isArray(transforms[0])) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

                            var funcsLength = transforms.length;
                            return baseRest(function(args) {
                                var index = -1,
                                    length = nativeMin(args.length, funcsLength);

                                while (++index < length) {
                                    args[index] = transforms[index].call(this, args[index]);
                                }
                                return apply(func, this, args);
                            });
                        });


                        var partial = baseRest(function(func, partials) {
                            var holders = replaceHolders(partials, getHolder(partial));
                            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
                        });


                        var partialRight = baseRest(function(func, partials) {
                            var holders = replaceHolders(partials, getHolder(partialRight));
                            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                        });


                        var rearg = flatRest(function(func, indexes) {
                            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
                        });


                        function rest(func, start) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            start = start === undefined ? start : toInteger(start);
                            return baseRest(func, start);
                        }


                        function spread(func, start) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
                            return baseRest(function(args) {
                                var array = args[start],
                                    otherArgs = castSlice(args, 0, start);

                                if (array) {
                                    arrayPush(otherArgs, array);
                                }
                                return apply(func, this, otherArgs);
                            });
                        }


                        function throttle(func, wait, options) {
                            var leading = true,
                                trailing = true;

                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            if (isObject(options)) {
                                leading = 'leading' in options ? !!options.leading : leading;
                                trailing = 'trailing' in options ? !!options.trailing : trailing;
                            }
                            return debounce(func, wait, {
                                'leading': leading,
                                'maxWait': wait,
                                'trailing': trailing
                            });
                        }


                        function unary(func) {
                            return ary(func, 1);
                        }


                        function wrap(value, wrapper) {
                            return partial(castFunction(wrapper), value);
                        }




                        function castArray() {
                            if (!arguments.length) {
                                return [];
                            }
                            var value = arguments[0];
                            return isArray(value) ? value : [value];
                        }


                        function clone(value) {
                            return baseClone(value, CLONE_SYMBOLS_FLAG);
                        }


                        function cloneWith(value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                        }


                        function cloneDeep(value) {
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                        }


                        function cloneDeepWith(value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                        }


                        function conformsTo(object, source) {
                            return source == null || baseConformsTo(object, source, keys(source));
                        }


                        function eq(value, other) {
                            return value === other || (value !== value && other !== other);
                        }


                        var gt = createRelationalOperation(baseGt);


                        var gte = createRelationalOperation(function(value, other) {
                            return value >= other;
                        });


                        var isArguments = baseIsArguments(function() {
                            return arguments;
                        }()) ? baseIsArguments : function(value) {
                            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
                                !propertyIsEnumerable.call(value, 'callee');
                        };


                        var isArray = Array.isArray;


                        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;


                        function isArrayLike(value) {
                            return value != null && isLength(value.length) && !isFunction(value);
                        }


                        function isArrayLikeObject(value) {
                            return isObjectLike(value) && isArrayLike(value);
                        }


                        function isBoolean(value) {
                            return value === true || value === false ||
                                (isObjectLike(value) && baseGetTag(value) == boolTag);
                        }


                        var isBuffer = nativeIsBuffer || stubFalse;


                        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;


                        function isElement(value) {
                            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                        }


                        function isEmpty(value) {
                            if (value == null) {
                                return true;
                            }
                            if (isArrayLike(value) &&
                                (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                                    isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                                return !value.length;
                            }
                            var tag = getTag(value);
                            if (tag == mapTag || tag == setTag) {
                                return !value.size;
                            }
                            if (isPrototype(value)) {
                                return !baseKeys(value).length;
                            }
                            for (var key in value) {
                                if (hasOwnProperty.call(value, key)) {
                                    return false;
                                }
                            }
                            return true;
                        }


                        function isEqual(value, other) {
                            return baseIsEqual(value, other);
                        }


                        function isEqualWith(value, other, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            var result = customizer ? customizer(value, other) : undefined;
                            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
                        }


                        function isError(value) {
                            if (!isObjectLike(value)) {
                                return false;
                            }
                            var tag = baseGetTag(value);
                            return tag == errorTag || tag == domExcTag ||
                                (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
                        }


                        function isFinite(value) {
                            return typeof value == 'number' && nativeIsFinite(value);
                        }


                        function isFunction(value) {
                            if (!isObject(value)) {
                                return false;
                            }
                            // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 9 which returns 'object' for typed arrays and other constructors.
                            var tag = baseGetTag(value);
                            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                        }


                        function isInteger(value) {
                            return typeof value == 'number' && value == toInteger(value);
                        }


                        function isLength(value) {
                            return typeof value == 'number' &&
                                value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                        }


                        function isObject(value) {
                            var type = typeof value;
                            return value != null && (type == 'object' || type == 'function');
                        }


                        function isObjectLike(value) {
                            return value != null && typeof value == 'object';
                        }


                        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;


                        function isMatch(object, source) {
                            return object === source || baseIsMatch(object, source, getMatchData(source));
                        }


                        function isMatchWith(object, source, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseIsMatch(object, source, getMatchData(source), customizer);
                        }


                        function isNaN(value) {
                            // An `NaN` primitive is the only value that is not equal to itself.
                            // Perform the `toStringTag` check first to avoid errors with some
                            // ActiveX objects in IE.
                            return isNumber(value) && value != +value;
                        }


                        function isNative(value) {
                            if (isMaskable(value)) {
                                throw new Error(CORE_ERROR_TEXT);
                            }
                            return baseIsNative(value);
                        }


                        function isNull(value) {
                            return value === null;
                        }


                        function isNil(value) {
                            return value == null;
                        }


                        function isNumber(value) {
                            return typeof value == 'number' ||
                                (isObjectLike(value) && baseGetTag(value) == numberTag);
                        }


                        function isPlainObject(value) {
                            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                                return false;
                            }
                            var proto = getPrototype(value);
                            if (proto === null) {
                                return true;
                            }
                            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                            return typeof Ctor == 'function' && Ctor instanceof Ctor &&
                                funcToString.call(Ctor) == objectCtorString;
                        }


                        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;


                        function isSafeInteger(value) {
                            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                        }


                        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;


                        function isString(value) {
                            return typeof value == 'string' ||
                                (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
                        }


                        function isSymbol(value) {
                            return typeof value == 'symbol' ||
                                (isObjectLike(value) && baseGetTag(value) == symbolTag);
                        }


                        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;


                        function isUndefined(value) {
                            return value === undefined;
                        }


                        function isWeakMap(value) {
                            return isObjectLike(value) && getTag(value) == weakMapTag;
                        }


                        function isWeakSet(value) {
                            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                        }


                        var lt = createRelationalOperation(baseLt);


                        var lte = createRelationalOperation(function(value, other) {
                            return value <= other;
                        });


                        function toArray(value) {
                            if (!value) {
                                return [];
                            }
                            if (isArrayLike(value)) {
                                return isString(value) ? stringToArray(value) : copyArray(value);
                            }
                            if (symIterator && value[symIterator]) {
                                return iteratorToArray(value[symIterator]());
                            }
                            var tag = getTag(value),
                                func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

                            return func(value);
                        }


                        function toFinite(value) {
                            if (!value) {
                                return value === 0 ? value : 0;
                            }
                            value = toNumber(value);
                            if (value === INFINITY || value === -INFINITY) {
                                var sign = (value < 0 ? -1 : 1);
                                return sign * MAX_INTEGER;
                            }
                            return value === value ? value : 0;
                        }


                        function toInteger(value) {
                            var result = toFinite(value),
                                remainder = result % 1;

                            return result === result ? (remainder ? result - remainder : result) : 0;
                        }


                        function toLength(value) {
                            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                        }


                        function toNumber(value) {
                            if (typeof value == 'number') {
                                return value;
                            }
                            if (isSymbol(value)) {
                                return NAN;
                            }
                            if (isObject(value)) {
                                var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                                value = isObject(other) ? (other + '') : other;
                            }
                            if (typeof value != 'string') {
                                return value === 0 ? value : +value;
                            }
                            value = value.replace(reTrim, '');
                            var isBinary = reIsBinary.test(value);
                            return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value);
                        }


                        function toPlainObject(value) {
                            return copyObject(value, keysIn(value));
                        }


                        function toSafeInteger(value) {
                            return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
                        }


                        function toString(value) {
                            return value == null ? '' : baseToString(value);
                        }




                        var assign = createAssigner(function(object, source) {
                            if (isPrototype(source) || isArrayLike(source)) {
                                copyObject(source, keys(source), object);
                                return;
                            }
                            for (var key in source) {
                                if (hasOwnProperty.call(source, key)) {
                                    assignValue(object, key, source[key]);
                                }
                            }
                        });


                        var assignIn = createAssigner(function(object, source) {
                            copyObject(source, keysIn(source), object);
                        });


                        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                            copyObject(source, keysIn(source), object, customizer);
                        });


                        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                            copyObject(source, keys(source), object, customizer);
                        });


                        var at = flatRest(baseAt);


                        function create(prototype, properties) {
                            var result = baseCreate(prototype);
                            return properties == null ? result : baseAssign(result, properties);
                        }


                        var defaults = baseRest(function(args) {
                            args.push(undefined, assignInDefaults);
                            return apply(assignInWith, undefined, args);
                        });


                        var defaultsDeep = baseRest(function(args) {
                            args.push(undefined, mergeDefaults);
                            return apply(mergeWith, undefined, args);
                        });


                        function findKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                        }


                        function findLastKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                        }


                        function forIn(object, iteratee) {
                            return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
                        }


                        function forInRight(object, iteratee) {
                            return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
                        }


                        function forOwn(object, iteratee) {
                            return object && baseForOwn(object, getIteratee(iteratee, 3));
                        }


                        function forOwnRight(object, iteratee) {
                            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
                        }


                        function functions(object) {
                            return object == null ? [] : baseFunctions(object, keys(object));
                        }


                        function functionsIn(object) {
                            return object == null ? [] : baseFunctions(object, keysIn(object));
                        }


                        function get(object, path, defaultValue) {
                            var result = object == null ? undefined : baseGet(object, path);
                            return result === undefined ? defaultValue : result;
                        }


                        function has(object, path) {
                            return object != null && hasPath(object, path, baseHas);
                        }


                        function hasIn(object, path) {
                            return object != null && hasPath(object, path, baseHasIn);
                        }


                        var invert = createInverter(function(result, value, key) {
                            result[value] = key;
                        }, constant(identity));


                        var invertBy = createInverter(function(result, value, key) {
                            if (hasOwnProperty.call(result, value)) {
                                result[value].push(key);
                            } else {
                                result[value] = [key];
                            }
                        }, getIteratee);


                        var invoke = baseRest(baseInvoke);


                        function keys(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                        }


                        function keysIn(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                        }


                        function mapKeys(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);

                            baseForOwn(object, function(value, key, object) {
                                baseAssignValue(result, iteratee(value, key, object), value);
                            });
                            return result;
                        }


                        function mapValues(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);

                            baseForOwn(object, function(value, key, object) {
                                baseAssignValue(result, key, iteratee(value, key, object));
                            });
                            return result;
                        }


                        var merge = createAssigner(function(object, source, srcIndex) {
                            baseMerge(object, source, srcIndex);
                        });


                        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                            baseMerge(object, source, srcIndex, customizer);
                        });


                        var omit = flatRest(function(object, paths) {
                            var result = {};
                            if (object == null) {
                                return result;
                            }
                            var isDeep = false;
                            paths = arrayMap(paths, function(path) {
                                path = castPath(path, object);
                                isDeep || (isDeep = path.length > 1);
                                return path;
                            });
                            copyObject(object, getAllKeysIn(object), result);
                            if (isDeep) {
                                result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG);
                            }
                            var length = paths.length;
                            while (length--) {
                                baseUnset(result, paths[length]);
                            }
                            return result;
                        });


                        function omitBy(object, predicate) {
                            return pickBy(object, negate(getIteratee(predicate)));
                        }


                        var pick = flatRest(function(object, paths) {
                            return object == null ? {} : basePick(object, paths);
                        });


                        function pickBy(object, predicate) {
                            if (object == null) {
                                return {};
                            }
                            var props = arrayMap(getAllKeysIn(object), function(prop) {
                                return [prop];
                            });
                            predicate = getIteratee(predicate);
                            return basePickBy(object, props, function(value, path) {
                                return predicate(value, path[0]);
                            });
                        }


                        function result(object, path, defaultValue) {
                            path = castPath(path, object);

                            var index = -1,
                                length = path.length;

                            // Ensure the loop is entered when path is empty.
                            if (!length) {
                                length = 1;
                                object = undefined;
                            }
                            while (++index < length) {
                                var value = object == null ? undefined : object[toKey(path[index])];
                                if (value === undefined) {
                                    index = length;
                                    value = defaultValue;
                                }
                                object = isFunction(value) ? value.call(object) : value;
                            }
                            return object;
                        }


                        function set(object, path, value) {
                            return object == null ? object : baseSet(object, path, value);
                        }


                        function setWith(object, path, value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return object == null ? object : baseSet(object, path, value, customizer);
                        }


                        var toPairs = createToPairs(keys);


                        var toPairsIn = createToPairs(keysIn);


                        function transform(object, iteratee, accumulator) {
                            var isArr = isArray(object),
                                isArrLike = isArr || isBuffer(object) || isTypedArray(object);

                            iteratee = getIteratee(iteratee, 4);
                            if (accumulator == null) {
                                var Ctor = object && object.constructor;
                                if (isArrLike) {
                                    accumulator = isArr ? new Ctor : [];
                                } else if (isObject(object)) {
                                    accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                                } else {
                                    accumulator = {};
                                }
                            }
                            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                                return iteratee(accumulator, value, index, object);
                            });
                            return accumulator;
                        }


                        function unset(object, path) {
                            return object == null ? true : baseUnset(object, path);
                        }


                        function update(object, path, updater) {
                            return object == null ? object : baseUpdate(object, path, castFunction(updater));
                        }


                        function updateWith(object, path, updater, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                        }


                        function values(object) {
                            return object == null ? [] : baseValues(object, keys(object));
                        }


                        function valuesIn(object) {
                            return object == null ? [] : baseValues(object, keysIn(object));
                        }




                        function clamp(number, lower, upper) {
                            if (upper === undefined) {
                                upper = lower;
                                lower = undefined;
                            }
                            if (upper !== undefined) {
                                upper = toNumber(upper);
                                upper = upper === upper ? upper : 0;
                            }
                            if (lower !== undefined) {
                                lower = toNumber(lower);
                                lower = lower === lower ? lower : 0;
                            }
                            return baseClamp(toNumber(number), lower, upper);
                        }


                        function inRange(number, start, end) {
                            start = toFinite(start);
                            if (end === undefined) {
                                end = start;
                                start = 0;
                            } else {
                                end = toFinite(end);
                            }
                            number = toNumber(number);
                            return baseInRange(number, start, end);
                        }


                        function random(lower, upper, floating) {
                            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                                upper = floating = undefined;
                            }
                            if (floating === undefined) {
                                if (typeof upper == 'boolean') {
                                    floating = upper;
                                    upper = undefined;
                                } else if (typeof lower == 'boolean') {
                                    floating = lower;
                                    lower = undefined;
                                }
                            }
                            if (lower === undefined && upper === undefined) {
                                lower = 0;
                                upper = 1;
                            } else {
                                lower = toFinite(lower);
                                if (upper === undefined) {
                                    upper = lower;
                                    lower = 0;
                                } else {
                                    upper = toFinite(upper);
                                }
                            }
                            if (lower > upper) {
                                var temp = lower;
                                lower = upper;
                                upper = temp;
                            }
                            if (floating || lower % 1 || upper % 1) {
                                var rand = nativeRandom();
                                return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
                            }
                            return baseRandom(lower, upper);
                        }




                        var camelCase = createCompounder(function(result, word, index) {
                            word = word.toLowerCase();
                            return result + (index ? capitalize(word) : word);
                        });


                        function capitalize(string) {
                            return upperFirst(toString(string).toLowerCase());
                        }


                        function deburr(string) {
                            string = toString(string);
                            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
                        }


                        function endsWith(string, target, position) {
                            string = toString(string);
                            target = baseToString(target);

                            var length = string.length;
                            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);

                            var end = position;
                            position -= target.length;
                            return position >= 0 && string.slice(position, end) == target;
                        }


                        function escape(string) {
                            string = toString(string);
                            return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                        }


                        function escapeRegExp(string) {
                            string = toString(string);
                            return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string;
                        }


                        var kebabCase = createCompounder(function(result, word, index) {
                            return result + (index ? '-' : '') + word.toLowerCase();
                        });


                        var lowerCase = createCompounder(function(result, word, index) {
                            return result + (index ? ' ' : '') + word.toLowerCase();
                        });


                        var lowerFirst = createCaseFirst('toLowerCase');


                        function pad(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);

                            var strLength = length ? stringSize(string) : 0;
                            if (!length || strLength >= length) {
                                return string;
                            }
                            var mid = (length - strLength) / 2;
                            return (
                                createPadding(nativeFloor(mid), chars) +
                                string +
                                createPadding(nativeCeil(mid), chars)
                            );
                        }


                        function padEnd(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);

                            var strLength = length ? stringSize(string) : 0;
                            return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string;
                        }


                        function padStart(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);

                            var strLength = length ? stringSize(string) : 0;
                            return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string;
                        }


                        function parseInt(string, radix, guard) {
                            if (guard || radix == null) {
                                radix = 0;
                            } else if (radix) {
                                radix = +radix;
                            }
                            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
                        }


                        function repeat(string, n, guard) {
                            if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
                                n = 1;
                            } else {
                                n = toInteger(n);
                            }
                            return baseRepeat(toString(string), n);
                        }


                        function replace() {
                            var args = arguments,
                                string = toString(args[0]);

                            return args.length < 3 ? string : string.replace(args[1], args[2]);
                        }


                        var snakeCase = createCompounder(function(result, word, index) {
                            return result + (index ? '_' : '') + word.toLowerCase();
                        });


                        function split(string, separator, limit) {
                            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                                separator = limit = undefined;
                            }
                            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                            if (!limit) {
                                return [];
                            }
                            string = toString(string);
                            if (string && (
                                    typeof separator == 'string' ||
                                    (separator != null && !isRegExp(separator))
                                )) {
                                separator = baseToString(separator);
                                if (!separator && hasUnicode(string)) {
                                    return castSlice(stringToArray(string), 0, limit);
                                }
                            }
                            return string.split(separator, limit);
                        }


                        var startCase = createCompounder(function(result, word, index) {
                            return result + (index ? ' ' : '') + upperFirst(word);
                        });


                        function startsWith(string, target, position) {
                            string = toString(string);
                            position = baseClamp(toInteger(position), 0, string.length);
                            target = baseToString(target);
                            return string.slice(position, position + target.length) == target;
                        }


                        function template(string, options, guard) {
                            // Based on John Resig's `tmpl` implementation
                            // (http://ejohn.org/blog/javascript-micro-templating/)
                            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                            var settings = lodash.templateSettings;

                            if (guard && isIterateeCall(string, options, guard)) {
                                options = undefined;
                            }
                            string = toString(string);
                            options = assignInWith({}, options, settings, assignInDefaults);

                            var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
                                importsKeys = keys(imports),
                                importsValues = baseValues(imports, importsKeys);

                            var isEscaping,
                                isEvaluating,
                                index = 0,
                                interpolate = options.interpolate || reNoMatch,
                                source = "__p += '";

                            // Compile the regexp to match each delimiter.
                            var reDelimiters = RegExp(
                                (options.escape || reNoMatch).source + '|' +
                                interpolate.source + '|' +
                                (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                                (options.evaluate || reNoMatch).source + '|$', 'g');

                            // Use a sourceURL for easier debugging.
                            var sourceURL = '//# sourceURL=' +
                                ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';

                            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                                interpolateValue || (interpolateValue = esTemplateValue);

                                // Escape characters that can't be included in string literals.
                                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                                // Replace delimiters with snippets.
                                if (escapeValue) {
                                    isEscaping = true;
                                    source += "' +\n__e(" + escapeValue + ") +\n'";
                                }
                                if (evaluateValue) {
                                    isEvaluating = true;
                                    source += "';\n" + evaluateValue + ";\n__p += '";
                                }
                                if (interpolateValue) {
                                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                                }
                                index = offset + match.length;

                                // The JS engine embedded in Adobe products needs `match` returned in
                                // order to produce the correct `offset` value.
                                return match;
                            });

                            source += "';\n";

                            // If `variable` is not specified wrap a with-statement around the generated
                            // code to add the data object to the top of the scope chain.
                            var variable = options.variable;
                            if (!variable) {
                                source = 'with (obj) {\n' + source + '\n}\n';
                            }
                            // Cleanup code by stripping empty strings.
                            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                                .replace(reEmptyStringMiddle, '$1')
                                .replace(reEmptyStringTrailing, '$1;');

                            // Frame code as the function body.
                            source = 'function(' + (variable || 'obj') + ') {\n' +
                                (variable ? '' : 'obj || (obj = {});\n') +
                                "var __t, __p = ''" +
                                (isEscaping ? ', __e = _.escape' : '') +
                                (isEvaluating ? ', __j = Array.prototype.join;\n' +
                                    "function print() { __p += __j.call(arguments, '') }\n" : ';\n'
                                ) +
                                source +
                                'return __p\n}';

                            var result = attempt(function() {
                                return Function(importsKeys, sourceURL + 'return ' + source)
                                    .apply(undefined, importsValues);
                            });

                            // Provide the compiled function's source by its `toString` method or
                            // the `source` property as a convenience for inlining compiled templates.
                            result.source = source;
                            if (isError(result)) {
                                throw result;
                            }
                            return result;
                        }


                        function toLower(value) {
                            return toString(value).toLowerCase();
                        }


                        function toUpper(value) {
                            return toString(value).toUpperCase();
                        }


                        function trim(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrim, '');
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string),
                                chrSymbols = stringToArray(chars),
                                start = charsStartIndex(strSymbols, chrSymbols),
                                end = charsEndIndex(strSymbols, chrSymbols) + 1;

                            return castSlice(strSymbols, start, end).join('');
                        }


                        function trimEnd(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrimEnd, '');
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string),
                                end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

                            return castSlice(strSymbols, 0, end).join('');
                        }


                        function trimStart(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrimStart, '');
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string),
                                start = charsStartIndex(strSymbols, stringToArray(chars));

                            return castSlice(strSymbols, start).join('');
                        }


                        function truncate(string, options) {
                            var length = DEFAULT_TRUNC_LENGTH,
                                omission = DEFAULT_TRUNC_OMISSION;

                            if (isObject(options)) {
                                var separator = 'separator' in options ? options.separator : separator;
                                length = 'length' in options ? toInteger(options.length) : length;
                                omission = 'omission' in options ? baseToString(options.omission) : omission;
                            }
                            string = toString(string);

                            var strLength = string.length;
                            if (hasUnicode(string)) {
                                var strSymbols = stringToArray(string);
                                strLength = strSymbols.length;
                            }
                            if (length >= strLength) {
                                return string;
                            }
                            var end = length - stringSize(omission);
                            if (end < 1) {
                                return omission;
                            }
                            var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

                            if (separator === undefined) {
                                return result + omission;
                            }
                            if (strSymbols) {
                                end += (result.length - end);
                            }
                            if (isRegExp(separator)) {
                                if (string.slice(end).search(separator)) {
                                    var match,
                                        substring = result;

                                    if (!separator.global) {
                                        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                                    }
                                    separator.lastIndex = 0;
                                    while ((match = separator.exec(substring))) {
                                        var newEnd = match.index;
                                    }
                                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                                }
                            } else if (string.indexOf(baseToString(separator), end) != end) {
                                var index = result.lastIndexOf(separator);
                                if (index > -1) {
                                    result = result.slice(0, index);
                                }
                            }
                            return result + omission;
                        }


                        function unescape(string) {
                            string = toString(string);
                            return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                        }


                        var upperCase = createCompounder(function(result, word, index) {
                            return result + (index ? ' ' : '') + word.toUpperCase();
                        });


                        var upperFirst = createCaseFirst('toUpperCase');


                        function words(string, pattern, guard) {
                            string = toString(string);
                            pattern = guard ? undefined : pattern;

                            if (pattern === undefined) {
                                return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                            }
                            return string.match(pattern) || [];
                        }




                        var attempt = baseRest(function(func, args) {
                            try {
                                return apply(func, undefined, args);
                            } catch (e) {
                                return isError(e) ? e : new Error(e);
                            }
                        });


                        var bindAll = flatRest(function(object, methodNames) {
                            arrayEach(methodNames, function(key) {
                                key = toKey(key);
                                baseAssignValue(object, key, bind(object[key], object));
                            });
                            return object;
                        });


                        function cond(pairs) {
                            var length = pairs == null ? 0 : pairs.length,
                                toIteratee = getIteratee();

                            pairs = !length ? [] : arrayMap(pairs, function(pair) {
                                if (typeof pair[1] != 'function') {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                return [toIteratee(pair[0]), pair[1]];
                            });

                            return baseRest(function(args) {
                                var index = -1;
                                while (++index < length) {
                                    var pair = pairs[index];
                                    if (apply(pair[0], this, args)) {
                                        return apply(pair[1], this, args);
                                    }
                                }
                            });
                        }


                        function conforms(source) {
                            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                        }


                        function constant(value) {
                            return function() {
                                return value;
                            };
                        }


                        function defaultTo(value, defaultValue) {
                            return (value == null || value !== value) ? defaultValue : value;
                        }


                        var flow = createFlow();


                        var flowRight = createFlow(true);


                        function identity(value) {
                            return value;
                        }


                        function iteratee(func) {
                            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
                        }


                        function matches(source) {
                            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                        }


                        function matchesProperty(path, srcValue) {
                            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                        }


                        var method = baseRest(function(path, args) {
                            return function(object) {
                                return baseInvoke(object, path, args);
                            };
                        });


                        var methodOf = baseRest(function(object, args) {
                            return function(path) {
                                return baseInvoke(object, path, args);
                            };
                        });


                        function mixin(object, source, options) {
                            var props = keys(source),
                                methodNames = baseFunctions(source, props);

                            if (options == null &&
                                !(isObject(source) && (methodNames.length || !props.length))) {
                                options = source;
                                source = object;
                                object = this;
                                methodNames = baseFunctions(source, keys(source));
                            }
                            var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
                                isFunc = isFunction(object);

                            arrayEach(methodNames, function(methodName) {
                                var func = source[methodName];
                                object[methodName] = func;
                                if (isFunc) {
                                    object.prototype[methodName] = function() {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__),
                                                actions = result.__actions__ = copyArray(this.__actions__);

                                            actions.push({
                                                'func': func,
                                                'args': arguments,
                                                'thisArg': object
                                            });
                                            result.__chain__ = chainAll;
                                            return result;
                                        }
                                        return func.apply(object, arrayPush([this.value()], arguments));
                                    };
                                }
                            });

                            return object;
                        }


                        function noConflict() {
                            if (root._ === this) {
                                root._ = oldDash;
                            }
                            return this;
                        }


                        function noop() {
                            // No operation performed.
                        }


                        function nthArg(n) {
                            n = toInteger(n);
                            return baseRest(function(args) {
                                return baseNth(args, n);
                            });
                        }


                        var over = createOver(arrayMap);


                        var overEvery = createOver(arrayEvery);


                        var overSome = createOver(arraySome);


                        function property(path) {
                            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                        }


                        function propertyOf(object) {
                            return function(path) {
                                return object == null ? undefined : baseGet(object, path);
                            };
                        }


                        var range = createRange();


                        var rangeRight = createRange(true);


                        function stubArray() {
                            return [];
                        }


                        function stubFalse() {
                            return false;
                        }


                        function stubObject() {
                            return {};
                        }


                        function stubString() {
                            return '';
                        }


                        function stubTrue() {
                            return true;
                        }


                        function times(n, iteratee) {
                            n = toInteger(n);
                            if (n < 1 || n > MAX_SAFE_INTEGER) {
                                return [];
                            }
                            var index = MAX_ARRAY_LENGTH,
                                length = nativeMin(n, MAX_ARRAY_LENGTH);

                            iteratee = getIteratee(iteratee);
                            n -= MAX_ARRAY_LENGTH;

                            var result = baseTimes(length, iteratee);
                            while (++index < n) {
                                iteratee(index);
                            }
                            return result;
                        }


                        function toPath(value) {
                            if (isArray(value)) {
                                return arrayMap(value, toKey);
                            }
                            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
                        }


                        function uniqueId(prefix) {
                            var id = ++idCounter;
                            return toString(prefix) + id;
                        }




                        var add = createMathOperation(function(augend, addend) {
                            return augend + addend;
                        }, 0);


                        var ceil = createRound('ceil');


                        var divide = createMathOperation(function(dividend, divisor) {
                            return dividend / divisor;
                        }, 1);


                        var floor = createRound('floor');


                        function max(array) {
                            return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined;
                        }


                        function maxBy(array, iteratee) {
                            return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
                        }


                        function mean(array) {
                            return baseMean(array, identity);
                        }


                        function meanBy(array, iteratee) {
                            return baseMean(array, getIteratee(iteratee, 2));
                        }


                        function min(array) {
                            return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined;
                        }


                        function minBy(array, iteratee) {
                            return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
                        }


                        var multiply = createMathOperation(function(multiplier, multiplicand) {
                            return multiplier * multiplicand;
                        }, 1);


                        var round = createRound('round');


                        var subtract = createMathOperation(function(minuend, subtrahend) {
                            return minuend - subtrahend;
                        }, 0);


                        function sum(array) {
                            return (array && array.length) ? baseSum(array, identity) : 0;
                        }


                        function sumBy(array, iteratee) {
                            return (array && array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0;
                        }



                        // Add methods that return wrapped values in chain sequences.
                        lodash.after = after;
                        lodash.ary = ary;
                        lodash.assign = assign;
                        lodash.assignIn = assignIn;
                        lodash.assignInWith = assignInWith;
                        lodash.assignWith = assignWith;
                        lodash.at = at;
                        lodash.before = before;
                        lodash.bind = bind;
                        lodash.bindAll = bindAll;
                        lodash.bindKey = bindKey;
                        lodash.castArray = castArray;
                        lodash.chain = chain;
                        lodash.chunk = chunk;
                        lodash.compact = compact;
                        lodash.concat = concat;
                        lodash.cond = cond;
                        lodash.conforms = conforms;
                        lodash.constant = constant;
                        lodash.countBy = countBy;
                        lodash.create = create;
                        lodash.curry = curry;
                        lodash.curryRight = curryRight;
                        lodash.debounce = debounce;
                        lodash.defaults = defaults;
                        lodash.defaultsDeep = defaultsDeep;
                        lodash.defer = defer;
                        lodash.delay = delay;
                        lodash.difference = difference;
                        lodash.differenceBy = differenceBy;
                        lodash.differenceWith = differenceWith;
                        lodash.drop = drop;
                        lodash.dropRight = dropRight;
                        lodash.dropRightWhile = dropRightWhile;
                        lodash.dropWhile = dropWhile;
                        lodash.fill = fill;
                        lodash.filter = filter;
                        lodash.flatMap = flatMap;
                        lodash.flatMapDeep = flatMapDeep;
                        lodash.flatMapDepth = flatMapDepth;
                        lodash.flatten = flatten;
                        lodash.flattenDeep = flattenDeep;
                        lodash.flattenDepth = flattenDepth;
                        lodash.flip = flip;
                        lodash.flow = flow;
                        lodash.flowRight = flowRight;
                        lodash.fromPairs = fromPairs;
                        lodash.functions = functions;
                        lodash.functionsIn = functionsIn;
                        lodash.groupBy = groupBy;
                        lodash.initial = initial;
                        lodash.intersection = intersection;
                        lodash.intersectionBy = intersectionBy;
                        lodash.intersectionWith = intersectionWith;
                        lodash.invert = invert;
                        lodash.invertBy = invertBy;
                        lodash.invokeMap = invokeMap;
                        lodash.iteratee = iteratee;
                        lodash.keyBy = keyBy;
                        lodash.keys = keys;
                        lodash.keysIn = keysIn;
                        lodash.map = map;
                        lodash.mapKeys = mapKeys;
                        lodash.mapValues = mapValues;
                        lodash.matches = matches;
                        lodash.matchesProperty = matchesProperty;
                        lodash.memoize = memoize;
                        lodash.merge = merge;
                        lodash.mergeWith = mergeWith;
                        lodash.method = method;
                        lodash.methodOf = methodOf;
                        lodash.mixin = mixin;
                        lodash.negate = negate;
                        lodash.nthArg = nthArg;
                        lodash.omit = omit;
                        lodash.omitBy = omitBy;
                        lodash.once = once;
                        lodash.orderBy = orderBy;
                        lodash.over = over;
                        lodash.overArgs = overArgs;
                        lodash.overEvery = overEvery;
                        lodash.overSome = overSome;
                        lodash.partial = partial;
                        lodash.partialRight = partialRight;
                        lodash.partition = partition;
                        lodash.pick = pick;
                        lodash.pickBy = pickBy;
                        lodash.property = property;
                        lodash.propertyOf = propertyOf;
                        lodash.pull = pull;
                        lodash.pullAll = pullAll;
                        lodash.pullAllBy = pullAllBy;
                        lodash.pullAllWith = pullAllWith;
                        lodash.pullAt = pullAt;
                        lodash.range = range;
                        lodash.rangeRight = rangeRight;
                        lodash.rearg = rearg;
                        lodash.reject = reject;
                        lodash.remove = remove;
                        lodash.rest = rest;
                        lodash.reverse = reverse;
                        lodash.sampleSize = sampleSize;
                        lodash.set = set;
                        lodash.setWith = setWith;
                        lodash.shuffle = shuffle;
                        lodash.slice = slice;
                        lodash.sortBy = sortBy;
                        lodash.sortedUniq = sortedUniq;
                        lodash.sortedUniqBy = sortedUniqBy;
                        lodash.split = split;
                        lodash.spread = spread;
                        lodash.tail = tail;
                        lodash.take = take;
                        lodash.takeRight = takeRight;
                        lodash.takeRightWhile = takeRightWhile;
                        lodash.takeWhile = takeWhile;
                        lodash.tap = tap;
                        lodash.throttle = throttle;
                        lodash.thru = thru;
                        lodash.toArray = toArray;
                        lodash.toPairs = toPairs;
                        lodash.toPairsIn = toPairsIn;
                        lodash.toPath = toPath;
                        lodash.toPlainObject = toPlainObject;
                        lodash.transform = transform;
                        lodash.unary = unary;
                        lodash.union = union;
                        lodash.unionBy = unionBy;
                        lodash.unionWith = unionWith;
                        lodash.uniq = uniq;
                        lodash.uniqBy = uniqBy;
                        lodash.uniqWith = uniqWith;
                        lodash.unset = unset;
                        lodash.unzip = unzip;
                        lodash.unzipWith = unzipWith;
                        lodash.update = update;
                        lodash.updateWith = updateWith;
                        lodash.values = values;
                        lodash.valuesIn = valuesIn;
                        lodash.without = without;
                        lodash.words = words;
                        lodash.wrap = wrap;
                        lodash.xor = xor;
                        lodash.xorBy = xorBy;
                        lodash.xorWith = xorWith;
                        lodash.zip = zip;
                        lodash.zipObject = zipObject;
                        lodash.zipObjectDeep = zipObjectDeep;
                        lodash.zipWith = zipWith;

                        // Add aliases.
                        lodash.entries = toPairs;
                        lodash.entriesIn = toPairsIn;
                        lodash.extend = assignIn;
                        lodash.extendWith = assignInWith;

                        // Add methods to `lodash.prototype`.
                        mixin(lodash, lodash);



                        // Add methods that return unwrapped values in chain sequences.
                        lodash.add = add;
                        lodash.attempt = attempt;
                        lodash.camelCase = camelCase;
                        lodash.capitalize = capitalize;
                        lodash.ceil = ceil;
                        lodash.clamp = clamp;
                        lodash.clone = clone;
                        lodash.cloneDeep = cloneDeep;
                        lodash.cloneDeepWith = cloneDeepWith;
                        lodash.cloneWith = cloneWith;
                        lodash.conformsTo = conformsTo;
                        lodash.deburr = deburr;
                        lodash.defaultTo = defaultTo;
                        lodash.divide = divide;
                        lodash.endsWith = endsWith;
                        lodash.eq = eq;
                        lodash.escape = escape;
                        lodash.escapeRegExp = escapeRegExp;
                        lodash.every = every;
                        lodash.find = find;
                        lodash.findIndex = findIndex;
                        lodash.findKey = findKey;
                        lodash.findLast = findLast;
                        lodash.findLastIndex = findLastIndex;
                        lodash.findLastKey = findLastKey;
                        lodash.floor = floor;
                        lodash.forEach = forEach;
                        lodash.forEachRight = forEachRight;
                        lodash.forIn = forIn;
                        lodash.forInRight = forInRight;
                        lodash.forOwn = forOwn;
                        lodash.forOwnRight = forOwnRight;
                        lodash.get = get;
                        lodash.gt = gt;
                        lodash.gte = gte;
                        lodash.has = has;
                        lodash.hasIn = hasIn;
                        lodash.head = head;
                        lodash.identity = identity;
                        lodash.includes = includes;
                        lodash.indexOf = indexOf;
                        lodash.inRange = inRange;
                        lodash.invoke = invoke;
                        lodash.isArguments = isArguments;
                        lodash.isArray = isArray;
                        lodash.isArrayBuffer = isArrayBuffer;
                        lodash.isArrayLike = isArrayLike;
                        lodash.isArrayLikeObject = isArrayLikeObject;
                        lodash.isBoolean = isBoolean;
                        lodash.isBuffer = isBuffer;
                        lodash.isDate = isDate;
                        lodash.isElement = isElement;
                        lodash.isEmpty = isEmpty;
                        lodash.isEqual = isEqual;
                        lodash.isEqualWith = isEqualWith;
                        lodash.isError = isError;
                        lodash.isFinite = isFinite;
                        lodash.isFunction = isFunction;
                        lodash.isInteger = isInteger;
                        lodash.isLength = isLength;
                        lodash.isMap = isMap;
                        lodash.isMatch = isMatch;
                        lodash.isMatchWith = isMatchWith;
                        lodash.isNaN = isNaN;
                        lodash.isNative = isNative;
                        lodash.isNil = isNil;
                        lodash.isNull = isNull;
                        lodash.isNumber = isNumber;
                        lodash.isObject = isObject;
                        lodash.isObjectLike = isObjectLike;
                        lodash.isPlainObject = isPlainObject;
                        lodash.isRegExp = isRegExp;
                        lodash.isSafeInteger = isSafeInteger;
                        lodash.isSet = isSet;
                        lodash.isString = isString;
                        lodash.isSymbol = isSymbol;
                        lodash.isTypedArray = isTypedArray;
                        lodash.isUndefined = isUndefined;
                        lodash.isWeakMap = isWeakMap;
                        lodash.isWeakSet = isWeakSet;
                        lodash.join = join;
                        lodash.kebabCase = kebabCase;
                        lodash.last = last;
                        lodash.lastIndexOf = lastIndexOf;
                        lodash.lowerCase = lowerCase;
                        lodash.lowerFirst = lowerFirst;
                        lodash.lt = lt;
                        lodash.lte = lte;
                        lodash.max = max;
                        lodash.maxBy = maxBy;
                        lodash.mean = mean;
                        lodash.meanBy = meanBy;
                        lodash.min = min;
                        lodash.minBy = minBy;
                        lodash.stubArray = stubArray;
                        lodash.stubFalse = stubFalse;
                        lodash.stubObject = stubObject;
                        lodash.stubString = stubString;
                        lodash.stubTrue = stubTrue;
                        lodash.multiply = multiply;
                        lodash.nth = nth;
                        lodash.noConflict = noConflict;
                        lodash.noop = noop;
                        lodash.now = now;
                        lodash.pad = pad;
                        lodash.padEnd = padEnd;
                        lodash.padStart = padStart;
                        lodash.parseInt = parseInt;
                        lodash.random = random;
                        lodash.reduce = reduce;
                        lodash.reduceRight = reduceRight;
                        lodash.repeat = repeat;
                        lodash.replace = replace;
                        lodash.result = result;
                        lodash.round = round;
                        lodash.runInContext = runInContext;
                        lodash.sample = sample;
                        lodash.size = size;
                        lodash.snakeCase = snakeCase;
                        lodash.some = some;
                        lodash.sortedIndex = sortedIndex;
                        lodash.sortedIndexBy = sortedIndexBy;
                        lodash.sortedIndexOf = sortedIndexOf;
                        lodash.sortedLastIndex = sortedLastIndex;
                        lodash.sortedLastIndexBy = sortedLastIndexBy;
                        lodash.sortedLastIndexOf = sortedLastIndexOf;
                        lodash.startCase = startCase;
                        lodash.startsWith = startsWith;
                        lodash.subtract = subtract;
                        lodash.sum = sum;
                        lodash.sumBy = sumBy;
                        lodash.template = template;
                        lodash.times = times;
                        lodash.toFinite = toFinite;
                        lodash.toInteger = toInteger;
                        lodash.toLength = toLength;
                        lodash.toLower = toLower;
                        lodash.toNumber = toNumber;
                        lodash.toSafeInteger = toSafeInteger;
                        lodash.toString = toString;
                        lodash.toUpper = toUpper;
                        lodash.trim = trim;
                        lodash.trimEnd = trimEnd;
                        lodash.trimStart = trimStart;
                        lodash.truncate = truncate;
                        lodash.unescape = unescape;
                        lodash.uniqueId = uniqueId;
                        lodash.upperCase = upperCase;
                        lodash.upperFirst = upperFirst;

                        // Add aliases.
                        lodash.each = forEach;
                        lodash.eachRight = forEachRight;
                        lodash.first = head;

                        mixin(lodash, (function() {
                            var source = {};
                            baseForOwn(lodash, function(func, methodName) {
                                if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                                    source[methodName] = func;
                                }
                            });
                            return source;
                        }()), {
                            'chain': false
                        });




                        lodash.VERSION = VERSION;

                        // Assign default placeholders.
                        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
                            lodash[methodName].placeholder = lodash;
                        });

                        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                        arrayEach(['drop', 'take'], function(methodName, index) {
                            LazyWrapper.prototype[methodName] = function(n) {
                                var filtered = this.__filtered__;
                                if (filtered && !index) {
                                    return new LazyWrapper(this);
                                }
                                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

                                var result = this.clone();
                                if (filtered) {
                                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                                } else {
                                    result.__views__.push({
                                        'size': nativeMin(n, MAX_ARRAY_LENGTH),
                                        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                                    });
                                }
                                return result;
                            };

                            LazyWrapper.prototype[methodName + 'Right'] = function(n) {
                                return this.reverse()[methodName](n).reverse();
                            };
                        });

                        // Add `LazyWrapper` methods that accept an `iteratee` value.
                        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
                            var type = index + 1,
                                isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

                            LazyWrapper.prototype[methodName] = function(iteratee) {
                                var result = this.clone();
                                result.__iteratees__.push({
                                    'iteratee': getIteratee(iteratee, 3),
                                    'type': type
                                });
                                result.__filtered__ = result.__filtered__ || isFilter;
                                return result;
                            };
                        });

                        // Add `LazyWrapper` methods for `_.head` and `_.last`.
                        arrayEach(['head', 'last'], function(methodName, index) {
                            var takeName = 'take' + (index ? 'Right' : '');

                            LazyWrapper.prototype[methodName] = function() {
                                return this[takeName](1).value()[0];
                            };
                        });

                        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
                        arrayEach(['initial', 'tail'], function(methodName, index) {
                            var dropName = 'drop' + (index ? '' : 'Right');

                            LazyWrapper.prototype[methodName] = function() {
                                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                            };
                        });

                        LazyWrapper.prototype.compact = function() {
                            return this.filter(identity);
                        };

                        LazyWrapper.prototype.find = function(predicate) {
                            return this.filter(predicate).head();
                        };

                        LazyWrapper.prototype.findLast = function(predicate) {
                            return this.reverse().find(predicate);
                        };

                        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                            if (typeof path == 'function') {
                                return new LazyWrapper(this);
                            }
                            return this.map(function(value) {
                                return baseInvoke(value, path, args);
                            });
                        });

                        LazyWrapper.prototype.reject = function(predicate) {
                            return this.filter(negate(getIteratee(predicate)));
                        };

                        LazyWrapper.prototype.slice = function(start, end) {
                            start = toInteger(start);

                            var result = this;
                            if (result.__filtered__ && (start > 0 || end < 0)) {
                                return new LazyWrapper(result);
                            }
                            if (start < 0) {
                                result = result.takeRight(-start);
                            } else if (start) {
                                result = result.drop(start);
                            }
                            if (end !== undefined) {
                                end = toInteger(end);
                                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                            }
                            return result;
                        };

                        LazyWrapper.prototype.takeRightWhile = function(predicate) {
                            return this.reverse().takeWhile(predicate).reverse();
                        };

                        LazyWrapper.prototype.toArray = function() {
                            return this.take(MAX_ARRAY_LENGTH);
                        };

                        // Add `LazyWrapper` methods to `lodash.prototype`.
                        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                                isTaker = /^(?:head|last)$/.test(methodName),
                                lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
                                retUnwrapped = isTaker || /^find/.test(methodName);

                            if (!lodashFunc) {
                                return;
                            }
                            lodash.prototype[methodName] = function() {
                                var value = this.__wrapped__,
                                    args = isTaker ? [1] : arguments,
                                    isLazy = value instanceof LazyWrapper,
                                    iteratee = args[0],
                                    useLazy = isLazy || isArray(value);

                                var interceptor = function(value) {
                                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                                    return (isTaker && chainAll) ? result[0] : result;
                                };

                                if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                    // Avoid lazy use if the iteratee has a "length" value other than `1`.
                                    isLazy = useLazy = false;
                                }
                                var chainAll = this.__chain__,
                                    isHybrid = !!this.__actions__.length,
                                    isUnwrapped = retUnwrapped && !chainAll,
                                    onlyLazy = isLazy && !isHybrid;

                                if (!retUnwrapped && useLazy) {
                                    value = onlyLazy ? value : new LazyWrapper(this);
                                    var result = func.apply(value, args);
                                    result.__actions__.push({
                                        'func': thru,
                                        'args': [interceptor],
                                        'thisArg': undefined
                                    });
                                    return new LodashWrapper(result, chainAll);
                                }
                                if (isUnwrapped && onlyLazy) {
                                    return func.apply(this, args);
                                }
                                result = this.thru(interceptor);
                                return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
                            };
                        });

                        // Add `Array` methods to `lodash.prototype`.
                        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
                            var func = arrayProto[methodName],
                                chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                                retUnwrapped = /^(?:pop|shift)$/.test(methodName);

                            lodash.prototype[methodName] = function() {
                                var args = arguments;
                                if (retUnwrapped && !this.__chain__) {
                                    var value = this.value();
                                    return func.apply(isArray(value) ? value : [], args);
                                }
                                return this[chainName](function(value) {
                                    return func.apply(isArray(value) ? value : [], args);
                                });
                            };
                        });

                        // Map minified method names to their real names.
                        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                            var lodashFunc = lodash[methodName];
                            if (lodashFunc) {
                                var key = (lodashFunc.name + ''),
                                    names = realNames[key] || (realNames[key] = []);

                                names.push({
                                    'name': methodName,
                                    'func': lodashFunc
                                });
                            }
                        });

                        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                            'name': 'wrapper',
                            'func': undefined
                        }];

                        // Add methods to `LazyWrapper`.
                        LazyWrapper.prototype.clone = lazyClone;
                        LazyWrapper.prototype.reverse = lazyReverse;
                        LazyWrapper.prototype.value = lazyValue;

                        // Add chain sequence methods to the `lodash` wrapper.
                        lodash.prototype.at = wrapperAt;
                        lodash.prototype.chain = wrapperChain;
                        lodash.prototype.commit = wrapperCommit;
                        lodash.prototype.next = wrapperNext;
                        lodash.prototype.plant = wrapperPlant;
                        lodash.prototype.reverse = wrapperReverse;
                        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                        // Add lazy aliases.
                        lodash.prototype.first = lodash.prototype.head;

                        if (symIterator) {
                            lodash.prototype[symIterator] = wrapperToIterator;
                        }
                        return lodash;
                    });



                    // Export lodash.
                    var _ = runInContext();

                    // Some AMD build optimizers, like r.js, check for condition patterns like:
                    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                        // Expose Lodash on the global object to prevent errors when Lodash is
                        // loaded by a script tag in the presence of an AMD loader.
                        // See http://requirejs.org/docs/errors.html#mismatch for more details.
                        // Use `_.noConflict` to remove Lodash from the global object.
                        root._ = _;

                        // Define as an anonymous module so, through path mapping, it can be
                        // referenced as the "underscore" module.
                        define(function() {
                            return _;
                        });
                    }
                    // Check for `exports` after `define` in case a build optimizer adds it.
                    else if (freeModule) {
                        // Export for Node.js.
                        (freeModule.exports = _)._ = _;
                        // Export for CommonJS support.
                        freeExports._ = _;
                    } else {
                        // Export to the global object.
                        root._ = _;
                    }
                }.call(this));

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}],
        27: [function(_dereq_, module, exports) {

            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var propIsEnumerable = Object.prototype.propertyIsEnumerable;

            function toObject(val) {
                if (val === null || val === undefined) {
                    throw new TypeError('Object.assign cannot be called with null or undefined');
                }

                return Object(val);
            }

            function shouldUseNative() {
                try {
                    if (!Object.assign) {
                        return false;
                    }

                    // Detect buggy property enumeration order in older V8 versions.

                    // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                    var test1 = new String('abc'); // eslint-disable-line
                    test1[5] = 'de';
                    if (Object.getOwnPropertyNames(test1)[0] === '5') {
                        return false;
                    }

                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                    var test2 = {};
                    for (var i = 0; i < 10; i++) {
                        test2['_' + String.fromCharCode(i)] = i;
                    }
                    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                        return test2[n];
                    });
                    if (order2.join('') !== '0123456789') {
                        return false;
                    }

                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                    var test3 = {};
                    'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                        test3[letter] = letter;
                    });
                    if (Object.keys(Object.assign({}, test3)).join('') !==
                        'abcdefghijklmnopqrst') {
                        return false;
                    }

                    return true;
                } catch (e) {
                    // We don't expect any of the above to throw, but better to be safe.
                    return false;
                }
            }

            module.exports = shouldUseNative() ? Object.assign : function(target, source) {
                var from;
                var to = toObject(target);
                var symbols;

                for (var s = 1; s < arguments.length; s++) {
                    from = Object(arguments[s]);

                    for (var key in from) {
                        if (hasOwnProperty.call(from, key)) {
                            to[key] = from[key];
                        }
                    }

                    if (Object.getOwnPropertySymbols) {
                        symbols = Object.getOwnPropertySymbols(from);
                        for (var i = 0; i < symbols.length; i++) {
                            if (propIsEnumerable.call(from, symbols[i])) {
                                to[symbols[i]] = from[symbols[i]];
                            }
                        }
                    }
                }

                return to;
            };

        }, {}],
        28: [function(_dereq_, module, exports) {
            // shim for using process in browser

            var process = module.exports = {};
            var queue = [];
            var draining = false;

            function drainQueue() {
                if (draining) {
                    return;
                }
                draining = true;
                var currentQueue;
                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    var i = -1;
                    while (++i < len) {
                        currentQueue[i]();
                    }
                    len = queue.length;
                }
                draining = false;
            }
            process.nextTick = function(fun) {
                queue.push(fun);
                if (!draining) {
                    setTimeout(drainQueue, 0);
                }
            };

            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = ''; // empty string to avoid regexp issues
            process.versions = {};

            function noop() {}

            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;

            process.binding = function(name) {
                throw new Error('process.binding is not supported');
            };

            // TODO(shtylman)
            process.cwd = function() {
                return '/'
            };
            process.chdir = function(dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function() {
                return 0;
            };

        }, {}],
        29: [function(_dereq_, module, exports) {

            module.exports = _dereq_('./lib/ReactDOM');

        }, {
            "./lib/ReactDOM": 59
        }],
        30: [function(_dereq_, module, exports) {

            var ARIADOMPropertyConfig = {
                Properties: {
                    // Global States and Properties
                    'aria-current': 0, // state
                    'aria-details': 0,
                    'aria-disabled': 0, // state
                    'aria-hidden': 0, // state
                    'aria-invalid': 0, // state
                    'aria-keyshortcuts': 0,
                    'aria-label': 0,
                    'aria-roledescription': 0,
                    // Widget Attributes
                    'aria-autocomplete': 0,
                    'aria-checked': 0,
                    'aria-expanded': 0,
                    'aria-haspopup': 0,
                    'aria-level': 0,
                    'aria-modal': 0,
                    'aria-multiline': 0,
                    'aria-multiselectable': 0,
                    'aria-orientation': 0,
                    'aria-placeholder': 0,
                    'aria-pressed': 0,
                    'aria-readonly': 0,
                    'aria-required': 0,
                    'aria-selected': 0,
                    'aria-sort': 0,
                    'aria-valuemax': 0,
                    'aria-valuemin': 0,
                    'aria-valuenow': 0,
                    'aria-valuetext': 0,
                    // Live Region Attributes
                    'aria-atomic': 0,
                    'aria-busy': 0,
                    'aria-live': 0,
                    'aria-relevant': 0,
                    // Drag-and-Drop Attributes
                    'aria-dropeffect': 0,
                    'aria-grabbed': 0,
                    // Relationship Attributes
                    'aria-activedescendant': 0,
                    'aria-colcount': 0,
                    'aria-colindex': 0,
                    'aria-colspan': 0,
                    'aria-controls': 0,
                    'aria-describedby': 0,
                    'aria-errormessage': 0,
                    'aria-flowto': 0,
                    'aria-labelledby': 0,
                    'aria-owns': 0,
                    'aria-posinset': 0,
                    'aria-rowcount': 0,
                    'aria-rowindex': 0,
                    'aria-rowspan': 0,
                    'aria-setsize': 0
                },
                DOMAttributeNames: {},
                DOMPropertyNames: {}
            };

            module.exports = ARIADOMPropertyConfig;
        }, {}],
        31: [function(_dereq_, module, exports) {

            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');

            var focusNode = _dereq_('fbjs/lib/focusNode');

            var AutoFocusUtils = {
                focusDOMComponent: function() {
                    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
                }
            };

            module.exports = AutoFocusUtils;
        }, {
            "./ReactDOMComponentTree": 62,
            "fbjs/lib/focusNode": 11
        }],
        32: [function(_dereq_, module, exports) {

            var EventPropagators = _dereq_('./EventPropagators');
            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
            var FallbackCompositionState = _dereq_('./FallbackCompositionState');
            var SyntheticCompositionEvent = _dereq_('./SyntheticCompositionEvent');
            var SyntheticInputEvent = _dereq_('./SyntheticInputEvent');

            var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
            var START_KEYCODE = 229;

            var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

            var documentMode = null;
            if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
                documentMode = document.documentMode;
            }

            // Webkit offers a very useful `textInput` event that can be used to
            // directly represent `beforeInput`. The IE `textinput` event is not as
            // useful, so we don't use it.
            var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

            // In IE9+, we have access to composition events, but the data supplied
            // by the native compositionend event may be incorrect. Japanese ideographic
            // spaces, for instance (\u3000) are not recorded correctly.
            var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

            function isPresto() {
                var opera = window.opera;
                return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
            }

            var SPACEBAR_CODE = 32;
            var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

            // Events and their corresponding property names.
            var eventTypes = {
                beforeInput: {
                    phasedRegistrationNames: {
                        bubbled: 'onBeforeInput',
                        captured: 'onBeforeInputCapture'
                    },
                    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
                },
                compositionEnd: {
                    phasedRegistrationNames: {
                        bubbled: 'onCompositionEnd',
                        captured: 'onCompositionEndCapture'
                    },
                    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
                },
                compositionStart: {
                    phasedRegistrationNames: {
                        bubbled: 'onCompositionStart',
                        captured: 'onCompositionStartCapture'
                    },
                    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
                },
                compositionUpdate: {
                    phasedRegistrationNames: {
                        bubbled: 'onCompositionUpdate',
                        captured: 'onCompositionUpdateCapture'
                    },
                    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
                }
            };

            // Track whether we've ever handled a keypress on the space key.
            var hasSpaceKeypress = false;

            function isKeypressCommand(nativeEvent) {
                return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
                    // ctrlKey && altKey is equivalent to AltGr, and is not a command.
                    !(nativeEvent.ctrlKey && nativeEvent.altKey);
            }

            function getCompositionEventType(topLevelType) {
                switch (topLevelType) {
                    case 'topCompositionStart':
                        return eventTypes.compositionStart;
                    case 'topCompositionEnd':
                        return eventTypes.compositionEnd;
                    case 'topCompositionUpdate':
                        return eventTypes.compositionUpdate;
                }
            }

            function isFallbackCompositionStart(topLevelType, nativeEvent) {
                return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
            }

            function isFallbackCompositionEnd(topLevelType, nativeEvent) {
                switch (topLevelType) {
                    case 'topKeyUp':
                        // Command keys insert or clear IME input.
                        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
                    case 'topKeyDown':
                        // Expect IME keyCode on each keydown. If we get any other
                        // code we must have exited earlier.
                        return nativeEvent.keyCode !== START_KEYCODE;
                    case 'topKeyPress':
                    case 'topMouseDown':
                    case 'topBlur':
                        // Events are not possible without cancelling IME.
                        return true;
                    default:
                        return false;
                }
            }

            function getDataFromCustomEvent(nativeEvent) {
                var detail = nativeEvent.detail;
                if (typeof detail === 'object' && 'data' in detail) {
                    return detail.data;
                }
                return null;
            }

            // Track the current IME composition fallback object, if any.
            var currentComposition = null;

            function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                var eventType;
                var fallbackData;

                if (canUseCompositionEvent) {
                    eventType = getCompositionEventType(topLevelType);
                } else if (!currentComposition) {
                    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
                        eventType = eventTypes.compositionStart;
                    }
                } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                    eventType = eventTypes.compositionEnd;
                }

                if (!eventType) {
                    return null;
                }

                if (useFallbackCompositionData) {
                    // The current composition is stored statically and must not be
                    // overwritten while composition continues.
                    if (!currentComposition && eventType === eventTypes.compositionStart) {
                        currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
                    } else if (eventType === eventTypes.compositionEnd) {
                        if (currentComposition) {
                            fallbackData = currentComposition.getData();
                        }
                    }
                }

                var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

                if (fallbackData) {
                    // Inject data generated from fallback path into the synthetic event.
                    // This matches the property of native CompositionEventInterface.
                    event.data = fallbackData;
                } else {
                    var customData = getDataFromCustomEvent(nativeEvent);
                    if (customData !== null) {
                        event.data = customData;
                    }
                }

                EventPropagators.accumulateTwoPhaseDispatches(event);
                return event;
            }

            function getNativeBeforeInputChars(topLevelType, nativeEvent) {
                switch (topLevelType) {
                    case 'topCompositionEnd':
                        return getDataFromCustomEvent(nativeEvent);
                    case 'topKeyPress':

                        var which = nativeEvent.which;
                        if (which !== SPACEBAR_CODE) {
                            return null;
                        }

                        hasSpaceKeypress = true;
                        return SPACEBAR_CHAR;

                    case 'topTextInput':
                        // Record the characters to be added to the DOM.
                        var chars = nativeEvent.data;

                        // If it's a spacebar character, assume that we have already handled
                        // it at the keypress level and bail immediately. Android Chrome
                        // doesn't give us keycodes, so we need to blacklist it.
                        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                            return null;
                        }

                        return chars;

                    default:
                        // For other native event types, do nothing.
                        return null;
                }
            }

            function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
                // If we are currently composing (IME) and using a fallback to do so,
                // try to extract the composed characters from the fallback object.
                // If composition event is available, we extract a string only at
                // compositionevent, otherwise extract it at fallback events.
                if (currentComposition) {
                    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                        var chars = currentComposition.getData();
                        FallbackCompositionState.release(currentComposition);
                        currentComposition = null;
                        return chars;
                    }
                    return null;
                }

                switch (topLevelType) {
                    case 'topPaste':
                        // If a paste event occurs after a keypress, throw out the input
                        // chars. Paste events should not lead to BeforeInput events.
                        return null;
                    case 'topKeyPress':

                        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
                            return String.fromCharCode(nativeEvent.which);
                        }
                        return null;
                    case 'topCompositionEnd':
                        return useFallbackCompositionData ? null : nativeEvent.data;
                    default:
                        return null;
                }
            }

            function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                var chars;

                if (canUseTextInputEvent) {
                    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
                } else {
                    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
                }

                // If no characters are being inserted, no BeforeInput event should
                // be fired.
                if (!chars) {
                    return null;
                }

                var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

                event.data = chars;
                EventPropagators.accumulateTwoPhaseDispatches(event);
                return event;
            }

            var BeforeInputEventPlugin = {

                eventTypes: eventTypes,

                extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
                }
            };

            module.exports = BeforeInputEventPlugin;
        }, {
            "./EventPropagators": 48,
            "./FallbackCompositionState": 49,
            "./SyntheticCompositionEvent": 113,
            "./SyntheticInputEvent": 117,
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        33: [function(_dereq_, module, exports) {

            var isUnitlessNumber = {
                animationIterationCount: true,
                borderImageOutset: true,
                borderImageSlice: true,
                borderImageWidth: true,
                boxFlex: true,
                boxFlexGroup: true,
                boxOrdinalGroup: true,
                columnCount: true,
                flex: true,
                flexGrow: true,
                flexPositive: true,
                flexShrink: true,
                flexNegative: true,
                flexOrder: true,
                gridRow: true,
                gridColumn: true,
                fontWeight: true,
                lineClamp: true,
                lineHeight: true,
                opacity: true,
                order: true,
                orphans: true,
                tabSize: true,
                widows: true,
                zIndex: true,
                zoom: true,

                // SVG-related properties
                fillOpacity: true,
                floodOpacity: true,
                stopOpacity: true,
                strokeDasharray: true,
                strokeDashoffset: true,
                strokeMiterlimit: true,
                strokeOpacity: true,
                strokeWidth: true
            };

            function prefixKey(prefix, key) {
                return prefix + key.charAt(0).toUpperCase() + key.substring(1);
            }

            var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

            // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
            // infinite loop, because it iterates over the newly added props too.
            Object.keys(isUnitlessNumber).forEach(function(prop) {
                prefixes.forEach(function(prefix) {
                    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
                });
            });

            var shorthandPropertyExpansions = {
                background: {
                    backgroundAttachment: true,
                    backgroundColor: true,
                    backgroundImage: true,
                    backgroundPositionX: true,
                    backgroundPositionY: true,
                    backgroundRepeat: true
                },
                backgroundPosition: {
                    backgroundPositionX: true,
                    backgroundPositionY: true
                },
                border: {
                    borderWidth: true,
                    borderStyle: true,
                    borderColor: true
                },
                borderBottom: {
                    borderBottomWidth: true,
                    borderBottomStyle: true,
                    borderBottomColor: true
                },
                borderLeft: {
                    borderLeftWidth: true,
                    borderLeftStyle: true,
                    borderLeftColor: true
                },
                borderRight: {
                    borderRightWidth: true,
                    borderRightStyle: true,
                    borderRightColor: true
                },
                borderTop: {
                    borderTopWidth: true,
                    borderTopStyle: true,
                    borderTopColor: true
                },
                font: {
                    fontStyle: true,
                    fontVariant: true,
                    fontWeight: true,
                    fontSize: true,
                    lineHeight: true,
                    fontFamily: true
                },
                outline: {
                    outlineWidth: true,
                    outlineStyle: true,
                    outlineColor: true
                }
            };

            var CSSProperty = {
                isUnitlessNumber: isUnitlessNumber,
                shorthandPropertyExpansions: shorthandPropertyExpansions
            };

            module.exports = CSSProperty;
        }, {}],
        34: [function(_dereq_, module, exports) {
            (function(process) {

                var CSSProperty = _dereq_('./CSSProperty');
                var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');

                var camelizeStyleName = _dereq_('fbjs/lib/camelizeStyleName');
                var dangerousStyleValue = _dereq_('./dangerousStyleValue');
                var hyphenateStyleName = _dereq_('fbjs/lib/hyphenateStyleName');
                var memoizeStringOnly = _dereq_('fbjs/lib/memoizeStringOnly');
                var warning = _dereq_('fbjs/lib/warning');

                var processStyleName = memoizeStringOnly(function(styleName) {
                    return hyphenateStyleName(styleName);
                });

                var hasShorthandPropertyBug = false;
                var styleFloatAccessor = 'cssFloat';
                if (ExecutionEnvironment.canUseDOM) {
                    var tempStyle = document.createElement('div').style;
                    try {
                        // IE8 throws "Invalid argument." if resetting shorthand style properties.
                        tempStyle.font = '';
                    } catch (e) {
                        hasShorthandPropertyBug = true;
                    }
                    // IE8 only supports accessing cssFloat (standard) as styleFloat
                    if (document.documentElement.style.cssFloat === undefined) {
                        styleFloatAccessor = 'styleFloat';
                    }
                }

                if (process.env.NODE_ENV !== 'production') {
                    // 'msTransform' is correct, but the other prefixes should be capitalized
                    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

                    // style values shouldn't contain a semicolon
                    var badStyleValueWithSemicolonPattern = /;\s*$/;

                    var warnedStyleNames = {};
                    var warnedStyleValues = {};
                    var warnedForNaNValue = false;

                    var warnHyphenatedStyleName = function(name, owner) {
                        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                            return;
                        }

                        warnedStyleNames[name] = true;
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
                    };

                    var warnBadVendoredStyleName = function(name, owner) {
                        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                            return;
                        }

                        warnedStyleNames[name] = true;
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
                    };

                    var warnStyleValueWithSemicolon = function(name, value, owner) {
                        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                            return;
                        }

                        warnedStyleValues[value] = true;
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
                    };

                    var warnStyleValueIsNaN = function(name, value, owner) {
                        if (warnedForNaNValue) {
                            return;
                        }

                        warnedForNaNValue = true;
                        process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
                    };

                    var checkRenderMessage = function(owner) {
                        if (owner) {
                            var name = owner.getName();
                            if (name) {
                                return ' Check the render method of `' + name + '`.';
                            }
                        }
                        return '';
                    };


                    var warnValidStyle = function(name, value, component) {
                        var owner;
                        if (component) {
                            owner = component._currentElement._owner;
                        }
                        if (name.indexOf('-') > -1) {
                            warnHyphenatedStyleName(name, owner);
                        } else if (badVendoredStyleNamePattern.test(name)) {
                            warnBadVendoredStyleName(name, owner);
                        } else if (badStyleValueWithSemicolonPattern.test(value)) {
                            warnStyleValueWithSemicolon(name, value, owner);
                        }

                        if (typeof value === 'number' && isNaN(value)) {
                            warnStyleValueIsNaN(name, value, owner);
                        }
                    };
                }

                var CSSPropertyOperations = {


                    createMarkupForStyles: function(styles, component) {
                        var serialized = '';
                        for (var styleName in styles) {
                            if (!styles.hasOwnProperty(styleName)) {
                                continue;
                            }
                            var styleValue = styles[styleName];
                            if (process.env.NODE_ENV !== 'production') {
                                warnValidStyle(styleName, styleValue, component);
                            }
                            if (styleValue != null) {
                                serialized += processStyleName(styleName) + ':';
                                serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
                            }
                        }
                        return serialized || null;
                    },


                    setValueForStyles: function(node, styles, component) {
                        if (process.env.NODE_ENV !== 'production') {
                            ReactInstrumentation.debugTool.onHostOperation({
                                instanceID: component._debugID,
                                type: 'update styles',
                                payload: styles
                            });
                        }

                        var style = node.style;
                        for (var styleName in styles) {
                            if (!styles.hasOwnProperty(styleName)) {
                                continue;
                            }
                            if (process.env.NODE_ENV !== 'production') {
                                warnValidStyle(styleName, styles[styleName], component);
                            }
                            var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
                            if (styleName === 'float' || styleName === 'cssFloat') {
                                styleName = styleFloatAccessor;
                            }
                            if (styleValue) {
                                style[styleName] = styleValue;
                            } else {
                                var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
                                if (expansion) {
                                    // Shorthand property that IE8 won't like unsetting, so unset each
                                    // component to placate it
                                    for (var individualStyleName in expansion) {
                                        style[individualStyleName] = '';
                                    }
                                } else {
                                    style[styleName] = '';
                                }
                            }
                        }
                    }

                };

                module.exports = CSSPropertyOperations;
            }).call(this, _dereq_('_process'))
        }, {
            "./CSSProperty": 33,
            "./ReactInstrumentation": 91,
            "./dangerousStyleValue": 130,
            "_process": 28,
            "fbjs/lib/ExecutionEnvironment": 3,
            "fbjs/lib/camelizeStyleName": 5,
            "fbjs/lib/hyphenateStyleName": 16,
            "fbjs/lib/memoizeStringOnly": 20,
            "fbjs/lib/warning": 24
        }],
        35: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }

                var PooledClass = _dereq_('./PooledClass');

                var invariant = _dereq_('fbjs/lib/invariant');

                var CallbackQueue = function() {
                    function CallbackQueue(arg) {
                        _classCallCheck(this, CallbackQueue);

                        this._callbacks = null;
                        this._contexts = null;
                        this._arg = arg;
                    }



                    CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
                        this._callbacks = this._callbacks || [];
                        this._callbacks.push(callback);
                        this._contexts = this._contexts || [];
                        this._contexts.push(context);
                    };



                    CallbackQueue.prototype.notifyAll = function notifyAll() {
                        var callbacks = this._callbacks;
                        var contexts = this._contexts;
                        var arg = this._arg;
                        if (callbacks && contexts) {
                            !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24'): void 0;
                            this._callbacks = null;
                            this._contexts = null;
                            for (var i = 0; i < callbacks.length; i++) {
                                callbacks[i].call(contexts[i], arg);
                            }
                            callbacks.length = 0;
                            contexts.length = 0;
                        }
                    };

                    CallbackQueue.prototype.checkpoint = function checkpoint() {
                        return this._callbacks ? this._callbacks.length : 0;
                    };

                    CallbackQueue.prototype.rollback = function rollback(len) {
                        if (this._callbacks && this._contexts) {
                            this._callbacks.length = len;
                            this._contexts.length = len;
                        }
                    };



                    CallbackQueue.prototype.reset = function reset() {
                        this._callbacks = null;
                        this._contexts = null;
                    };



                    CallbackQueue.prototype.destructor = function destructor() {
                        this.reset();
                    };

                    return CallbackQueue;
                }();

                module.exports = PooledClass.addPoolingTo(CallbackQueue);
            }).call(this, _dereq_('_process'))
        }, {
            "./PooledClass": 53,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        36: [function(_dereq_, module, exports) {

            var EventPluginHub = _dereq_('./EventPluginHub');
            var EventPropagators = _dereq_('./EventPropagators');
            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
            var ReactUpdates = _dereq_('./ReactUpdates');
            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var getEventTarget = _dereq_('./getEventTarget');
            var isEventSupported = _dereq_('./isEventSupported');
            var isTextInputElement = _dereq_('./isTextInputElement');

            var eventTypes = {
                change: {
                    phasedRegistrationNames: {
                        bubbled: 'onChange',
                        captured: 'onChangeCapture'
                    },
                    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
                }
            };

            var activeElement = null;
            var activeElementInst = null;
            var activeElementValue = null;
            var activeElementValueProp = null;

            function shouldUseChangeEvent(elem) {
                var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
                return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
            }

            var doesChangeEventBubble = false;
            if (ExecutionEnvironment.canUseDOM) {
                // See `handleChange` comment below
                doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
            }

            function manualDispatchChangeEvent(nativeEvent) {
                var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
                EventPropagators.accumulateTwoPhaseDispatches(event);

                // If change and propertychange bubbled, we'd just bind to it like all the
                // other events and have it go through ReactBrowserEventEmitter. Since it
                // doesn't, we manually listen for the events and so we have to enqueue and
                // process the abstract event manually.
                //
                // Batching is necessary here in order to ensure that all event handlers run
                // before the next rerender (including event handlers attached to ancestor
                // elements instead of directly on the input). Without this, controlled
                // components don't work properly in conjunction with event bubbling because
                // the component is rerendered and the value reverted before all the event
                // handlers can run. See https://github.com/facebook/react/issues/708.
                ReactUpdates.batchedUpdates(runEventInBatch, event);
            }

            function runEventInBatch(event) {
                EventPluginHub.enqueueEvents(event);
                EventPluginHub.processEventQueue(false);
            }

            function startWatchingForChangeEventIE8(target, targetInst) {
                activeElement = target;
                activeElementInst = targetInst;
                activeElement.attachEvent('onchange', manualDispatchChangeEvent);
            }

            function stopWatchingForChangeEventIE8() {
                if (!activeElement) {
                    return;
                }
                activeElement.detachEvent('onchange', manualDispatchChangeEvent);
                activeElement = null;
                activeElementInst = null;
            }

            function getTargetInstForChangeEvent(topLevelType, targetInst) {
                if (topLevelType === 'topChange') {
                    return targetInst;
                }
            }

            function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
                if (topLevelType === 'topFocus') {
                    // stopWatching() should be a noop here but we call it just in case we
                    // missed a blur event somehow.
                    stopWatchingForChangeEventIE8();
                    startWatchingForChangeEventIE8(target, targetInst);
                } else if (topLevelType === 'topBlur') {
                    stopWatchingForChangeEventIE8();
                }
            }

            var isInputEventSupported = false;
            if (ExecutionEnvironment.canUseDOM) {
                // IE9 claims to support the input event but fails to trigger it when
                // deleting text, so we ignore its input events.
                // IE10+ fire input events to often, such when a placeholder
                // changes or when an input with a placeholder is focused.
                isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
            }

            var newValueProp = {
                get: function() {
                    return activeElementValueProp.get.call(this);
                },
                set: function(val) {
                    // Cast to a string so we can do equality checks.
                    activeElementValue = '' + val;
                    activeElementValueProp.set.call(this, val);
                }
            };

            function startWatchingForValueChange(target, targetInst) {
                activeElement = target;
                activeElementInst = targetInst;
                activeElementValue = target.value;
                activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

                // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
                // on DOM elements
                Object.defineProperty(activeElement, 'value', newValueProp);
                if (activeElement.attachEvent) {
                    activeElement.attachEvent('onpropertychange', handlePropertyChange);
                } else {
                    activeElement.addEventListener('propertychange', handlePropertyChange, false);
                }
            }

            function stopWatchingForValueChange() {
                if (!activeElement) {
                    return;
                }

                // delete restores the original property definition
                delete activeElement.value;

                if (activeElement.detachEvent) {
                    activeElement.detachEvent('onpropertychange', handlePropertyChange);
                } else {
                    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
                }

                activeElement = null;
                activeElementInst = null;
                activeElementValue = null;
                activeElementValueProp = null;
            }

            function handlePropertyChange(nativeEvent) {
                if (nativeEvent.propertyName !== 'value') {
                    return;
                }
                var value = nativeEvent.srcElement.value;
                if (value === activeElementValue) {
                    return;
                }
                activeElementValue = value;

                manualDispatchChangeEvent(nativeEvent);
            }

            function getTargetInstForInputEvent(topLevelType, targetInst) {
                if (topLevelType === 'topInput') {
                    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
                    // what we want so fall through here and trigger an abstract event
                    return targetInst;
                }
            }

            function handleEventsForInputEventIE(topLevelType, target, targetInst) {
                if (topLevelType === 'topFocus') {
                    // In IE8, we can capture almost all .value changes by adding a
                    // propertychange handler and looking for events with propertyName
                    // equal to 'value'
                    // In IE9-11, propertychange fires for most input events but is buggy and
                    // doesn't fire when text is deleted, but conveniently, selectionchange
                    // appears to fire in all of the remaining cases so we catch those and
                    // forward the event if the value has changed
                    // In either case, we don't want to call the event handler if the value
                    // is changed from JS so we redefine a setter for `.value` that updates
                    // our activeElementValue variable, allowing us to ignore those changes
                    //
                    // stopWatching() should be a noop here but we call it just in case we
                    // missed a blur event somehow.
                    stopWatchingForValueChange();
                    startWatchingForValueChange(target, targetInst);
                } else if (topLevelType === 'topBlur') {
                    stopWatchingForValueChange();
                }
            }

            // For IE8 and IE9.
            function getTargetInstForInputEventIE(topLevelType, targetInst) {
                if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
                    // On the selectionchange event, the target is just document which isn't
                    // helpful for us so just check activeElement instead.
                    //
                    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
                    // propertychange on the first input event after setting `value` from a
                    // script and fires only keydown, keypress, keyup. Catching keyup usually
                    // gets it and catching keydown lets us fire an event for the first
                    // keystroke if user does a key repeat (it'll be a little delayed: right
                    // before the second keystroke). Other input methods (e.g., paste) seem to
                    // fire selectionchange normally.
                    if (activeElement && activeElement.value !== activeElementValue) {
                        activeElementValue = activeElement.value;
                        return activeElementInst;
                    }
                }
            }

            function shouldUseClickEvent(elem) {
                // Use the `click` event to detect changes to checkbox and radio inputs.
                // This approach works across all browsers, whereas `change` does not fire
                // until `blur` in IE8.
                return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
            }

            function getTargetInstForClickEvent(topLevelType, targetInst) {
                if (topLevelType === 'topClick') {
                    return targetInst;
                }
            }

            var ChangeEventPlugin = {

                eventTypes: eventTypes,

                extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

                    var getTargetInstFunc, handleEventFunc;
                    if (shouldUseChangeEvent(targetNode)) {
                        if (doesChangeEventBubble) {
                            getTargetInstFunc = getTargetInstForChangeEvent;
                        } else {
                            handleEventFunc = handleEventsForChangeEventIE8;
                        }
                    } else if (isTextInputElement(targetNode)) {
                        if (isInputEventSupported) {
                            getTargetInstFunc = getTargetInstForInputEvent;
                        } else {
                            getTargetInstFunc = getTargetInstForInputEventIE;
                            handleEventFunc = handleEventsForInputEventIE;
                        }
                    } else if (shouldUseClickEvent(targetNode)) {
                        getTargetInstFunc = getTargetInstForClickEvent;
                    }

                    if (getTargetInstFunc) {
                        var inst = getTargetInstFunc(topLevelType, targetInst);
                        if (inst) {
                            var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
                            event.type = 'change';
                            EventPropagators.accumulateTwoPhaseDispatches(event);
                            return event;
                        }
                    }

                    if (handleEventFunc) {
                        handleEventFunc(topLevelType, targetNode, targetInst);
                    }
                }

            };

            module.exports = ChangeEventPlugin;
        }, {
            "./EventPluginHub": 45,
            "./EventPropagators": 48,
            "./ReactDOMComponentTree": 62,
            "./ReactUpdates": 106,
            "./SyntheticEvent": 115,
            "./getEventTarget": 138,
            "./isEventSupported": 146,
            "./isTextInputElement": 147,
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        37: [function(_dereq_, module, exports) {
            (function(process) {

                var DOMLazyTree = _dereq_('./DOMLazyTree');
                var Danger = _dereq_('./Danger');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');

                var createMicrosoftUnsafeLocalFunction = _dereq_('./createMicrosoftUnsafeLocalFunction');
                var setInnerHTML = _dereq_('./setInnerHTML');
                var setTextContent = _dereq_('./setTextContent');

                function getNodeAfter(parentNode, node) {
                    // Special case for text components, which return [open, close] comments
                    // from getHostNode.
                    if (Array.isArray(node)) {
                        node = node[1];
                    }
                    return node ? node.nextSibling : parentNode.firstChild;
                }

                var insertChildAt = createMicrosoftUnsafeLocalFunction(function(parentNode, childNode, referenceNode) {
                    // We rely exclusively on `insertBefore(node, null)` instead of also using
                    // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
                    // we are careful to use `null`.)
                    parentNode.insertBefore(childNode, referenceNode);
                });

                function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
                    DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
                }

                function moveChild(parentNode, childNode, referenceNode) {
                    if (Array.isArray(childNode)) {
                        moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
                    } else {
                        insertChildAt(parentNode, childNode, referenceNode);
                    }
                }

                function removeChild(parentNode, childNode) {
                    if (Array.isArray(childNode)) {
                        var closingComment = childNode[1];
                        childNode = childNode[0];
                        removeDelimitedText(parentNode, childNode, closingComment);
                        parentNode.removeChild(closingComment);
                    }
                    parentNode.removeChild(childNode);
                }

                function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
                    var node = openingComment;
                    while (true) {
                        var nextNode = node.nextSibling;
                        insertChildAt(parentNode, node, referenceNode);
                        if (node === closingComment) {
                            break;
                        }
                        node = nextNode;
                    }
                }

                function removeDelimitedText(parentNode, startNode, closingComment) {
                    while (true) {
                        var node = startNode.nextSibling;
                        if (node === closingComment) {
                            // The closing comment is removed by ReactMultiChild.
                            break;
                        } else {
                            parentNode.removeChild(node);
                        }
                    }
                }

                function replaceDelimitedText(openingComment, closingComment, stringText) {
                    var parentNode = openingComment.parentNode;
                    var nodeAfterComment = openingComment.nextSibling;
                    if (nodeAfterComment === closingComment) {
                        // There are no text nodes between the opening and closing comments; insert
                        // a new one if stringText isn't empty.
                        if (stringText) {
                            insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
                        }
                    } else {
                        if (stringText) {
                            // Set the text content of the first node after the opening comment, and
                            // remove all following nodes up until the closing comment.
                            setTextContent(nodeAfterComment, stringText);
                            removeDelimitedText(parentNode, nodeAfterComment, closingComment);
                        } else {
                            removeDelimitedText(parentNode, openingComment, closingComment);
                        }
                    }

                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onHostOperation({
                            instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
                            type: 'replace text',
                            payload: stringText
                        });
                    }
                }

                var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
                if (process.env.NODE_ENV !== 'production') {
                    dangerouslyReplaceNodeWithMarkup = function(oldChild, markup, prevInstance) {
                        Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
                        if (prevInstance._debugID !== 0) {
                            ReactInstrumentation.debugTool.onHostOperation({
                                instanceID: prevInstance._debugID,
                                type: 'replace with',
                                payload: markup.toString()
                            });
                        } else {
                            var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
                            if (nextInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onHostOperation({
                                    instanceID: nextInstance._debugID,
                                    type: 'mount',
                                    payload: markup.toString()
                                });
                            }
                        }
                    };
                }

                var DOMChildrenOperations = {

                    dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

                    replaceDelimitedText: replaceDelimitedText,


                    processUpdates: function(parentNode, updates) {
                        if (process.env.NODE_ENV !== 'production') {
                            var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
                        }

                        for (var k = 0; k < updates.length; k++) {
                            var update = updates[k];
                            switch (update.type) {
                                case 'INSERT_MARKUP':
                                    insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
                                    if (process.env.NODE_ENV !== 'production') {
                                        ReactInstrumentation.debugTool.onHostOperation({
                                            instanceID: parentNodeDebugID,
                                            type: 'insert child',
                                            payload: {
                                                toIndex: update.toIndex,
                                                content: update.content.toString()
                                            }
                                        });
                                    }
                                    break;
                                case 'MOVE_EXISTING':
                                    moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
                                    if (process.env.NODE_ENV !== 'production') {
                                        ReactInstrumentation.debugTool.onHostOperation({
                                            instanceID: parentNodeDebugID,
                                            type: 'move child',
                                            payload: {
                                                fromIndex: update.fromIndex,
                                                toIndex: update.toIndex
                                            }
                                        });
                                    }
                                    break;
                                case 'SET_MARKUP':
                                    setInnerHTML(parentNode, update.content);
                                    if (process.env.NODE_ENV !== 'production') {
                                        ReactInstrumentation.debugTool.onHostOperation({
                                            instanceID: parentNodeDebugID,
                                            type: 'replace children',
                                            payload: update.content.toString()
                                        });
                                    }
                                    break;
                                case 'TEXT_CONTENT':
                                    setTextContent(parentNode, update.content);
                                    if (process.env.NODE_ENV !== 'production') {
                                        ReactInstrumentation.debugTool.onHostOperation({
                                            instanceID: parentNodeDebugID,
                                            type: 'replace text',
                                            payload: update.content.toString()
                                        });
                                    }
                                    break;
                                case 'REMOVE_NODE':
                                    removeChild(parentNode, update.fromNode);
                                    if (process.env.NODE_ENV !== 'production') {
                                        ReactInstrumentation.debugTool.onHostOperation({
                                            instanceID: parentNodeDebugID,
                                            type: 'remove child',
                                            payload: {
                                                fromIndex: update.fromIndex
                                            }
                                        });
                                    }
                                    break;
                            }
                        }
                    }

                };

                module.exports = DOMChildrenOperations;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMLazyTree": 38,
            "./Danger": 42,
            "./ReactDOMComponentTree": 62,
            "./ReactInstrumentation": 91,
            "./createMicrosoftUnsafeLocalFunction": 129,
            "./setInnerHTML": 151,
            "./setTextContent": 152,
            "_process": 28
        }],
        38: [function(_dereq_, module, exports) {

            var DOMNamespaces = _dereq_('./DOMNamespaces');
            var setInnerHTML = _dereq_('./setInnerHTML');

            var createMicrosoftUnsafeLocalFunction = _dereq_('./createMicrosoftUnsafeLocalFunction');
            var setTextContent = _dereq_('./setTextContent');

            var ELEMENT_NODE_TYPE = 1;
            var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

            var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

            function insertTreeChildren(tree) {
                if (!enableLazy) {
                    return;
                }
                var node = tree.node;
                var children = tree.children;
                if (children.length) {
                    for (var i = 0; i < children.length; i++) {
                        insertTreeBefore(node, children[i], null);
                    }
                } else if (tree.html != null) {
                    setInnerHTML(node, tree.html);
                } else if (tree.text != null) {
                    setTextContent(node, tree.text);
                }
            }

            var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function(parentNode, tree, referenceNode) {
                // DocumentFragments aren't actually part of the DOM after insertion so
                // appending children won't update the DOM. We need to ensure the fragment
                // is properly populated first, breaking out of our lazy approach for just
                // this level. Also, some <object> plugins (like Flash Player) will read
                // <param> nodes immediately upon insertion into the DOM, so <object>
                // must also be populated prior to insertion into the DOM.
                if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
                    insertTreeChildren(tree);
                    parentNode.insertBefore(tree.node, referenceNode);
                } else {
                    parentNode.insertBefore(tree.node, referenceNode);
                    insertTreeChildren(tree);
                }
            });

            function replaceChildWithTree(oldNode, newTree) {
                oldNode.parentNode.replaceChild(newTree.node, oldNode);
                insertTreeChildren(newTree);
            }

            function queueChild(parentTree, childTree) {
                if (enableLazy) {
                    parentTree.children.push(childTree);
                } else {
                    parentTree.node.appendChild(childTree.node);
                }
            }

            function queueHTML(tree, html) {
                if (enableLazy) {
                    tree.html = html;
                } else {
                    setInnerHTML(tree.node, html);
                }
            }

            function queueText(tree, text) {
                if (enableLazy) {
                    tree.text = text;
                } else {
                    setTextContent(tree.node, text);
                }
            }

            function toString() {
                return this.node.nodeName;
            }

            function DOMLazyTree(node) {
                return {
                    node: node,
                    children: [],
                    html: null,
                    text: null,
                    toString: toString
                };
            }

            DOMLazyTree.insertTreeBefore = insertTreeBefore;
            DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
            DOMLazyTree.queueChild = queueChild;
            DOMLazyTree.queueHTML = queueHTML;
            DOMLazyTree.queueText = queueText;

            module.exports = DOMLazyTree;
        }, {
            "./DOMNamespaces": 39,
            "./createMicrosoftUnsafeLocalFunction": 129,
            "./setInnerHTML": 151,
            "./setTextContent": 152
        }],
        39: [function(_dereq_, module, exports) {

            var DOMNamespaces = {
                html: 'http://www.w3.org/1999/xhtml',
                mathml: 'http://www.w3.org/1998/Math/MathML',
                svg: 'http://www.w3.org/2000/svg'
            };

            module.exports = DOMNamespaces;
        }, {}],
        40: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                function checkMask(value, bitmask) {
                    return (value & bitmask) === bitmask;
                }

                var DOMPropertyInjection = {

                    MUST_USE_PROPERTY: 0x1,
                    HAS_BOOLEAN_VALUE: 0x4,
                    HAS_NUMERIC_VALUE: 0x8,
                    HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
                    HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,


                    injectDOMPropertyConfig: function(domPropertyConfig) {
                        var Injection = DOMPropertyInjection;
                        var Properties = domPropertyConfig.Properties || {};
                        var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
                        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
                        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
                        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

                        if (domPropertyConfig.isCustomAttribute) {
                            DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
                        }

                        for (var propName in Properties) {
                            !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

                            var lowerCased = propName.toLowerCase();
                            var propConfig = Properties[propName];

                            var propertyInfo = {
                                attributeName: lowerCased,
                                attributeNamespace: null,
                                propertyName: propName,
                                mutationMethod: null,

                                mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
                                hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
                                hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
                                hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
                                hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
                            };
                            !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName): void 0;

                            if (process.env.NODE_ENV !== 'production') {
                                DOMProperty.getPossibleStandardName[lowerCased] = propName;
                            }

                            if (DOMAttributeNames.hasOwnProperty(propName)) {
                                var attributeName = DOMAttributeNames[propName];
                                propertyInfo.attributeName = attributeName;
                                if (process.env.NODE_ENV !== 'production') {
                                    DOMProperty.getPossibleStandardName[attributeName] = propName;
                                }
                            }

                            if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
                                propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
                            }

                            if (DOMPropertyNames.hasOwnProperty(propName)) {
                                propertyInfo.propertyName = DOMPropertyNames[propName];
                            }

                            if (DOMMutationMethods.hasOwnProperty(propName)) {
                                propertyInfo.mutationMethod = DOMMutationMethods[propName];
                            }

                            DOMProperty.properties[propName] = propertyInfo;
                        }
                    }
                };

                var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';

                var DOMProperty = {

                    ID_ATTRIBUTE_NAME: 'data-reactid',
                    ROOT_ATTRIBUTE_NAME: 'data-reactroot',

                    ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
                    ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',


                    properties: {},


                    getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {
                        autofocus: 'autoFocus'
                    } : null,


                    _isCustomAttributeFunctions: [],


                    isCustomAttribute: function(attributeName) {
                        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
                            var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
                            if (isCustomAttributeFn(attributeName)) {
                                return true;
                            }
                        }
                        return false;
                    },

                    injection: DOMPropertyInjection
                };

                module.exports = DOMProperty;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        41: [function(_dereq_, module, exports) {
            (function(process) {

                var DOMProperty = _dereq_('./DOMProperty');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');

                var quoteAttributeValueForBrowser = _dereq_('./quoteAttributeValueForBrowser');
                var warning = _dereq_('fbjs/lib/warning');

                var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
                var illegalAttributeNameCache = {};
                var validatedAttributeNameCache = {};

                function isAttributeNameSafe(attributeName) {
                    if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
                        return true;
                    }
                    if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
                        return false;
                    }
                    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
                        validatedAttributeNameCache[attributeName] = true;
                        return true;
                    }
                    illegalAttributeNameCache[attributeName] = true;
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
                    return false;
                }

                function shouldIgnoreValue(propertyInfo, value) {
                    return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
                }

                var DOMPropertyOperations = {


                    createMarkupForID: function(id) {
                        return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
                    },

                    setAttributeForID: function(node, id) {
                        node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
                    },

                    createMarkupForRoot: function() {
                        return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
                    },

                    setAttributeForRoot: function(node) {
                        node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
                    },


                    createMarkupForProperty: function(name, value) {
                        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
                        if (propertyInfo) {
                            if (shouldIgnoreValue(propertyInfo, value)) {
                                return '';
                            }
                            var attributeName = propertyInfo.attributeName;
                            if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
                                return attributeName + '=""';
                            }
                            return attributeName + '=' + quoteAttributeValueForBrowser(value);
                        } else if (DOMProperty.isCustomAttribute(name)) {
                            if (value == null) {
                                return '';
                            }
                            return name + '=' + quoteAttributeValueForBrowser(value);
                        }
                        return null;
                    },


                    createMarkupForCustomAttribute: function(name, value) {
                        if (!isAttributeNameSafe(name) || value == null) {
                            return '';
                        }
                        return name + '=' + quoteAttributeValueForBrowser(value);
                    },


                    setValueForProperty: function(node, name, value) {
                        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
                        if (propertyInfo) {
                            var mutationMethod = propertyInfo.mutationMethod;
                            if (mutationMethod) {
                                mutationMethod(node, value);
                            } else if (shouldIgnoreValue(propertyInfo, value)) {
                                this.deleteValueForProperty(node, name);
                                return;
                            } else if (propertyInfo.mustUseProperty) {
                                // Contrary to `setAttribute`, object properties are properly
                                // `toString`ed by IE8/9.
                                node[propertyInfo.propertyName] = value;
                            } else {
                                var attributeName = propertyInfo.attributeName;
                                var namespace = propertyInfo.attributeNamespace;
                                // `setAttribute` with objects becomes only `[object]` in IE8/9,
                                // ('' + value) makes it output the correct toString()-value.
                                if (namespace) {
                                    node.setAttributeNS(namespace, attributeName, '' + value);
                                } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
                                    node.setAttribute(attributeName, '');
                                } else {
                                    node.setAttribute(attributeName, '' + value);
                                }
                            }
                        } else if (DOMProperty.isCustomAttribute(name)) {
                            DOMPropertyOperations.setValueForAttribute(node, name, value);
                            return;
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            var payload = {};
                            payload[name] = value;
                            ReactInstrumentation.debugTool.onHostOperation({
                                instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                                type: 'update attribute',
                                payload: payload
                            });
                        }
                    },

                    setValueForAttribute: function(node, name, value) {
                        if (!isAttributeNameSafe(name)) {
                            return;
                        }
                        if (value == null) {
                            node.removeAttribute(name);
                        } else {
                            node.setAttribute(name, '' + value);
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            var payload = {};
                            payload[name] = value;
                            ReactInstrumentation.debugTool.onHostOperation({
                                instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                                type: 'update attribute',
                                payload: payload
                            });
                        }
                    },


                    deleteValueForAttribute: function(node, name) {
                        node.removeAttribute(name);
                        if (process.env.NODE_ENV !== 'production') {
                            ReactInstrumentation.debugTool.onHostOperation({
                                instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                                type: 'remove attribute',
                                payload: name
                            });
                        }
                    },


                    deleteValueForProperty: function(node, name) {
                        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
                        if (propertyInfo) {
                            var mutationMethod = propertyInfo.mutationMethod;
                            if (mutationMethod) {
                                mutationMethod(node, undefined);
                            } else if (propertyInfo.mustUseProperty) {
                                var propName = propertyInfo.propertyName;
                                if (propertyInfo.hasBooleanValue) {
                                    node[propName] = false;
                                } else {
                                    node[propName] = '';
                                }
                            } else {
                                node.removeAttribute(propertyInfo.attributeName);
                            }
                        } else if (DOMProperty.isCustomAttribute(name)) {
                            node.removeAttribute(name);
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            ReactInstrumentation.debugTool.onHostOperation({
                                instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                                type: 'remove attribute',
                                payload: name
                            });
                        }
                    }

                };

                module.exports = DOMPropertyOperations;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMProperty": 40,
            "./ReactDOMComponentTree": 62,
            "./ReactInstrumentation": 91,
            "./quoteAttributeValueForBrowser": 148,
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        42: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var DOMLazyTree = _dereq_('./DOMLazyTree');
                var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');

                var createNodesFromMarkup = _dereq_('fbjs/lib/createNodesFromMarkup');
                var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
                var invariant = _dereq_('fbjs/lib/invariant');

                var Danger = {


                    dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
                        !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
                        !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
                        !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58'): void 0;

                        if (typeof markup === 'string') {
                            var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
                            oldChild.parentNode.replaceChild(newChild, oldChild);
                        } else {
                            DOMLazyTree.replaceChildWithTree(oldChild, markup);
                        }
                    }

                };

                module.exports = Danger;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMLazyTree": 38,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/ExecutionEnvironment": 3,
            "fbjs/lib/createNodesFromMarkup": 8,
            "fbjs/lib/emptyFunction": 9,
            "fbjs/lib/invariant": 17
        }],
        43: [function(_dereq_, module, exports) {

            var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

            module.exports = DefaultEventPluginOrder;
        }, {}],
        44: [function(_dereq_, module, exports) {

            var EventPropagators = _dereq_('./EventPropagators');
            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
            var SyntheticMouseEvent = _dereq_('./SyntheticMouseEvent');

            var eventTypes = {
                mouseEnter: {
                    registrationName: 'onMouseEnter',
                    dependencies: ['topMouseOut', 'topMouseOver']
                },
                mouseLeave: {
                    registrationName: 'onMouseLeave',
                    dependencies: ['topMouseOut', 'topMouseOver']
                }
            };

            var EnterLeaveEventPlugin = {

                eventTypes: eventTypes,


                extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
                        return null;
                    }
                    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
                        // Must not be a mouse in or mouse out - ignoring.
                        return null;
                    }

                    var win;
                    if (nativeEventTarget.window === nativeEventTarget) {
                        // `nativeEventTarget` is probably a window object.
                        win = nativeEventTarget;
                    } else {
                        // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
                        var doc = nativeEventTarget.ownerDocument;
                        if (doc) {
                            win = doc.defaultView || doc.parentWindow;
                        } else {
                            win = window;
                        }
                    }

                    var from;
                    var to;
                    if (topLevelType === 'topMouseOut') {
                        from = targetInst;
                        var related = nativeEvent.relatedTarget || nativeEvent.toElement;
                        to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
                    } else {
                        // Moving to a node from outside the window.
                        from = null;
                        to = targetInst;
                    }

                    if (from === to) {
                        // Nothing pertains to our managed components.
                        return null;
                    }

                    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
                    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

                    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
                    leave.type = 'mouseleave';
                    leave.target = fromNode;
                    leave.relatedTarget = toNode;

                    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
                    enter.type = 'mouseenter';
                    enter.target = toNode;
                    enter.relatedTarget = fromNode;

                    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

                    return [leave, enter];
                }

            };

            module.exports = EnterLeaveEventPlugin;
        }, {
            "./EventPropagators": 48,
            "./ReactDOMComponentTree": 62,
            "./SyntheticMouseEvent": 119
        }],
        45: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var EventPluginRegistry = _dereq_('./EventPluginRegistry');
                var EventPluginUtils = _dereq_('./EventPluginUtils');
                var ReactErrorUtils = _dereq_('./ReactErrorUtils');

                var accumulateInto = _dereq_('./accumulateInto');
                var forEachAccumulated = _dereq_('./forEachAccumulated');
                var invariant = _dereq_('fbjs/lib/invariant');

                var listenerBank = {};

                var eventQueue = null;

                var executeDispatchesAndRelease = function(event, simulated) {
                    if (event) {
                        EventPluginUtils.executeDispatchesInOrder(event, simulated);

                        if (!event.isPersistent()) {
                            event.constructor.release(event);
                        }
                    }
                };
                var executeDispatchesAndReleaseSimulated = function(e) {
                    return executeDispatchesAndRelease(e, true);
                };
                var executeDispatchesAndReleaseTopLevel = function(e) {
                    return executeDispatchesAndRelease(e, false);
                };

                var getDictionaryKey = function(inst) {
                    // Prevents V8 performance issue:
                    // https://github.com/facebook/react/pull/7232
                    return '.' + inst._rootNodeID;
                };

                function isInteractive(tag) {
                    return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
                }

                function shouldPreventMouseEvent(name, type, props) {
                    switch (name) {
                        case 'onClick':
                        case 'onClickCapture':
                        case 'onDoubleClick':
                        case 'onDoubleClickCapture':
                        case 'onMouseDown':
                        case 'onMouseDownCapture':
                        case 'onMouseMove':
                        case 'onMouseMoveCapture':
                        case 'onMouseUp':
                        case 'onMouseUpCapture':
                            return !!(props.disabled && isInteractive(type));
                        default:
                            return false;
                    }
                }

                var EventPluginHub = {


                    injection: {


                        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,


                        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

                    },


                    putListener: function(inst, registrationName, listener) {
                        !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener): void 0;

                        var key = getDictionaryKey(inst);
                        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
                        bankForRegistrationName[key] = listener;

                        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
                        if (PluginModule && PluginModule.didPutListener) {
                            PluginModule.didPutListener(inst, registrationName, listener);
                        }
                    },


                    getListener: function(inst, registrationName) {
                        // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
                        // live here; needs to be moved to a better place soon
                        var bankForRegistrationName = listenerBank[registrationName];
                        if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
                            return null;
                        }
                        var key = getDictionaryKey(inst);
                        return bankForRegistrationName && bankForRegistrationName[key];
                    },


                    deleteListener: function(inst, registrationName) {
                        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
                        if (PluginModule && PluginModule.willDeleteListener) {
                            PluginModule.willDeleteListener(inst, registrationName);
                        }

                        var bankForRegistrationName = listenerBank[registrationName];
                        // TODO: This should never be null -- when is it?
                        if (bankForRegistrationName) {
                            var key = getDictionaryKey(inst);
                            delete bankForRegistrationName[key];
                        }
                    },


                    deleteAllListeners: function(inst) {
                        var key = getDictionaryKey(inst);
                        for (var registrationName in listenerBank) {
                            if (!listenerBank.hasOwnProperty(registrationName)) {
                                continue;
                            }

                            if (!listenerBank[registrationName][key]) {
                                continue;
                            }

                            var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
                            if (PluginModule && PluginModule.willDeleteListener) {
                                PluginModule.willDeleteListener(inst, registrationName);
                            }

                            delete listenerBank[registrationName][key];
                        }
                    },


                    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                        var events;
                        var plugins = EventPluginRegistry.plugins;
                        for (var i = 0; i < plugins.length; i++) {
                            // Not every plugin in the ordering may be loaded at runtime.
                            var possiblePlugin = plugins[i];
                            if (possiblePlugin) {
                                var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
                                if (extractedEvents) {
                                    events = accumulateInto(events, extractedEvents);
                                }
                            }
                        }
                        return events;
                    },


                    enqueueEvents: function(events) {
                        if (events) {
                            eventQueue = accumulateInto(eventQueue, events);
                        }
                    },


                    processEventQueue: function(simulated) {
                        // Set `eventQueue` to null before processing it so that we can tell if more
                        // events get enqueued while processing.
                        var processingEventQueue = eventQueue;
                        eventQueue = null;
                        if (simulated) {
                            forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
                        } else {
                            forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
                        }!!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
                        // This would be a good time to rethrow if any of the event handlers threw.
                        ReactErrorUtils.rethrowCaughtError();
                    },


                    __purge: function() {
                        listenerBank = {};
                    },

                    __getListenerBank: function() {
                        return listenerBank;
                    }

                };

                module.exports = EventPluginHub;
            }).call(this, _dereq_('_process'))
        }, {
            "./EventPluginRegistry": 46,
            "./EventPluginUtils": 47,
            "./ReactErrorUtils": 82,
            "./accumulateInto": 126,
            "./forEachAccumulated": 134,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        46: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                var eventPluginOrder = null;

                var namesToPlugins = {};

                function recomputePluginOrdering() {
                    if (!eventPluginOrder) {
                        // Wait until an `eventPluginOrder` is injected.
                        return;
                    }
                    for (var pluginName in namesToPlugins) {
                        var pluginModule = namesToPlugins[pluginName];
                        var pluginIndex = eventPluginOrder.indexOf(pluginName);
                        !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName): void 0;
                        if (EventPluginRegistry.plugins[pluginIndex]) {
                            continue;
                        }!pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
                        EventPluginRegistry.plugins[pluginIndex] = pluginModule;
                        var publishedEvents = pluginModule.eventTypes;
                        for (var eventName in publishedEvents) {
                            !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
                        }
                    }
                }

                function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
                    !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
                    EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

                    var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
                    if (phasedRegistrationNames) {
                        for (var phaseName in phasedRegistrationNames) {
                            if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                                var phasedRegistrationName = phasedRegistrationNames[phaseName];
                                publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
                            }
                        }
                        return true;
                    } else if (dispatchConfig.registrationName) {
                        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
                        return true;
                    }
                    return false;
                }

                function publishRegistrationName(registrationName, pluginModule, eventName) {
                    !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
                    EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
                    EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

                    if (process.env.NODE_ENV !== 'production') {
                        var lowerCasedName = registrationName.toLowerCase();
                        EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

                        if (registrationName === 'onDoubleClick') {
                            EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
                        }
                    }
                }

                var EventPluginRegistry = {


                    plugins: [],


                    eventNameDispatchConfigs: {},


                    registrationNameModules: {},


                    registrationNameDependencies: {},


                    possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
                    // Trust the developer to only use possibleRegistrationNames in __DEV__


                    injectEventPluginOrder: function(injectedEventPluginOrder) {
                        !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
                        // Clone the ordering so it cannot be dynamically mutated.
                        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
                        recomputePluginOrdering();
                    },


                    injectEventPluginsByName: function(injectedNamesToPlugins) {
                        var isOrderingDirty = false;
                        for (var pluginName in injectedNamesToPlugins) {
                            if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                                continue;
                            }
                            var pluginModule = injectedNamesToPlugins[pluginName];
                            if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
                                !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
                                namesToPlugins[pluginName] = pluginModule;
                                isOrderingDirty = true;
                            }
                        }
                        if (isOrderingDirty) {
                            recomputePluginOrdering();
                        }
                    },


                    getPluginModuleForEvent: function(event) {
                        var dispatchConfig = event.dispatchConfig;
                        if (dispatchConfig.registrationName) {
                            return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
                        }
                        if (dispatchConfig.phasedRegistrationNames !== undefined) {
                            // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
                            // that it is not undefined.
                            var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

                            for (var phase in phasedRegistrationNames) {
                                if (!phasedRegistrationNames.hasOwnProperty(phase)) {
                                    continue;
                                }
                                var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
                                if (pluginModule) {
                                    return pluginModule;
                                }
                            }
                        }
                        return null;
                    },


                    _resetEventPlugins: function() {
                        eventPluginOrder = null;
                        for (var pluginName in namesToPlugins) {
                            if (namesToPlugins.hasOwnProperty(pluginName)) {
                                delete namesToPlugins[pluginName];
                            }
                        }
                        EventPluginRegistry.plugins.length = 0;

                        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
                        for (var eventName in eventNameDispatchConfigs) {
                            if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
                                delete eventNameDispatchConfigs[eventName];
                            }
                        }

                        var registrationNameModules = EventPluginRegistry.registrationNameModules;
                        for (var registrationName in registrationNameModules) {
                            if (registrationNameModules.hasOwnProperty(registrationName)) {
                                delete registrationNameModules[registrationName];
                            }
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
                            for (var lowerCasedName in possibleRegistrationNames) {
                                if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
                                    delete possibleRegistrationNames[lowerCasedName];
                                }
                            }
                        }
                    }

                };

                module.exports = EventPluginRegistry;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        47: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactErrorUtils = _dereq_('./ReactErrorUtils');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                var ComponentTree;
                var TreeTraversal;
                var injection = {
                    injectComponentTree: function(Injected) {
                        ComponentTree = Injected;
                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
                        }
                    },
                    injectTreeTraversal: function(Injected) {
                        TreeTraversal = Injected;
                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
                        }
                    }
                };

                function isEndish(topLevelType) {
                    return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
                }

                function isMoveish(topLevelType) {
                    return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
                }

                function isStartish(topLevelType) {
                    return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
                }

                var validateEventDispatches;
                if (process.env.NODE_ENV !== 'production') {
                    validateEventDispatches = function(event) {
                        var dispatchListeners = event._dispatchListeners;
                        var dispatchInstances = event._dispatchInstances;

                        var listenersIsArr = Array.isArray(dispatchListeners);
                        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

                        var instancesIsArr = Array.isArray(dispatchInstances);
                        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

                        process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
                    };
                }

                function executeDispatch(event, simulated, listener, inst) {
                    var type = event.type || 'unknown-event';
                    event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
                    if (simulated) {
                        ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
                    } else {
                        ReactErrorUtils.invokeGuardedCallback(type, listener, event);
                    }
                    event.currentTarget = null;
                }

                function executeDispatchesInOrder(event, simulated) {
                    var dispatchListeners = event._dispatchListeners;
                    var dispatchInstances = event._dispatchInstances;
                    if (process.env.NODE_ENV !== 'production') {
                        validateEventDispatches(event);
                    }
                    if (Array.isArray(dispatchListeners)) {
                        for (var i = 0; i < dispatchListeners.length; i++) {
                            if (event.isPropagationStopped()) {
                                break;
                            }
                            // Listeners and Instances are two parallel arrays that are always in sync.
                            executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
                        }
                    } else if (dispatchListeners) {
                        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
                    }
                    event._dispatchListeners = null;
                    event._dispatchInstances = null;
                }

                function executeDispatchesInOrderStopAtTrueImpl(event) {
                    var dispatchListeners = event._dispatchListeners;
                    var dispatchInstances = event._dispatchInstances;
                    if (process.env.NODE_ENV !== 'production') {
                        validateEventDispatches(event);
                    }
                    if (Array.isArray(dispatchListeners)) {
                        for (var i = 0; i < dispatchListeners.length; i++) {
                            if (event.isPropagationStopped()) {
                                break;
                            }
                            // Listeners and Instances are two parallel arrays that are always in sync.
                            if (dispatchListeners[i](event, dispatchInstances[i])) {
                                return dispatchInstances[i];
                            }
                        }
                    } else if (dispatchListeners) {
                        if (dispatchListeners(event, dispatchInstances)) {
                            return dispatchInstances;
                        }
                    }
                    return null;
                }

                function executeDispatchesInOrderStopAtTrue(event) {
                    var ret = executeDispatchesInOrderStopAtTrueImpl(event);
                    event._dispatchInstances = null;
                    event._dispatchListeners = null;
                    return ret;
                }

                function executeDirectDispatch(event) {
                    if (process.env.NODE_ENV !== 'production') {
                        validateEventDispatches(event);
                    }
                    var dispatchListener = event._dispatchListeners;
                    var dispatchInstance = event._dispatchInstances;
                    !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
                    event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
                    var res = dispatchListener ? dispatchListener(event) : null;
                    event.currentTarget = null;
                    event._dispatchListeners = null;
                    event._dispatchInstances = null;
                    return res;
                }

                function hasDispatches(event) {
                    return !!event._dispatchListeners;
                }

                var EventPluginUtils = {
                    isEndish: isEndish,
                    isMoveish: isMoveish,
                    isStartish: isStartish,

                    executeDirectDispatch: executeDirectDispatch,
                    executeDispatchesInOrder: executeDispatchesInOrder,
                    executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
                    hasDispatches: hasDispatches,

                    getInstanceFromNode: function(node) {
                        return ComponentTree.getInstanceFromNode(node);
                    },
                    getNodeFromInstance: function(node) {
                        return ComponentTree.getNodeFromInstance(node);
                    },
                    isAncestor: function(a, b) {
                        return TreeTraversal.isAncestor(a, b);
                    },
                    getLowestCommonAncestor: function(a, b) {
                        return TreeTraversal.getLowestCommonAncestor(a, b);
                    },
                    getParentInstance: function(inst) {
                        return TreeTraversal.getParentInstance(inst);
                    },
                    traverseTwoPhase: function(target, fn, arg) {
                        return TreeTraversal.traverseTwoPhase(target, fn, arg);
                    },
                    traverseEnterLeave: function(from, to, fn, argFrom, argTo) {
                        return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
                    },

                    injection: injection
                };

                module.exports = EventPluginUtils;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactErrorUtils": 82,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24
        }],
        48: [function(_dereq_, module, exports) {
            (function(process) {

                var EventPluginHub = _dereq_('./EventPluginHub');
                var EventPluginUtils = _dereq_('./EventPluginUtils');

                var accumulateInto = _dereq_('./accumulateInto');
                var forEachAccumulated = _dereq_('./forEachAccumulated');
                var warning = _dereq_('fbjs/lib/warning');

                var getListener = EventPluginHub.getListener;

                function listenerAtPhase(inst, event, propagationPhase) {
                    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
                    return getListener(inst, registrationName);
                }

                function accumulateDirectionalDispatches(inst, phase, event) {
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
                    }
                    var listener = listenerAtPhase(inst, event, phase);
                    if (listener) {
                        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
                    }
                }

                function accumulateTwoPhaseDispatchesSingle(event) {
                    if (event && event.dispatchConfig.phasedRegistrationNames) {
                        EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
                    }
                }

                function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
                    if (event && event.dispatchConfig.phasedRegistrationNames) {
                        var targetInst = event._targetInst;
                        var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
                        EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
                    }
                }

                function accumulateDispatches(inst, ignoredDirection, event) {
                    if (event && event.dispatchConfig.registrationName) {
                        var registrationName = event.dispatchConfig.registrationName;
                        var listener = getListener(inst, registrationName);
                        if (listener) {
                            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
                        }
                    }
                }

                function accumulateDirectDispatchesSingle(event) {
                    if (event && event.dispatchConfig.registrationName) {
                        accumulateDispatches(event._targetInst, null, event);
                    }
                }

                function accumulateTwoPhaseDispatches(events) {
                    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
                }

                function accumulateTwoPhaseDispatchesSkipTarget(events) {
                    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
                }

                function accumulateEnterLeaveDispatches(leave, enter, from, to) {
                    EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
                }

                function accumulateDirectDispatches(events) {
                    forEachAccumulated(events, accumulateDirectDispatchesSingle);
                }

                var EventPropagators = {
                    accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
                    accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
                    accumulateDirectDispatches: accumulateDirectDispatches,
                    accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
                };

                module.exports = EventPropagators;
            }).call(this, _dereq_('_process'))
        }, {
            "./EventPluginHub": 45,
            "./EventPluginUtils": 47,
            "./accumulateInto": 126,
            "./forEachAccumulated": 134,
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        49: [function(_dereq_, module, exports) {

            var _assign = _dereq_('object-assign');

            var PooledClass = _dereq_('./PooledClass');

            var getTextContentAccessor = _dereq_('./getTextContentAccessor');

            function FallbackCompositionState(root) {
                this._root = root;
                this._startText = this.getText();
                this._fallbackText = null;
            }

            _assign(FallbackCompositionState.prototype, {
                destructor: function() {
                    this._root = null;
                    this._startText = null;
                    this._fallbackText = null;
                },


                getText: function() {
                    if ('value' in this._root) {
                        return this._root.value;
                    }
                    return this._root[getTextContentAccessor()];
                },


                getData: function() {
                    if (this._fallbackText) {
                        return this._fallbackText;
                    }

                    var start;
                    var startValue = this._startText;
                    var startLength = startValue.length;
                    var end;
                    var endValue = this.getText();
                    var endLength = endValue.length;

                    for (start = 0; start < startLength; start++) {
                        if (startValue[start] !== endValue[start]) {
                            break;
                        }
                    }

                    var minEnd = startLength - start;
                    for (end = 1; end <= minEnd; end++) {
                        if (startValue[startLength - end] !== endValue[endLength - end]) {
                            break;
                        }
                    }

                    var sliceTail = end > 1 ? 1 - end : undefined;
                    this._fallbackText = endValue.slice(start, sliceTail);
                    return this._fallbackText;
                }
            });

            PooledClass.addPoolingTo(FallbackCompositionState);

            module.exports = FallbackCompositionState;
        }, {
            "./PooledClass": 53,
            "./getTextContentAccessor": 143,
            "object-assign": 27
        }],
        50: [function(_dereq_, module, exports) {

            var DOMProperty = _dereq_('./DOMProperty');

            var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
            var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
            var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
            var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
            var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

            var HTMLDOMPropertyConfig = {
                isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
                Properties: {

                    accept: 0,
                    acceptCharset: 0,
                    accessKey: 0,
                    action: 0,
                    allowFullScreen: HAS_BOOLEAN_VALUE,
                    allowTransparency: 0,
                    alt: 0,
                    // specifies target context for links with `preload` type
                    as: 0,
                    async: HAS_BOOLEAN_VALUE,
                    autoComplete: 0,
                    // autoFocus is polyfilled/normalized by AutoFocusUtils
                    // autoFocus: HAS_BOOLEAN_VALUE,
                    autoPlay: HAS_BOOLEAN_VALUE,
                    capture: HAS_BOOLEAN_VALUE,
                    cellPadding: 0,
                    cellSpacing: 0,
                    charSet: 0,
                    challenge: 0,
                    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                    cite: 0,
                    classID: 0,
                    className: 0,
                    cols: HAS_POSITIVE_NUMERIC_VALUE,
                    colSpan: 0,
                    content: 0,
                    contentEditable: 0,
                    contextMenu: 0,
                    controls: HAS_BOOLEAN_VALUE,
                    coords: 0,
                    crossOrigin: 0,
                    data: 0, // For `<object />` acts as `src`.
                    dateTime: 0,
                    'default': HAS_BOOLEAN_VALUE,
                    defer: HAS_BOOLEAN_VALUE,
                    dir: 0,
                    disabled: HAS_BOOLEAN_VALUE,
                    download: HAS_OVERLOADED_BOOLEAN_VALUE,
                    draggable: 0,
                    encType: 0,
                    form: 0,
                    formAction: 0,
                    formEncType: 0,
                    formMethod: 0,
                    formNoValidate: HAS_BOOLEAN_VALUE,
                    formTarget: 0,
                    frameBorder: 0,
                    headers: 0,
                    height: 0,
                    hidden: HAS_BOOLEAN_VALUE,
                    high: 0,
                    href: 0,
                    hrefLang: 0,
                    htmlFor: 0,
                    httpEquiv: 0,
                    icon: 0,
                    id: 0,
                    inputMode: 0,
                    integrity: 0,
                    is: 0,
                    keyParams: 0,
                    keyType: 0,
                    kind: 0,
                    label: 0,
                    lang: 0,
                    list: 0,
                    loop: HAS_BOOLEAN_VALUE,
                    low: 0,
                    manifest: 0,
                    marginHeight: 0,
                    marginWidth: 0,
                    max: 0,
                    maxLength: 0,
                    media: 0,
                    mediaGroup: 0,
                    method: 0,
                    min: 0,
                    minLength: 0,
                    // Caution; `option.selected` is not updated if `select.multiple` is
                    // disabled with `removeAttribute`.
                    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                    name: 0,
                    nonce: 0,
                    noValidate: HAS_BOOLEAN_VALUE,
                    open: HAS_BOOLEAN_VALUE,
                    optimum: 0,
                    pattern: 0,
                    placeholder: 0,
                    playsInline: HAS_BOOLEAN_VALUE,
                    poster: 0,
                    preload: 0,
                    profile: 0,
                    radioGroup: 0,
                    readOnly: HAS_BOOLEAN_VALUE,
                    referrerPolicy: 0,
                    rel: 0,
                    required: HAS_BOOLEAN_VALUE,
                    reversed: HAS_BOOLEAN_VALUE,
                    role: 0,
                    rows: HAS_POSITIVE_NUMERIC_VALUE,
                    rowSpan: HAS_NUMERIC_VALUE,
                    sandbox: 0,
                    scope: 0,
                    scoped: HAS_BOOLEAN_VALUE,
                    scrolling: 0,
                    seamless: HAS_BOOLEAN_VALUE,
                    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                    shape: 0,
                    size: HAS_POSITIVE_NUMERIC_VALUE,
                    sizes: 0,
                    span: HAS_POSITIVE_NUMERIC_VALUE,
                    spellCheck: 0,
                    src: 0,
                    srcDoc: 0,
                    srcLang: 0,
                    srcSet: 0,
                    start: HAS_NUMERIC_VALUE,
                    step: 0,
                    style: 0,
                    summary: 0,
                    tabIndex: 0,
                    target: 0,
                    title: 0,
                    // Setting .type throws on non-<input> tags
                    type: 0,
                    useMap: 0,
                    value: 0,
                    width: 0,
                    wmode: 0,
                    wrap: 0,


                    about: 0,
                    datatype: 0,
                    inlist: 0,
                    prefix: 0,
                    // property is also supported for OpenGraph in meta tags.
                    property: 0,
                    resource: 0,
                    'typeof': 0,
                    vocab: 0,


                    // autoCapitalize and autoCorrect are supported in Mobile Safari for
                    // keyboard hints.
                    autoCapitalize: 0,
                    autoCorrect: 0,
                    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
                    autoSave: 0,
                    // color is for Safari mask-icon link
                    color: 0,
                    // itemProp, itemScope, itemType are for
                    // Microdata support. See http://schema.org/docs/gs.html
                    itemProp: 0,
                    itemScope: HAS_BOOLEAN_VALUE,
                    itemType: 0,
                    // itemID and itemRef are for Microdata support as well but
                    // only specified in the WHATWG spec document. See
                    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
                    itemID: 0,
                    itemRef: 0,
                    // results show looking glass icon and recent searches on input
                    // search fields in WebKit/Blink
                    results: 0,
                    // IE-only attribute that specifies security restrictions on an iframe
                    // as an alternative to the sandbox attribute on IE<10
                    security: 0,
                    // IE-only attribute that controls focus behavior
                    unselectable: 0
                },
                DOMAttributeNames: {
                    acceptCharset: 'accept-charset',
                    className: 'class',
                    htmlFor: 'for',
                    httpEquiv: 'http-equiv'
                },
                DOMPropertyNames: {}
            };

            module.exports = HTMLDOMPropertyConfig;
        }, {
            "./DOMProperty": 40
        }],
        51: [function(_dereq_, module, exports) {

            function escape(key) {
                var escapeRegex = /[=:]/g;
                var escaperLookup = {
                    '=': '=0',
                    ':': '=2'
                };
                var escapedString = ('' + key).replace(escapeRegex, function(match) {
                    return escaperLookup[match];
                });

                return '$' + escapedString;
            }

            function unescape(key) {
                var unescapeRegex = /(=0|=2)/g;
                var unescaperLookup = {
                    '=0': '=',
                    '=2': ':'
                };
                var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

                return ('' + keySubstring).replace(unescapeRegex, function(match) {
                    return unescaperLookup[match];
                });
            }

            var KeyEscapeUtils = {
                escape: escape,
                unescape: unescape
            };

            module.exports = KeyEscapeUtils;
        }, {}],
        52: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var React = _dereq_('react/lib/React');
                var ReactPropTypesSecret = _dereq_('./ReactPropTypesSecret');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                var hasReadOnlyValue = {
                    'button': true,
                    'checkbox': true,
                    'image': true,
                    'hidden': true,
                    'radio': true,
                    'reset': true,
                    'submit': true
                };

                function _assertSingleLink(inputProps) {
                    !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87'): void 0;
                }

                function _assertValueLink(inputProps) {
                    _assertSingleLink(inputProps);
                    !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88'): void 0;
                }

                function _assertCheckedLink(inputProps) {
                    _assertSingleLink(inputProps);
                    !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89'): void 0;
                }

                var propTypes = {
                    value: function(props, propName, componentName) {
                        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
                            return null;
                        }
                        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                    },
                    checked: function(props, propName, componentName) {
                        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
                            return null;
                        }
                        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                    },
                    onChange: React.PropTypes.func
                };

                var loggedTypeFailures = {};

                function getDeclarationErrorAddendum(owner) {
                    if (owner) {
                        var name = owner.getName();
                        if (name) {
                            return ' Check the render method of `' + name + '`.';
                        }
                    }
                    return '';
                }

                var LinkedValueUtils = {
                    checkPropTypes: function(tagName, props, owner) {
                        for (var propName in propTypes) {
                            if (propTypes.hasOwnProperty(propName)) {
                                var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
                            }
                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                                // Only monitor this failure once because there tends to be a lot of the
                                // same error.
                                loggedTypeFailures[error.message] = true;

                                var addendum = getDeclarationErrorAddendum(owner);
                                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
                            }
                        }
                    },


                    getValue: function(inputProps) {
                        if (inputProps.valueLink) {
                            _assertValueLink(inputProps);
                            return inputProps.valueLink.value;
                        }
                        return inputProps.value;
                    },


                    getChecked: function(inputProps) {
                        if (inputProps.checkedLink) {
                            _assertCheckedLink(inputProps);
                            return inputProps.checkedLink.value;
                        }
                        return inputProps.checked;
                    },


                    executeOnChange: function(inputProps, event) {
                        if (inputProps.valueLink) {
                            _assertValueLink(inputProps);
                            return inputProps.valueLink.requestChange(event.target.value);
                        } else if (inputProps.checkedLink) {
                            _assertCheckedLink(inputProps);
                            return inputProps.checkedLink.requestChange(event.target.checked);
                        } else if (inputProps.onChange) {
                            return inputProps.onChange.call(undefined, event);
                        }
                    }
                };

                module.exports = LinkedValueUtils;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactPropTypesSecret": 99,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "react/lib/React": 158
        }],
        53: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                var oneArgumentPooler = function(copyFieldsFrom) {
                    var Klass = this;
                    if (Klass.instancePool.length) {
                        var instance = Klass.instancePool.pop();
                        Klass.call(instance, copyFieldsFrom);
                        return instance;
                    } else {
                        return new Klass(copyFieldsFrom);
                    }
                };

                var twoArgumentPooler = function(a1, a2) {
                    var Klass = this;
                    if (Klass.instancePool.length) {
                        var instance = Klass.instancePool.pop();
                        Klass.call(instance, a1, a2);
                        return instance;
                    } else {
                        return new Klass(a1, a2);
                    }
                };

                var threeArgumentPooler = function(a1, a2, a3) {
                    var Klass = this;
                    if (Klass.instancePool.length) {
                        var instance = Klass.instancePool.pop();
                        Klass.call(instance, a1, a2, a3);
                        return instance;
                    } else {
                        return new Klass(a1, a2, a3);
                    }
                };

                var fourArgumentPooler = function(a1, a2, a3, a4) {
                    var Klass = this;
                    if (Klass.instancePool.length) {
                        var instance = Klass.instancePool.pop();
                        Klass.call(instance, a1, a2, a3, a4);
                        return instance;
                    } else {
                        return new Klass(a1, a2, a3, a4);
                    }
                };

                var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
                    var Klass = this;
                    if (Klass.instancePool.length) {
                        var instance = Klass.instancePool.pop();
                        Klass.call(instance, a1, a2, a3, a4, a5);
                        return instance;
                    } else {
                        return new Klass(a1, a2, a3, a4, a5);
                    }
                };

                var standardReleaser = function(instance) {
                    var Klass = this;
                    !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25'): void 0;
                    instance.destructor();
                    if (Klass.instancePool.length < Klass.poolSize) {
                        Klass.instancePool.push(instance);
                    }
                };

                var DEFAULT_POOL_SIZE = 10;
                var DEFAULT_POOLER = oneArgumentPooler;

                var addPoolingTo = function(CopyConstructor, pooler) {
                    // Casting as any so that flow ignores the actual implementation and trusts
                    // it to match the type we declared
                    var NewKlass = CopyConstructor;
                    NewKlass.instancePool = [];
                    NewKlass.getPooled = pooler || DEFAULT_POOLER;
                    if (!NewKlass.poolSize) {
                        NewKlass.poolSize = DEFAULT_POOL_SIZE;
                    }
                    NewKlass.release = standardReleaser;
                    return NewKlass;
                };

                var PooledClass = {
                    addPoolingTo: addPoolingTo,
                    oneArgumentPooler: oneArgumentPooler,
                    twoArgumentPooler: twoArgumentPooler,
                    threeArgumentPooler: threeArgumentPooler,
                    fourArgumentPooler: fourArgumentPooler,
                    fiveArgumentPooler: fiveArgumentPooler
                };

                module.exports = PooledClass;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        54: [function(_dereq_, module, exports) {

            var _assign = _dereq_('object-assign');

            var EventPluginRegistry = _dereq_('./EventPluginRegistry');
            var ReactEventEmitterMixin = _dereq_('./ReactEventEmitterMixin');
            var ViewportMetrics = _dereq_('./ViewportMetrics');

            var getVendorPrefixedEventName = _dereq_('./getVendorPrefixedEventName');
            var isEventSupported = _dereq_('./isEventSupported');

            var hasEventPageXY;
            var alreadyListeningTo = {};
            var isMonitoringScrollValue = false;
            var reactTopListenersCounter = 0;

            // For events like 'submit' which don't consistently bubble (which we trap at a
            // lower node than `document`), binding at `document` would cause duplicate
            // events so we don't include them here
            var topEventMapping = {
                topAbort: 'abort',
                topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
                topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
                topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
                topBlur: 'blur',
                topCanPlay: 'canplay',
                topCanPlayThrough: 'canplaythrough',
                topChange: 'change',
                topClick: 'click',
                topCompositionEnd: 'compositionend',
                topCompositionStart: 'compositionstart',
                topCompositionUpdate: 'compositionupdate',
                topContextMenu: 'contextmenu',
                topCopy: 'copy',
                topCut: 'cut',
                topDoubleClick: 'dblclick',
                topDrag: 'drag',
                topDragEnd: 'dragend',
                topDragEnter: 'dragenter',
                topDragExit: 'dragexit',
                topDragLeave: 'dragleave',
                topDragOver: 'dragover',
                topDragStart: 'dragstart',
                topDrop: 'drop',
                topDurationChange: 'durationchange',
                topEmptied: 'emptied',
                topEncrypted: 'encrypted',
                topEnded: 'ended',
                topError: 'error',
                topFocus: 'focus',
                topInput: 'input',
                topKeyDown: 'keydown',
                topKeyPress: 'keypress',
                topKeyUp: 'keyup',
                topLoadedData: 'loadeddata',
                topLoadedMetadata: 'loadedmetadata',
                topLoadStart: 'loadstart',
                topMouseDown: 'mousedown',
                topMouseMove: 'mousemove',
                topMouseOut: 'mouseout',
                topMouseOver: 'mouseover',
                topMouseUp: 'mouseup',
                topPaste: 'paste',
                topPause: 'pause',
                topPlay: 'play',
                topPlaying: 'playing',
                topProgress: 'progress',
                topRateChange: 'ratechange',
                topScroll: 'scroll',
                topSeeked: 'seeked',
                topSeeking: 'seeking',
                topSelectionChange: 'selectionchange',
                topStalled: 'stalled',
                topSuspend: 'suspend',
                topTextInput: 'textInput',
                topTimeUpdate: 'timeupdate',
                topTouchCancel: 'touchcancel',
                topTouchEnd: 'touchend',
                topTouchMove: 'touchmove',
                topTouchStart: 'touchstart',
                topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
                topVolumeChange: 'volumechange',
                topWaiting: 'waiting',
                topWheel: 'wheel'
            };

            var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

            function getListeningForDocument(mountAt) {
                // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
                // directly.
                if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
                    mountAt[topListenersIDKey] = reactTopListenersCounter++;
                    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
                }
                return alreadyListeningTo[mountAt[topListenersIDKey]];
            }

            var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {


                ReactEventListener: null,

                injection: {

                    injectReactEventListener: function(ReactEventListener) {
                        ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
                        ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
                    }
                },


                setEnabled: function(enabled) {
                    if (ReactBrowserEventEmitter.ReactEventListener) {
                        ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
                    }
                },


                isEnabled: function() {
                    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
                },


                listenTo: function(registrationName, contentDocumentHandle) {
                    var mountAt = contentDocumentHandle;
                    var isListening = getListeningForDocument(mountAt);
                    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

                    for (var i = 0; i < dependencies.length; i++) {
                        var dependency = dependencies[i];
                        if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
                            if (dependency === 'topWheel') {
                                if (isEventSupported('wheel')) {
                                    ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
                                } else if (isEventSupported('mousewheel')) {
                                    ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
                                } else {
                                    // Firefox needs to capture a different mouse scroll event.
                                    // @see http://www.quirksmode.org/dom/events/tests/scroll.html
                                    ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
                                }
                            } else if (dependency === 'topScroll') {

                                if (isEventSupported('scroll', true)) {
                                    ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
                                } else {
                                    ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
                                }
                            } else if (dependency === 'topFocus' || dependency === 'topBlur') {

                                if (isEventSupported('focus', true)) {
                                    ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
                                    ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
                                } else if (isEventSupported('focusin')) {
                                    // IE has `focusin` and `focusout` events which bubble.
                                    // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
                                    ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
                                    ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
                                }

                                // to make sure blur and focus event listeners are only attached once
                                isListening.topBlur = true;
                                isListening.topFocus = true;
                            } else if (topEventMapping.hasOwnProperty(dependency)) {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
                            }

                            isListening[dependency] = true;
                        }
                    }
                },

                trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
                    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
                },

                trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
                    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
                },


                supportsEventPageXY: function() {
                    if (!document.createEvent) {
                        return false;
                    }
                    var ev = document.createEvent('MouseEvent');
                    return ev != null && 'pageX' in ev;
                },


                ensureScrollValueMonitoring: function() {
                    if (hasEventPageXY === undefined) {
                        hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
                    }
                    if (!hasEventPageXY && !isMonitoringScrollValue) {
                        var refresh = ViewportMetrics.refreshScrollValues;
                        ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
                        isMonitoringScrollValue = true;
                    }
                }

            });

            module.exports = ReactBrowserEventEmitter;
        }, {
            "./EventPluginRegistry": 46,
            "./ReactEventEmitterMixin": 83,
            "./ViewportMetrics": 125,
            "./getVendorPrefixedEventName": 144,
            "./isEventSupported": 146,
            "object-assign": 27
        }],
        55: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactReconciler = _dereq_('./ReactReconciler');

                var instantiateReactComponent = _dereq_('./instantiateReactComponent');
                var KeyEscapeUtils = _dereq_('./KeyEscapeUtils');
                var shouldUpdateReactComponent = _dereq_('./shouldUpdateReactComponent');
                var traverseAllChildren = _dereq_('./traverseAllChildren');
                var warning = _dereq_('fbjs/lib/warning');

                var ReactComponentTreeHook;

                if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
                    // Temporary hack.
                    // Inline requires don't work well with Jest:
                    // https://github.com/facebook/react/issues/7240
                    // Remove the inline requires when we don't need them anymore:
                    // https://github.com/facebook/react/pull/7178
                    ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');
                }

                function instantiateChild(childInstances, child, name, selfDebugID) {
                    // We found a component instance.
                    var keyUnique = childInstances[name] === undefined;
                    if (process.env.NODE_ENV !== 'production') {
                        if (!ReactComponentTreeHook) {
                            ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');
                        }
                        if (!keyUnique) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
                        }
                    }
                    if (child != null && keyUnique) {
                        childInstances[name] = instantiateReactComponent(child, true);
                    }
                }

                var ReactChildReconciler = {

                    instantiateChildren: function(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
                    ) {
                        if (nestedChildNodes == null) {
                            return null;
                        }
                        var childInstances = {};

                        if (process.env.NODE_ENV !== 'production') {
                            traverseAllChildren(nestedChildNodes, function(childInsts, child, name) {
                                return instantiateChild(childInsts, child, name, selfDebugID);
                            }, childInstances);
                        } else {
                            traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
                        }
                        return childInstances;
                    },


                    updateChildren: function(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
                    ) {
                        // We currently don't have a way to track moves here but if we use iterators
                        // instead of for..in we can zip the iterators and check if an item has
                        // moved.
                        // TODO: If nothing has changed, return the prevChildren object so that we
                        // can quickly bailout if nothing has changed.
                        if (!nextChildren && !prevChildren) {
                            return;
                        }
                        var name;
                        var prevChild;
                        for (name in nextChildren) {
                            if (!nextChildren.hasOwnProperty(name)) {
                                continue;
                            }
                            prevChild = prevChildren && prevChildren[name];
                            var prevElement = prevChild && prevChild._currentElement;
                            var nextElement = nextChildren[name];
                            if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
                                ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
                                nextChildren[name] = prevChild;
                            } else {
                                if (prevChild) {
                                    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
                                    ReactReconciler.unmountComponent(prevChild, false);
                                }
                                // The child must be instantiated before it's mounted.
                                var nextChildInstance = instantiateReactComponent(nextElement, true);
                                nextChildren[name] = nextChildInstance;
                                // Creating mount image now ensures refs are resolved in right order
                                // (see https://github.com/facebook/react/pull/7101 for explanation).
                                var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
                                mountImages.push(nextChildMountImage);
                            }
                        }
                        // Unmount children that are no longer present.
                        for (name in prevChildren) {
                            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
                                prevChild = prevChildren[name];
                                removedNodes[name] = ReactReconciler.getHostNode(prevChild);
                                ReactReconciler.unmountComponent(prevChild, false);
                            }
                        }
                    },


                    unmountChildren: function(renderedChildren, safely) {
                        for (var name in renderedChildren) {
                            if (renderedChildren.hasOwnProperty(name)) {
                                var renderedChild = renderedChildren[name];
                                ReactReconciler.unmountComponent(renderedChild, safely);
                            }
                        }
                    }

                };

                module.exports = ReactChildReconciler;
            }).call(this, _dereq_('_process'))
        }, {
            "./KeyEscapeUtils": 51,
            "./ReactReconciler": 101,
            "./instantiateReactComponent": 145,
            "./shouldUpdateReactComponent": 153,
            "./traverseAllChildren": 154,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "react/lib/ReactComponentTreeHook": 162
        }],
        56: [function(_dereq_, module, exports) {

            var DOMChildrenOperations = _dereq_('./DOMChildrenOperations');
            var ReactDOMIDOperations = _dereq_('./ReactDOMIDOperations');

            var ReactComponentBrowserEnvironment = {

                processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

                replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

            };

            module.exports = ReactComponentBrowserEnvironment;
        }, {
            "./DOMChildrenOperations": 37,
            "./ReactDOMIDOperations": 66
        }],
        57: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                var injected = false;

                var ReactComponentEnvironment = {


                    replaceNodeWithMarkup: null,


                    processChildrenUpdates: null,

                    injection: {
                        injectEnvironment: function(environment) {
                            !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
                            ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
                            ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
                            injected = true;
                        }
                    }

                };

                module.exports = ReactComponentEnvironment;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        58: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var React = _dereq_('react/lib/React');
                var ReactComponentEnvironment = _dereq_('./ReactComponentEnvironment');
                var ReactCurrentOwner = _dereq_('react/lib/ReactCurrentOwner');
                var ReactErrorUtils = _dereq_('./ReactErrorUtils');
                var ReactInstanceMap = _dereq_('./ReactInstanceMap');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');
                var ReactNodeTypes = _dereq_('./ReactNodeTypes');
                var ReactReconciler = _dereq_('./ReactReconciler');

                if (process.env.NODE_ENV !== 'production') {
                    var checkReactTypeSpec = _dereq_('./checkReactTypeSpec');
                }

                var emptyObject = _dereq_('fbjs/lib/emptyObject');
                var invariant = _dereq_('fbjs/lib/invariant');
                var shallowEqual = _dereq_('fbjs/lib/shallowEqual');
                var shouldUpdateReactComponent = _dereq_('./shouldUpdateReactComponent');
                var warning = _dereq_('fbjs/lib/warning');

                var CompositeTypes = {
                    ImpureClass: 0,
                    PureClass: 1,
                    StatelessFunctional: 2
                };

                function StatelessComponent(Component) {}
                StatelessComponent.prototype.render = function() {
                    var Component = ReactInstanceMap.get(this)._currentElement.type;
                    var element = Component(this.props, this.context, this.updater);
                    warnIfInvalidElement(Component, element);
                    return element;
                };

                function warnIfInvalidElement(Component, element) {
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
                        process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
                    }
                }

                function shouldConstruct(Component) {
                    return !!(Component.prototype && Component.prototype.isReactComponent);
                }

                function isPureComponent(Component) {
                    return !!(Component.prototype && Component.prototype.isPureReactComponent);
                }

                // Separated into a function to contain deoptimizations caused by try/finally.
                function measureLifeCyclePerf(fn, debugID, timerType) {
                    if (debugID === 0) {
                        // Top-level wrappers (see ReactMount) and empty components (see
                        // ReactDOMEmptyComponent) are invisible to hooks and devtools.
                        // Both are implementation details that should go away in the future.
                        return fn();
                    }

                    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
                    try {
                        return fn();
                    } finally {
                        ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
                    }
                }

                var nextMountID = 1;

                var ReactCompositeComponent = {


                    construct: function(element) {
                        this._currentElement = element;
                        this._rootNodeID = 0;
                        this._compositeType = null;
                        this._instance = null;
                        this._hostParent = null;
                        this._hostContainerInfo = null;

                        // See ReactUpdateQueue
                        this._updateBatchNumber = null;
                        this._pendingElement = null;
                        this._pendingStateQueue = null;
                        this._pendingReplaceState = false;
                        this._pendingForceUpdate = false;

                        this._renderedNodeType = null;
                        this._renderedComponent = null;
                        this._context = null;
                        this._mountOrder = 0;
                        this._topLevelWrapper = null;

                        // See ReactUpdates and ReactUpdateQueue.
                        this._pendingCallbacks = null;

                        // ComponentWillUnmount shall only be called once
                        this._calledComponentWillUnmount = false;

                        if (process.env.NODE_ENV !== 'production') {
                            this._warnedAboutRefsInRender = false;
                        }
                    },


                    mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
                        var _this = this;

                        this._context = context;
                        this._mountOrder = nextMountID++;
                        this._hostParent = hostParent;
                        this._hostContainerInfo = hostContainerInfo;

                        var publicProps = this._currentElement.props;
                        var publicContext = this._processContext(context);

                        var Component = this._currentElement.type;

                        var updateQueue = transaction.getUpdateQueue();

                        // Initialize the public class
                        var doConstruct = shouldConstruct(Component);
                        var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
                        var renderedElement;

                        // Support functional components
                        if (!doConstruct && (inst == null || inst.render == null)) {
                            renderedElement = inst;
                            warnIfInvalidElement(Component, renderedElement);
                            !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component'): void 0;
                            inst = new StatelessComponent(Component);
                            this._compositeType = CompositeTypes.StatelessFunctional;
                        } else {
                            if (isPureComponent(Component)) {
                                this._compositeType = CompositeTypes.PureClass;
                            } else {
                                this._compositeType = CompositeTypes.ImpureClass;
                            }
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            // This will throw later in _renderValidatedComponent, but add an early
                            // warning now to help debugging
                            if (inst.render == null) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
                            }

                            var propsMutated = inst.props !== publicProps;
                            var componentName = Component.displayName || Component.name || 'Component';

                            process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
                        }

                        // These should be set up in the constructor, but as a convenience for
                        // simpler class abstractions, we set them up after the fact.
                        inst.props = publicProps;
                        inst.context = publicContext;
                        inst.refs = emptyObject;
                        inst.updater = updateQueue;

                        this._instance = inst;

                        // Store a reference from the instance back to the internal representation
                        ReactInstanceMap.set(inst, this);

                        if (process.env.NODE_ENV !== 'production') {
                            // Since plain JS classes are defined without any special initialization
                            // logic, we can not catch common errors early. Therefore, we have to
                            // catch them here, at initialization time, instead.
                            process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
                            process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
                            process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
                            process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
                            process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
                            process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
                            process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
                        }

                        var initialState = inst.state;
                        if (initialState === undefined) {
                            inst.state = initialState = null;
                        }!(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent'): void 0;

                        this._pendingStateQueue = null;
                        this._pendingReplaceState = false;
                        this._pendingForceUpdate = false;

                        var markup;
                        if (inst.unstable_handleError) {
                            markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
                        } else {
                            markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
                        }

                        if (inst.componentDidMount) {
                            if (process.env.NODE_ENV !== 'production') {
                                transaction.getReactMountReady().enqueue(function() {
                                    measureLifeCyclePerf(function() {
                                        return inst.componentDidMount();
                                    }, _this._debugID, 'componentDidMount');
                                });
                            } else {
                                transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
                            }
                        }

                        return markup;
                    },

                    _constructComponent: function(doConstruct, publicProps, publicContext, updateQueue) {
                        if (process.env.NODE_ENV !== 'production') {
                            ReactCurrentOwner.current = this;
                            try {
                                return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
                            } finally {
                                ReactCurrentOwner.current = null;
                            }
                        } else {
                            return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
                        }
                    },

                    _constructComponentWithoutOwner: function(doConstruct, publicProps, publicContext, updateQueue) {
                        var Component = this._currentElement.type;

                        if (doConstruct) {
                            if (process.env.NODE_ENV !== 'production') {
                                return measureLifeCyclePerf(function() {
                                    return new Component(publicProps, publicContext, updateQueue);
                                }, this._debugID, 'ctor');
                            } else {
                                return new Component(publicProps, publicContext, updateQueue);
                            }
                        }

                        // This can still be an instance in case of factory components
                        // but we'll count this as time spent rendering as the more common case.
                        if (process.env.NODE_ENV !== 'production') {
                            return measureLifeCyclePerf(function() {
                                return Component(publicProps, publicContext, updateQueue);
                            }, this._debugID, 'render');
                        } else {
                            return Component(publicProps, publicContext, updateQueue);
                        }
                    },

                    performInitialMountWithErrorHandling: function(renderedElement, hostParent, hostContainerInfo, transaction, context) {
                        var markup;
                        var checkpoint = transaction.checkpoint();
                        try {
                            markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
                        } catch (e) {
                            // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
                            transaction.rollback(checkpoint);
                            this._instance.unstable_handleError(e);
                            if (this._pendingStateQueue) {
                                this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
                            }
                            checkpoint = transaction.checkpoint();

                            this._renderedComponent.unmountComponent(true);
                            transaction.rollback(checkpoint);

                            // Try again - we've informed the component about the error, so they can render an error message this time.
                            // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
                            markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
                        }
                        return markup;
                    },

                    performInitialMount: function(renderedElement, hostParent, hostContainerInfo, transaction, context) {
                        var inst = this._instance;

                        var debugID = 0;
                        if (process.env.NODE_ENV !== 'production') {
                            debugID = this._debugID;
                        }

                        if (inst.componentWillMount) {
                            if (process.env.NODE_ENV !== 'production') {
                                measureLifeCyclePerf(function() {
                                    return inst.componentWillMount();
                                }, debugID, 'componentWillMount');
                            } else {
                                inst.componentWillMount();
                            }
                            // When mounting, calls to `setState` by `componentWillMount` will set
                            // `this._pendingStateQueue` without triggering a re-render.
                            if (this._pendingStateQueue) {
                                inst.state = this._processPendingState(inst.props, inst.context);
                            }
                        }

                        // If not a stateless component, we now render
                        if (renderedElement === undefined) {
                            renderedElement = this._renderValidatedComponent();
                        }

                        var nodeType = ReactNodeTypes.getType(renderedElement);
                        this._renderedNodeType = nodeType;
                        var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY);
                        this._renderedComponent = child;

                        var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

                        if (process.env.NODE_ENV !== 'production') {
                            if (debugID !== 0) {
                                var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
                                ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
                            }
                        }

                        return markup;
                    },

                    getHostNode: function() {
                        return ReactReconciler.getHostNode(this._renderedComponent);
                    },


                    unmountComponent: function(safely) {
                        if (!this._renderedComponent) {
                            return;
                        }

                        var inst = this._instance;

                        if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
                            inst._calledComponentWillUnmount = true;

                            if (safely) {
                                var name = this.getName() + '.componentWillUnmount()';
                                ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
                            } else {
                                if (process.env.NODE_ENV !== 'production') {
                                    measureLifeCyclePerf(function() {
                                        return inst.componentWillUnmount();
                                    }, this._debugID, 'componentWillUnmount');
                                } else {
                                    inst.componentWillUnmount();
                                }
                            }
                        }

                        if (this._renderedComponent) {
                            ReactReconciler.unmountComponent(this._renderedComponent, safely);
                            this._renderedNodeType = null;
                            this._renderedComponent = null;
                            this._instance = null;
                        }

                        // Reset pending fields
                        // Even if this component is scheduled for another update in ReactUpdates,
                        // it would still be ignored because these fields are reset.
                        this._pendingStateQueue = null;
                        this._pendingReplaceState = false;
                        this._pendingForceUpdate = false;
                        this._pendingCallbacks = null;
                        this._pendingElement = null;

                        // These fields do not really need to be reset since this object is no
                        // longer accessible.
                        this._context = null;
                        this._rootNodeID = 0;
                        this._topLevelWrapper = null;

                        // Delete the reference from the instance to this internal representation
                        // which allow the internals to be properly cleaned up even if the user
                        // leaks a reference to the public instance.
                        ReactInstanceMap.remove(inst);

                        // Some existing components rely on inst.props even after they've been
                        // destroyed (in event handlers).
                        // TODO: inst.props = null;
                        // TODO: inst.state = null;
                        // TODO: inst.context = null;
                    },


                    _maskContext: function(context) {
                        var Component = this._currentElement.type;
                        var contextTypes = Component.contextTypes;
                        if (!contextTypes) {
                            return emptyObject;
                        }
                        var maskedContext = {};
                        for (var contextName in contextTypes) {
                            maskedContext[contextName] = context[contextName];
                        }
                        return maskedContext;
                    },


                    _processContext: function(context) {
                        var maskedContext = this._maskContext(context);
                        if (process.env.NODE_ENV !== 'production') {
                            var Component = this._currentElement.type;
                            if (Component.contextTypes) {
                                this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
                            }
                        }
                        return maskedContext;
                    },


                    _processChildContext: function(currentContext) {
                        var Component = this._currentElement.type;
                        var inst = this._instance;
                        var childContext;

                        if (inst.getChildContext) {
                            if (process.env.NODE_ENV !== 'production') {
                                ReactInstrumentation.debugTool.onBeginProcessingChildContext();
                                try {
                                    childContext = inst.getChildContext();
                                } finally {
                                    ReactInstrumentation.debugTool.onEndProcessingChildContext();
                                }
                            } else {
                                childContext = inst.getChildContext();
                            }
                        }

                        if (childContext) {
                            !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent'): void 0;
                            if (process.env.NODE_ENV !== 'production') {
                                this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
                            }
                            for (var name in childContext) {
                                !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name): void 0;
                            }
                            return _assign({}, currentContext, childContext);
                        }
                        return currentContext;
                    },


                    _checkContextTypes: function(typeSpecs, values, location) {
                        if (process.env.NODE_ENV !== 'production') {
                            checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
                        }
                    },

                    receiveComponent: function(nextElement, transaction, nextContext) {
                        var prevElement = this._currentElement;
                        var prevContext = this._context;

                        this._pendingElement = null;

                        this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
                    },


                    performUpdateIfNecessary: function(transaction) {
                        if (this._pendingElement != null) {
                            ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
                        } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
                            this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
                        } else {
                            this._updateBatchNumber = null;
                        }
                    },


                    updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
                        var inst = this._instance;
                        !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent'): void 0;

                        var willReceive = false;
                        var nextContext;

                        // Determine if the context has changed or not
                        if (this._context === nextUnmaskedContext) {
                            nextContext = inst.context;
                        } else {
                            nextContext = this._processContext(nextUnmaskedContext);
                            willReceive = true;
                        }

                        var prevProps = prevParentElement.props;
                        var nextProps = nextParentElement.props;

                        // Not a simple state update but a props update
                        if (prevParentElement !== nextParentElement) {
                            willReceive = true;
                        }

                        // An update here will schedule an update but immediately set
                        // _pendingStateQueue which will ensure that any state updates gets
                        // immediately reconciled instead of waiting for the next batch.
                        if (willReceive && inst.componentWillReceiveProps) {
                            if (process.env.NODE_ENV !== 'production') {
                                measureLifeCyclePerf(function() {
                                    return inst.componentWillReceiveProps(nextProps, nextContext);
                                }, this._debugID, 'componentWillReceiveProps');
                            } else {
                                inst.componentWillReceiveProps(nextProps, nextContext);
                            }
                        }

                        var nextState = this._processPendingState(nextProps, nextContext);
                        var shouldUpdate = true;

                        if (!this._pendingForceUpdate) {
                            if (inst.shouldComponentUpdate) {
                                if (process.env.NODE_ENV !== 'production') {
                                    shouldUpdate = measureLifeCyclePerf(function() {
                                        return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
                                    }, this._debugID, 'shouldComponentUpdate');
                                } else {
                                    shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
                                }
                            } else {
                                if (this._compositeType === CompositeTypes.PureClass) {
                                    shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
                                }
                            }
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
                        }

                        this._updateBatchNumber = null;
                        if (shouldUpdate) {
                            this._pendingForceUpdate = false;
                            // Will set `this.props`, `this.state` and `this.context`.
                            this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
                        } else {
                            // If it's determined that a component should not update, we still want
                            // to set props and state but we shortcut the rest of the update.
                            this._currentElement = nextParentElement;
                            this._context = nextUnmaskedContext;
                            inst.props = nextProps;
                            inst.state = nextState;
                            inst.context = nextContext;
                        }
                    },

                    _processPendingState: function(props, context) {
                        var inst = this._instance;
                        var queue = this._pendingStateQueue;
                        var replace = this._pendingReplaceState;
                        this._pendingReplaceState = false;
                        this._pendingStateQueue = null;

                        if (!queue) {
                            return inst.state;
                        }

                        if (replace && queue.length === 1) {
                            return queue[0];
                        }

                        var nextState = _assign({}, replace ? queue[0] : inst.state);
                        for (var i = replace ? 1 : 0; i < queue.length; i++) {
                            var partial = queue[i];
                            _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
                        }

                        return nextState;
                    },


                    _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
                        var _this2 = this;

                        var inst = this._instance;

                        var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
                        var prevProps;
                        var prevState;
                        var prevContext;
                        if (hasComponentDidUpdate) {
                            prevProps = inst.props;
                            prevState = inst.state;
                            prevContext = inst.context;
                        }

                        if (inst.componentWillUpdate) {
                            if (process.env.NODE_ENV !== 'production') {
                                measureLifeCyclePerf(function() {
                                    return inst.componentWillUpdate(nextProps, nextState, nextContext);
                                }, this._debugID, 'componentWillUpdate');
                            } else {
                                inst.componentWillUpdate(nextProps, nextState, nextContext);
                            }
                        }

                        this._currentElement = nextElement;
                        this._context = unmaskedContext;
                        inst.props = nextProps;
                        inst.state = nextState;
                        inst.context = nextContext;

                        this._updateRenderedComponent(transaction, unmaskedContext);

                        if (hasComponentDidUpdate) {
                            if (process.env.NODE_ENV !== 'production') {
                                transaction.getReactMountReady().enqueue(function() {
                                    measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
                                });
                            } else {
                                transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
                            }
                        }
                    },


                    _updateRenderedComponent: function(transaction, context) {
                        var prevComponentInstance = this._renderedComponent;
                        var prevRenderedElement = prevComponentInstance._currentElement;
                        var nextRenderedElement = this._renderValidatedComponent();

                        var debugID = 0;
                        if (process.env.NODE_ENV !== 'production') {
                            debugID = this._debugID;
                        }

                        if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
                            ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
                        } else {
                            var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
                            ReactReconciler.unmountComponent(prevComponentInstance, false);

                            var nodeType = ReactNodeTypes.getType(nextRenderedElement);
                            this._renderedNodeType = nodeType;
                            var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY);
                            this._renderedComponent = child;

                            var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

                            if (process.env.NODE_ENV !== 'production') {
                                if (debugID !== 0) {
                                    var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
                                    ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
                                }
                            }

                            this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
                        }
                    },


                    _replaceNodeWithMarkup: function(oldHostNode, nextMarkup, prevInstance) {
                        ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
                    },


                    _renderValidatedComponentWithoutOwnerOrContext: function() {
                        var inst = this._instance;
                        var renderedElement;

                        if (process.env.NODE_ENV !== 'production') {
                            renderedElement = measureLifeCyclePerf(function() {
                                return inst.render();
                            }, this._debugID, 'render');
                        } else {
                            renderedElement = inst.render();
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            // We allow auto-mocks to proceed as if they're returning null.
                            if (renderedElement === undefined && inst.render._isMockFunction) {
                                // This is probably bad practice. Consider warning here and
                                // deprecating this convenience.
                                renderedElement = null;
                            }
                        }

                        return renderedElement;
                    },


                    _renderValidatedComponent: function() {
                        var renderedElement;
                        if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
                            ReactCurrentOwner.current = this;
                            try {
                                renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
                            } finally {
                                ReactCurrentOwner.current = null;
                            }
                        } else {
                            renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
                        }!(
                            // TODO: An `isValidNode` function would probably be more appropriate
                            renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent'): void 0;

                        return renderedElement;
                    },


                    attachRef: function(ref, component) {
                        var inst = this.getPublicInstance();
                        !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110'): void 0;
                        var publicComponentInstance = component.getPublicInstance();
                        if (process.env.NODE_ENV !== 'production') {
                            var componentName = component && component.getName ? component.getName() : 'a component';
                            process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
                        }
                        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
                        refs[ref] = publicComponentInstance;
                    },


                    detachRef: function(ref) {
                        var refs = this.getPublicInstance().refs;
                        delete refs[ref];
                    },


                    getName: function() {
                        var type = this._currentElement.type;
                        var constructor = this._instance && this._instance.constructor;
                        return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
                    },


                    getPublicInstance: function() {
                        var inst = this._instance;
                        if (this._compositeType === CompositeTypes.StatelessFunctional) {
                            return null;
                        }
                        return inst;
                    },

                    // Stub
                    _instantiateReactComponent: null

                };

                module.exports = ReactCompositeComponent;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactComponentEnvironment": 57,
            "./ReactErrorUtils": 82,
            "./ReactInstanceMap": 90,
            "./ReactInstrumentation": 91,
            "./ReactNodeTypes": 96,
            "./ReactReconciler": 101,
            "./checkReactTypeSpec": 128,
            "./reactProdInvariant": 149,
            "./shouldUpdateReactComponent": 153,
            "_process": 28,
            "fbjs/lib/emptyObject": 10,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/shallowEqual": 23,
            "fbjs/lib/warning": 24,
            "object-assign": 27,
            "react/lib/React": 158,
            "react/lib/ReactCurrentOwner": 163
        }],
        59: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactDefaultInjection = _dereq_('./ReactDefaultInjection');
                var ReactMount = _dereq_('./ReactMount');
                var ReactReconciler = _dereq_('./ReactReconciler');
                var ReactUpdates = _dereq_('./ReactUpdates');
                var ReactVersion = _dereq_('./ReactVersion');

                var findDOMNode = _dereq_('./findDOMNode');
                var getHostComponentFromComposite = _dereq_('./getHostComponentFromComposite');
                var renderSubtreeIntoContainer = _dereq_('./renderSubtreeIntoContainer');
                var warning = _dereq_('fbjs/lib/warning');

                ReactDefaultInjection.inject();

                var ReactDOM = {
                    findDOMNode: findDOMNode,
                    render: ReactMount.render,
                    unmountComponentAtNode: ReactMount.unmountComponentAtNode,
                    version: ReactVersion,


                    unstable_batchedUpdates: ReactUpdates.batchedUpdates,
                    unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
                };

                // Inject the runtime into a devtools global hook regardless of browser.
                // Allows for debugging when the hook is injected on the page.
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
                        ComponentTree: {
                            getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
                            getNodeFromInstance: function(inst) {
                                // inst is an internal instance (but could be a composite)
                                if (inst._renderedComponent) {
                                    inst = getHostComponentFromComposite(inst);
                                }
                                if (inst) {
                                    return ReactDOMComponentTree.getNodeFromInstance(inst);
                                } else {
                                    return null;
                                }
                            }
                        },
                        Mount: ReactMount,
                        Reconciler: ReactReconciler
                    });
                }

                if (process.env.NODE_ENV !== 'production') {
                    var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
                    if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

                        // First check if devtools is not installed
                        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                            // If we're in Chrome or Firefox, provide a download link if not installed.
                            if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
                                // Firefox does not have the issue with devtools loaded over file://
                                var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
                                console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
                            }
                        }

                        var testFunc = function testFn() {};
                        process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

                        // If we're in IE8, check to see if we are in compatibility mode and provide
                        // information on preventing compatibility mode
                        var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

                        process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

                        var expectedFeatures = [
                            // shims
                            Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim
                        ];

                        for (var i = 0; i < expectedFeatures.length; i++) {
                            if (!expectedFeatures[i]) {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
                                break;
                            }
                        }
                    }
                }

                if (process.env.NODE_ENV !== 'production') {
                    var ReactInstrumentation = _dereq_('./ReactInstrumentation');
                    var ReactDOMUnknownPropertyHook = _dereq_('./ReactDOMUnknownPropertyHook');
                    var ReactDOMNullInputValuePropHook = _dereq_('./ReactDOMNullInputValuePropHook');
                    var ReactDOMInvalidARIAHook = _dereq_('./ReactDOMInvalidARIAHook');

                    ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
                    ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
                    ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
                }

                module.exports = ReactDOM;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactDOMComponentTree": 62,
            "./ReactDOMInvalidARIAHook": 68,
            "./ReactDOMNullInputValuePropHook": 69,
            "./ReactDOMUnknownPropertyHook": 76,
            "./ReactDefaultInjection": 79,
            "./ReactInstrumentation": 91,
            "./ReactMount": 94,
            "./ReactReconciler": 101,
            "./ReactUpdates": 106,
            "./ReactVersion": 107,
            "./findDOMNode": 132,
            "./getHostComponentFromComposite": 139,
            "./renderSubtreeIntoContainer": 150,
            "_process": 28,
            "fbjs/lib/ExecutionEnvironment": 3,
            "fbjs/lib/warning": 24
        }],
        60: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var AutoFocusUtils = _dereq_('./AutoFocusUtils');
                var CSSPropertyOperations = _dereq_('./CSSPropertyOperations');
                var DOMLazyTree = _dereq_('./DOMLazyTree');
                var DOMNamespaces = _dereq_('./DOMNamespaces');
                var DOMProperty = _dereq_('./DOMProperty');
                var DOMPropertyOperations = _dereq_('./DOMPropertyOperations');
                var EventPluginHub = _dereq_('./EventPluginHub');
                var EventPluginRegistry = _dereq_('./EventPluginRegistry');
                var ReactBrowserEventEmitter = _dereq_('./ReactBrowserEventEmitter');
                var ReactDOMComponentFlags = _dereq_('./ReactDOMComponentFlags');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactDOMInput = _dereq_('./ReactDOMInput');
                var ReactDOMOption = _dereq_('./ReactDOMOption');
                var ReactDOMSelect = _dereq_('./ReactDOMSelect');
                var ReactDOMTextarea = _dereq_('./ReactDOMTextarea');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');
                var ReactMultiChild = _dereq_('./ReactMultiChild');
                var ReactServerRenderingTransaction = _dereq_('./ReactServerRenderingTransaction');

                var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
                var escapeTextContentForBrowser = _dereq_('./escapeTextContentForBrowser');
                var invariant = _dereq_('fbjs/lib/invariant');
                var isEventSupported = _dereq_('./isEventSupported');
                var shallowEqual = _dereq_('fbjs/lib/shallowEqual');
                var validateDOMNesting = _dereq_('./validateDOMNesting');
                var warning = _dereq_('fbjs/lib/warning');

                var Flags = ReactDOMComponentFlags;
                var deleteListener = EventPluginHub.deleteListener;
                var getNode = ReactDOMComponentTree.getNodeFromInstance;
                var listenTo = ReactBrowserEventEmitter.listenTo;
                var registrationNameModules = EventPluginRegistry.registrationNameModules;

                // For quickly matching children type, to test if can be treated as content.
                var CONTENT_TYPES = {
                    'string': true,
                    'number': true
                };

                var STYLE = 'style';
                var HTML = '__html';
                var RESERVED_PROPS = {
                    children: null,
                    dangerouslySetInnerHTML: null,
                    suppressContentEditableWarning: null
                };

                // Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
                var DOC_FRAGMENT_TYPE = 11;

                function getDeclarationErrorAddendum(internalInstance) {
                    if (internalInstance) {
                        var owner = internalInstance._currentElement._owner || null;
                        if (owner) {
                            var name = owner.getName();
                            if (name) {
                                return ' This DOM node was rendered by `' + name + '`.';
                            }
                        }
                    }
                    return '';
                }

                function friendlyStringify(obj) {
                    if (typeof obj === 'object') {
                        if (Array.isArray(obj)) {
                            return '[' + obj.map(friendlyStringify).join(', ') + ']';
                        } else {
                            var pairs = [];
                            for (var key in obj) {
                                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                    var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
                                    pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
                                }
                            }
                            return '{' + pairs.join(', ') + '}';
                        }
                    } else if (typeof obj === 'string') {
                        return JSON.stringify(obj);
                    } else if (typeof obj === 'function') {
                        return '[function object]';
                    }
                    // Differs from JSON.stringify in that undefined because undefined and that
                    // inf and nan don't become null
                    return String(obj);
                }

                var styleMutationWarning = {};

                function checkAndWarnForMutatedStyle(style1, style2, component) {
                    if (style1 == null || style2 == null) {
                        return;
                    }
                    if (shallowEqual(style1, style2)) {
                        return;
                    }

                    var componentName = component._tag;
                    var owner = component._currentElement._owner;
                    var ownerName;
                    if (owner) {
                        ownerName = owner.getName();
                    }

                    var hash = ownerName + '|' + componentName;

                    if (styleMutationWarning.hasOwnProperty(hash)) {
                        return;
                    }

                    styleMutationWarning[hash] = true;

                    process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
                }

                function assertValidProps(component, props) {
                    if (!props) {
                        return;
                    }
                    // Note the use of `==` which checks for null or undefined.
                    if (voidElementTags[component._tag]) {
                        !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : ''): void 0;
                    }
                    if (props.dangerouslySetInnerHTML != null) {
                        !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60'): void 0;
                        !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61'): void 0;
                    }
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
                        process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
                        process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
                    }!(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)): void 0;
                }

                function enqueuePutListener(inst, registrationName, listener, transaction) {
                    if (transaction instanceof ReactServerRenderingTransaction) {
                        return;
                    }
                    if (process.env.NODE_ENV !== 'production') {
                        // IE8 has no API for event capturing and the `onScroll` event doesn't
                        // bubble.
                        process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
                    }
                    var containerInfo = inst._hostContainerInfo;
                    var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
                    var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
                    listenTo(registrationName, doc);
                    transaction.getReactMountReady().enqueue(putListener, {
                        inst: inst,
                        registrationName: registrationName,
                        listener: listener
                    });
                }

                function putListener() {
                    var listenerToPut = this;
                    EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
                }

                function inputPostMount() {
                    var inst = this;
                    ReactDOMInput.postMountWrapper(inst);
                }

                function textareaPostMount() {
                    var inst = this;
                    ReactDOMTextarea.postMountWrapper(inst);
                }

                function optionPostMount() {
                    var inst = this;
                    ReactDOMOption.postMountWrapper(inst);
                }

                var setAndValidateContentChildDev = emptyFunction;
                if (process.env.NODE_ENV !== 'production') {
                    setAndValidateContentChildDev = function(content) {
                        var hasExistingContent = this._contentDebugID != null;
                        var debugID = this._debugID;
                        // This ID represents the inlined child that has no backing instance:
                        var contentDebugID = -debugID;

                        if (content == null) {
                            if (hasExistingContent) {
                                ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
                            }
                            this._contentDebugID = null;
                            return;
                        }

                        validateDOMNesting(null, String(content), this, this._ancestorInfo);
                        this._contentDebugID = contentDebugID;
                        if (hasExistingContent) {
                            ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
                            ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
                        } else {
                            ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
                            ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
                            ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
                        }
                    };
                }

                // There are so many media events, it makes sense to just
                // maintain a list rather than create a `trapBubbledEvent` for each
                var mediaEvents = {
                    topAbort: 'abort',
                    topCanPlay: 'canplay',
                    topCanPlayThrough: 'canplaythrough',
                    topDurationChange: 'durationchange',
                    topEmptied: 'emptied',
                    topEncrypted: 'encrypted',
                    topEnded: 'ended',
                    topError: 'error',
                    topLoadedData: 'loadeddata',
                    topLoadedMetadata: 'loadedmetadata',
                    topLoadStart: 'loadstart',
                    topPause: 'pause',
                    topPlay: 'play',
                    topPlaying: 'playing',
                    topProgress: 'progress',
                    topRateChange: 'ratechange',
                    topSeeked: 'seeked',
                    topSeeking: 'seeking',
                    topStalled: 'stalled',
                    topSuspend: 'suspend',
                    topTimeUpdate: 'timeupdate',
                    topVolumeChange: 'volumechange',
                    topWaiting: 'waiting'
                };

                function trapBubbledEventsLocal() {
                    var inst = this;
                    // If a component renders to null or if another component fatals and causes
                    // the state of the tree to be corrupted, `node` here can be null.
                    !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
                    var node = getNode(inst);
                    !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

                    switch (inst._tag) {
                        case 'iframe':
                        case 'object':
                            inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
                            break;
                        case 'video':
                        case 'audio':

                            inst._wrapperState.listeners = [];
                            // Create listener for each media event
                            for (var event in mediaEvents) {
                                if (mediaEvents.hasOwnProperty(event)) {
                                    inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
                                }
                            }
                            break;
                        case 'source':
                            inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
                            break;
                        case 'img':
                            inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
                            break;
                        case 'form':
                            inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
                            break;
                        case 'input':
                        case 'select':
                        case 'textarea':
                            inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
                            break;
                    }
                }

                function postUpdateSelectWrapper() {
                    ReactDOMSelect.postUpdateWrapper(this);
                }

                // For HTML, certain tags should omit their close tag. We keep a whitelist for
                // those special-case tags.

                var omittedCloseTags = {
                    'area': true,
                    'base': true,
                    'br': true,
                    'col': true,
                    'embed': true,
                    'hr': true,
                    'img': true,
                    'input': true,
                    'keygen': true,
                    'link': true,
                    'meta': true,
                    'param': true,
                    'source': true,
                    'track': true,
                    'wbr': true
                };

                var newlineEatingTags = {
                    'listing': true,
                    'pre': true,
                    'textarea': true
                };

                // For HTML, certain tags cannot have children. This has the same purpose as
                // `omittedCloseTags` except that `menuitem` should still have its closing tag.

                var voidElementTags = _assign({
                    'menuitem': true
                }, omittedCloseTags);

                // We accept any tag to be rendered but since this gets injected into arbitrary
                // HTML, we want to make sure that it's a safe tag.
                // http://www.w3.org/TR/REC-xml/#NT-Name

                var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
                var validatedTagCache = {};
                var hasOwnProperty = {}.hasOwnProperty;

                function validateDangerousTag(tag) {
                    if (!hasOwnProperty.call(validatedTagCache, tag)) {
                        !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
                        validatedTagCache[tag] = true;
                    }
                }

                function isCustomComponent(tagName, props) {
                    return tagName.indexOf('-') >= 0 || props.is != null;
                }

                var globalIdCounter = 1;

                function ReactDOMComponent(element) {
                    var tag = element.type;
                    validateDangerousTag(tag);
                    this._currentElement = element;
                    this._tag = tag.toLowerCase();
                    this._namespaceURI = null;
                    this._renderedChildren = null;
                    this._previousStyle = null;
                    this._previousStyleCopy = null;
                    this._hostNode = null;
                    this._hostParent = null;
                    this._rootNodeID = 0;
                    this._domID = 0;
                    this._hostContainerInfo = null;
                    this._wrapperState = null;
                    this._topLevelWrapper = null;
                    this._flags = 0;
                    if (process.env.NODE_ENV !== 'production') {
                        this._ancestorInfo = null;
                        setAndValidateContentChildDev.call(this, null);
                    }
                }

                ReactDOMComponent.displayName = 'ReactDOMComponent';

                ReactDOMComponent.Mixin = {


                    mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
                        this._rootNodeID = globalIdCounter++;
                        this._domID = hostContainerInfo._idCounter++;
                        this._hostParent = hostParent;
                        this._hostContainerInfo = hostContainerInfo;

                        var props = this._currentElement.props;

                        switch (this._tag) {
                            case 'audio':
                            case 'form':
                            case 'iframe':
                            case 'img':
                            case 'link':
                            case 'object':
                            case 'source':
                            case 'video':
                                this._wrapperState = {
                                    listeners: null
                                };
                                transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                                break;
                            case 'input':
                                ReactDOMInput.mountWrapper(this, props, hostParent);
                                props = ReactDOMInput.getHostProps(this, props);
                                transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                                break;
                            case 'option':
                                ReactDOMOption.mountWrapper(this, props, hostParent);
                                props = ReactDOMOption.getHostProps(this, props);
                                break;
                            case 'select':
                                ReactDOMSelect.mountWrapper(this, props, hostParent);
                                props = ReactDOMSelect.getHostProps(this, props);
                                transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                                break;
                            case 'textarea':
                                ReactDOMTextarea.mountWrapper(this, props, hostParent);
                                props = ReactDOMTextarea.getHostProps(this, props);
                                transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                                break;
                        }

                        assertValidProps(this, props);

                        // We create tags in the namespace of their parent container, except HTML
                        // tags get no namespace.
                        var namespaceURI;
                        var parentTag;
                        if (hostParent != null) {
                            namespaceURI = hostParent._namespaceURI;
                            parentTag = hostParent._tag;
                        } else if (hostContainerInfo._tag) {
                            namespaceURI = hostContainerInfo._namespaceURI;
                            parentTag = hostContainerInfo._tag;
                        }
                        if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
                            namespaceURI = DOMNamespaces.html;
                        }
                        if (namespaceURI === DOMNamespaces.html) {
                            if (this._tag === 'svg') {
                                namespaceURI = DOMNamespaces.svg;
                            } else if (this._tag === 'math') {
                                namespaceURI = DOMNamespaces.mathml;
                            }
                        }
                        this._namespaceURI = namespaceURI;

                        if (process.env.NODE_ENV !== 'production') {
                            var parentInfo;
                            if (hostParent != null) {
                                parentInfo = hostParent._ancestorInfo;
                            } else if (hostContainerInfo._tag) {
                                parentInfo = hostContainerInfo._ancestorInfo;
                            }
                            if (parentInfo) {
                                // parentInfo should always be present except for the top-level
                                // component when server rendering
                                validateDOMNesting(this._tag, null, this, parentInfo);
                            }
                            this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
                        }

                        var mountImage;
                        if (transaction.useCreateElement) {
                            var ownerDocument = hostContainerInfo._ownerDocument;
                            var el;
                            if (namespaceURI === DOMNamespaces.html) {
                                if (this._tag === 'script') {
                                    // Create the script via .innerHTML so its "parser-inserted" flag is
                                    // set to true and it does not execute
                                    var div = ownerDocument.createElement('div');
                                    var type = this._currentElement.type;
                                    div.innerHTML = '<' + type + '></' + type + '>';
                                    el = div.removeChild(div.firstChild);
                                } else if (props.is) {
                                    el = ownerDocument.createElement(this._currentElement.type, props.is);
                                } else {
                                    // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
                                    // See discussion in https://github.com/facebook/react/pull/6896
                                    // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
                                    el = ownerDocument.createElement(this._currentElement.type);
                                }
                            } else {
                                el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
                            }
                            ReactDOMComponentTree.precacheNode(this, el);
                            this._flags |= Flags.hasCachedChildNodes;
                            if (!this._hostParent) {
                                DOMPropertyOperations.setAttributeForRoot(el);
                            }
                            this._updateDOMProperties(null, props, transaction);
                            var lazyTree = DOMLazyTree(el);
                            this._createInitialChildren(transaction, props, context, lazyTree);
                            mountImage = lazyTree;
                        } else {
                            var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
                            var tagContent = this._createContentMarkup(transaction, props, context);
                            if (!tagContent && omittedCloseTags[this._tag]) {
                                mountImage = tagOpen + '/>';
                            } else {
                                mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
                            }
                        }

                        switch (this._tag) {
                            case 'input':
                                transaction.getReactMountReady().enqueue(inputPostMount, this);
                                if (props.autoFocus) {
                                    transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                                }
                                break;
                            case 'textarea':
                                transaction.getReactMountReady().enqueue(textareaPostMount, this);
                                if (props.autoFocus) {
                                    transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                                }
                                break;
                            case 'select':
                                if (props.autoFocus) {
                                    transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                                }
                                break;
                            case 'button':
                                if (props.autoFocus) {
                                    transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                                }
                                break;
                            case 'option':
                                transaction.getReactMountReady().enqueue(optionPostMount, this);
                                break;
                        }

                        return mountImage;
                    },


                    _createOpenTagMarkupAndPutListeners: function(transaction, props) {
                        var ret = '<' + this._currentElement.type;

                        for (var propKey in props) {
                            if (!props.hasOwnProperty(propKey)) {
                                continue;
                            }
                            var propValue = props[propKey];
                            if (propValue == null) {
                                continue;
                            }
                            if (registrationNameModules.hasOwnProperty(propKey)) {
                                if (propValue) {
                                    enqueuePutListener(this, propKey, propValue, transaction);
                                }
                            } else {
                                if (propKey === STYLE) {
                                    if (propValue) {
                                        if (process.env.NODE_ENV !== 'production') {
                                            // See `_updateDOMProperties`. style block
                                            this._previousStyle = propValue;
                                        }
                                        propValue = this._previousStyleCopy = _assign({}, props.style);
                                    }
                                    propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
                                }
                                var markup = null;
                                if (this._tag != null && isCustomComponent(this._tag, props)) {
                                    if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                                        markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
                                    }
                                } else {
                                    markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
                                }
                                if (markup) {
                                    ret += ' ' + markup;
                                }
                            }
                        }

                        // For static pages, no need to put React ID and checksum. Saves lots of
                        // bytes.
                        if (transaction.renderToStaticMarkup) {
                            return ret;
                        }

                        if (!this._hostParent) {
                            ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
                        }
                        ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
                        return ret;
                    },


                    _createContentMarkup: function(transaction, props, context) {
                        var ret = '';

                        // Intentional use of != to avoid catching zero/false.
                        var innerHTML = props.dangerouslySetInnerHTML;
                        if (innerHTML != null) {
                            if (innerHTML.__html != null) {
                                ret = innerHTML.__html;
                            }
                        } else {
                            var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
                            var childrenToUse = contentToUse != null ? null : props.children;
                            if (contentToUse != null) {
                                // TODO: Validate that text is allowed as a child of this node
                                ret = escapeTextContentForBrowser(contentToUse);
                                if (process.env.NODE_ENV !== 'production') {
                                    setAndValidateContentChildDev.call(this, contentToUse);
                                }
                            } else if (childrenToUse != null) {
                                var mountImages = this.mountChildren(childrenToUse, transaction, context);
                                ret = mountImages.join('');
                            }
                        }
                        if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
                            // text/html ignores the first character in these tags if it's a newline
                            // Prefer to break application/xml over text/html (for now) by adding
                            // a newline specifically to get eaten by the parser. (Alternately for
                            // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
                            // \r is normalized out by HTMLTextAreaElement#value.)
                            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
                            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
                            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
                            // See: Parsing of "textarea" "listing" and "pre" elements
                            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
                            return '\n' + ret;
                        } else {
                            return ret;
                        }
                    },

                    _createInitialChildren: function(transaction, props, context, lazyTree) {
                        // Intentional use of != to avoid catching zero/false.
                        var innerHTML = props.dangerouslySetInnerHTML;
                        if (innerHTML != null) {
                            if (innerHTML.__html != null) {
                                DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
                            }
                        } else {
                            var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
                            var childrenToUse = contentToUse != null ? null : props.children;
                            if (contentToUse != null) {
                                // TODO: Validate that text is allowed as a child of this node
                                if (process.env.NODE_ENV !== 'production') {
                                    setAndValidateContentChildDev.call(this, contentToUse);
                                }
                                DOMLazyTree.queueText(lazyTree, contentToUse);
                            } else if (childrenToUse != null) {
                                var mountImages = this.mountChildren(childrenToUse, transaction, context);
                                for (var i = 0; i < mountImages.length; i++) {
                                    DOMLazyTree.queueChild(lazyTree, mountImages[i]);
                                }
                            }
                        }
                    },


                    receiveComponent: function(nextElement, transaction, context) {
                        var prevElement = this._currentElement;
                        this._currentElement = nextElement;
                        this.updateComponent(transaction, prevElement, nextElement, context);
                    },


                    updateComponent: function(transaction, prevElement, nextElement, context) {
                        var lastProps = prevElement.props;
                        var nextProps = this._currentElement.props;

                        switch (this._tag) {
                            case 'input':
                                lastProps = ReactDOMInput.getHostProps(this, lastProps);
                                nextProps = ReactDOMInput.getHostProps(this, nextProps);
                                break;
                            case 'option':
                                lastProps = ReactDOMOption.getHostProps(this, lastProps);
                                nextProps = ReactDOMOption.getHostProps(this, nextProps);
                                break;
                            case 'select':
                                lastProps = ReactDOMSelect.getHostProps(this, lastProps);
                                nextProps = ReactDOMSelect.getHostProps(this, nextProps);
                                break;
                            case 'textarea':
                                lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
                                nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
                                break;
                        }

                        assertValidProps(this, nextProps);
                        this._updateDOMProperties(lastProps, nextProps, transaction);
                        this._updateDOMChildren(lastProps, nextProps, transaction, context);

                        switch (this._tag) {
                            case 'input':
                                // Update the wrapper around inputs *after* updating props. This has to
                                // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
                                // raise warnings and prevent the new value from being assigned.
                                ReactDOMInput.updateWrapper(this);
                                break;
                            case 'textarea':
                                ReactDOMTextarea.updateWrapper(this);
                                break;
                            case 'select':
                                // <select> value update needs to occur after <option> children
                                // reconciliation
                                transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
                                break;
                        }
                    },


                    _updateDOMProperties: function(lastProps, nextProps, transaction) {
                        var propKey;
                        var styleName;
                        var styleUpdates;
                        for (propKey in lastProps) {
                            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                                continue;
                            }
                            if (propKey === STYLE) {
                                var lastStyle = this._previousStyleCopy;
                                for (styleName in lastStyle) {
                                    if (lastStyle.hasOwnProperty(styleName)) {
                                        styleUpdates = styleUpdates || {};
                                        styleUpdates[styleName] = '';
                                    }
                                }
                                this._previousStyleCopy = null;
                            } else if (registrationNameModules.hasOwnProperty(propKey)) {
                                if (lastProps[propKey]) {
                                    // Only call deleteListener if there was a listener previously or
                                    // else willDeleteListener gets called when there wasn't actually a
                                    // listener (e.g., onClick={null})
                                    deleteListener(this, propKey);
                                }
                            } else if (isCustomComponent(this._tag, lastProps)) {
                                if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                                    DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
                                }
                            } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                                DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
                            }
                        }
                        for (propKey in nextProps) {
                            var nextProp = nextProps[propKey];
                            var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
                            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                                continue;
                            }
                            if (propKey === STYLE) {
                                if (nextProp) {
                                    if (process.env.NODE_ENV !== 'production') {
                                        checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
                                        this._previousStyle = nextProp;
                                    }
                                    nextProp = this._previousStyleCopy = _assign({}, nextProp);
                                } else {
                                    this._previousStyleCopy = null;
                                }
                                if (lastProp) {
                                    // Unset styles on `lastProp` but not on `nextProp`.
                                    for (styleName in lastProp) {
                                        if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                                            styleUpdates = styleUpdates || {};
                                            styleUpdates[styleName] = '';
                                        }
                                    }
                                    // Update styles that changed since `lastProp`.
                                    for (styleName in nextProp) {
                                        if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                                            styleUpdates = styleUpdates || {};
                                            styleUpdates[styleName] = nextProp[styleName];
                                        }
                                    }
                                } else {
                                    // Relies on `updateStylesByID` not mutating `styleUpdates`.
                                    styleUpdates = nextProp;
                                }
                            } else if (registrationNameModules.hasOwnProperty(propKey)) {
                                if (nextProp) {
                                    enqueuePutListener(this, propKey, nextProp, transaction);
                                } else if (lastProp) {
                                    deleteListener(this, propKey);
                                }
                            } else if (isCustomComponent(this._tag, nextProps)) {
                                if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                                    DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
                                }
                            } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                                var node = getNode(this);
                                // If we're updating to null or undefined, we should remove the property
                                // from the DOM node instead of inadvertently setting to a string. This
                                // brings us in line with the same behavior we have on initial render.
                                if (nextProp != null) {
                                    DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
                                } else {
                                    DOMPropertyOperations.deleteValueForProperty(node, propKey);
                                }
                            }
                        }
                        if (styleUpdates) {
                            CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
                        }
                    },


                    _updateDOMChildren: function(lastProps, nextProps, transaction, context) {
                        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
                        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

                        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
                        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

                        // Note the use of `!=` which checks for null or undefined.
                        var lastChildren = lastContent != null ? null : lastProps.children;
                        var nextChildren = nextContent != null ? null : nextProps.children;

                        // If we're switching from children to content/html or vice versa, remove
                        // the old content
                        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
                        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
                        if (lastChildren != null && nextChildren == null) {
                            this.updateChildren(null, transaction, context);
                        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
                            this.updateTextContent('');
                            if (process.env.NODE_ENV !== 'production') {
                                ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
                            }
                        }

                        if (nextContent != null) {
                            if (lastContent !== nextContent) {
                                this.updateTextContent('' + nextContent);
                                if (process.env.NODE_ENV !== 'production') {
                                    setAndValidateContentChildDev.call(this, nextContent);
                                }
                            }
                        } else if (nextHtml != null) {
                            if (lastHtml !== nextHtml) {
                                this.updateMarkup('' + nextHtml);
                            }
                            if (process.env.NODE_ENV !== 'production') {
                                ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
                            }
                        } else if (nextChildren != null) {
                            if (process.env.NODE_ENV !== 'production') {
                                setAndValidateContentChildDev.call(this, null);
                            }

                            this.updateChildren(nextChildren, transaction, context);
                        }
                    },

                    getHostNode: function() {
                        return getNode(this);
                    },


                    unmountComponent: function(safely) {
                        switch (this._tag) {
                            case 'audio':
                            case 'form':
                            case 'iframe':
                            case 'img':
                            case 'link':
                            case 'object':
                            case 'source':
                            case 'video':
                                var listeners = this._wrapperState.listeners;
                                if (listeners) {
                                    for (var i = 0; i < listeners.length; i++) {
                                        listeners[i].remove();
                                    }
                                }
                                break;
                            case 'html':
                            case 'head':
                            case 'body':

                                !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
                                break;
                        }

                        this.unmountChildren(safely);
                        ReactDOMComponentTree.uncacheNode(this);
                        EventPluginHub.deleteAllListeners(this);
                        this._rootNodeID = 0;
                        this._domID = 0;
                        this._wrapperState = null;

                        if (process.env.NODE_ENV !== 'production') {
                            setAndValidateContentChildDev.call(this, null);
                        }
                    },

                    getPublicInstance: function() {
                        return getNode(this);
                    }

                };

                _assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

                module.exports = ReactDOMComponent;
            }).call(this, _dereq_('_process'))
        }, {
            "./AutoFocusUtils": 31,
            "./CSSPropertyOperations": 34,
            "./DOMLazyTree": 38,
            "./DOMNamespaces": 39,
            "./DOMProperty": 40,
            "./DOMPropertyOperations": 41,
            "./EventPluginHub": 45,
            "./EventPluginRegistry": 46,
            "./ReactBrowserEventEmitter": 54,
            "./ReactDOMComponentFlags": 61,
            "./ReactDOMComponentTree": 62,
            "./ReactDOMInput": 67,
            "./ReactDOMOption": 70,
            "./ReactDOMSelect": 71,
            "./ReactDOMTextarea": 74,
            "./ReactInstrumentation": 91,
            "./ReactMultiChild": 95,
            "./ReactServerRenderingTransaction": 103,
            "./escapeTextContentForBrowser": 131,
            "./isEventSupported": 146,
            "./reactProdInvariant": 149,
            "./validateDOMNesting": 155,
            "_process": 28,
            "fbjs/lib/emptyFunction": 9,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/shallowEqual": 23,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        61: [function(_dereq_, module, exports) {

            var ReactDOMComponentFlags = {
                hasCachedChildNodes: 1 << 0
            };

            module.exports = ReactDOMComponentFlags;
        }, {}],
        62: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var DOMProperty = _dereq_('./DOMProperty');
                var ReactDOMComponentFlags = _dereq_('./ReactDOMComponentFlags');

                var invariant = _dereq_('fbjs/lib/invariant');

                var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
                var Flags = ReactDOMComponentFlags;

                var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

                function getRenderedHostOrTextFromComponent(component) {
                    var rendered;
                    while (rendered = component._renderedComponent) {
                        component = rendered;
                    }
                    return component;
                }

                function precacheNode(inst, node) {
                    var hostInst = getRenderedHostOrTextFromComponent(inst);
                    hostInst._hostNode = node;
                    node[internalInstanceKey] = hostInst;
                }

                function uncacheNode(inst) {
                    var node = inst._hostNode;
                    if (node) {
                        delete node[internalInstanceKey];
                        inst._hostNode = null;
                    }
                }

                function precacheChildNodes(inst, node) {
                    if (inst._flags & Flags.hasCachedChildNodes) {
                        return;
                    }
                    var children = inst._renderedChildren;
                    var childNode = node.firstChild;
                    outer: for (var name in children) {
                        if (!children.hasOwnProperty(name)) {
                            continue;
                        }
                        var childInst = children[name];
                        var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
                        if (childID === 0) {
                            // We're currently unmounting this child in ReactMultiChild; skip it.
                            continue;
                        }
                        // We assume the child nodes are in the same order as the child instances.
                        for (; childNode !== null; childNode = childNode.nextSibling) {
                            if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
                                precacheNode(childInst, childNode);
                                continue outer;
                            }
                        }
                        // We reached the end of the DOM children without finding an ID match.
                        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
                    }
                    inst._flags |= Flags.hasCachedChildNodes;
                }

                function getClosestInstanceFromNode(node) {
                    if (node[internalInstanceKey]) {
                        return node[internalInstanceKey];
                    }

                    // Walk up the tree until we find an ancestor whose instance we have cached.
                    var parents = [];
                    while (!node[internalInstanceKey]) {
                        parents.push(node);
                        if (node.parentNode) {
                            node = node.parentNode;
                        } else {
                            // Top of the tree. This node must not be part of a React tree (or is
                            // unmounted, potentially).
                            return null;
                        }
                    }

                    var closest;
                    var inst;
                    for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
                        closest = inst;
                        if (parents.length) {
                            precacheChildNodes(inst, node);
                        }
                    }

                    return closest;
                }

                function getInstanceFromNode(node) {
                    var inst = getClosestInstanceFromNode(node);
                    if (inst != null && inst._hostNode === node) {
                        return inst;
                    } else {
                        return null;
                    }
                }

                function getNodeFromInstance(inst) {
                    // Without this first invariant, passing a non-DOM-component triggers the next
                    // invariant for a missing parent, which is super confusing.
                    !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33'): void 0;

                    if (inst._hostNode) {
                        return inst._hostNode;
                    }

                    // Walk up the tree until we find an ancestor whose DOM node we have cached.
                    var parents = [];
                    while (!inst._hostNode) {
                        parents.push(inst);
                        !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
                        inst = inst._hostParent;
                    }

                    // Now parents contains each ancestor that does *not* have a cached native
                    // node, and `inst` is the deepest ancestor that does.
                    for (; parents.length; inst = parents.pop()) {
                        precacheChildNodes(inst, inst._hostNode);
                    }

                    return inst._hostNode;
                }

                var ReactDOMComponentTree = {
                    getClosestInstanceFromNode: getClosestInstanceFromNode,
                    getInstanceFromNode: getInstanceFromNode,
                    getNodeFromInstance: getNodeFromInstance,
                    precacheChildNodes: precacheChildNodes,
                    precacheNode: precacheNode,
                    uncacheNode: uncacheNode
                };

                module.exports = ReactDOMComponentTree;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMProperty": 40,
            "./ReactDOMComponentFlags": 61,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        63: [function(_dereq_, module, exports) {
            (function(process) {

                var validateDOMNesting = _dereq_('./validateDOMNesting');

                var DOC_NODE_TYPE = 9;

                function ReactDOMContainerInfo(topLevelWrapper, node) {
                    var info = {
                        _topLevelWrapper: topLevelWrapper,
                        _idCounter: 1,
                        _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
                        _node: node,
                        _tag: node ? node.nodeName.toLowerCase() : null,
                        _namespaceURI: node ? node.namespaceURI : null
                    };
                    if (process.env.NODE_ENV !== 'production') {
                        info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
                    }
                    return info;
                }

                module.exports = ReactDOMContainerInfo;
            }).call(this, _dereq_('_process'))
        }, {
            "./validateDOMNesting": 155,
            "_process": 28
        }],
        64: [function(_dereq_, module, exports) {

            var _assign = _dereq_('object-assign');

            var DOMLazyTree = _dereq_('./DOMLazyTree');
            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');

            var ReactDOMEmptyComponent = function(instantiate) {
                // ReactCompositeComponent uses this:
                this._currentElement = null;
                // ReactDOMComponentTree uses these:
                this._hostNode = null;
                this._hostParent = null;
                this._hostContainerInfo = null;
                this._domID = 0;
            };
            _assign(ReactDOMEmptyComponent.prototype, {
                mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
                    var domID = hostContainerInfo._idCounter++;
                    this._domID = domID;
                    this._hostParent = hostParent;
                    this._hostContainerInfo = hostContainerInfo;

                    var nodeValue = ' react-empty: ' + this._domID + ' ';
                    if (transaction.useCreateElement) {
                        var ownerDocument = hostContainerInfo._ownerDocument;
                        var node = ownerDocument.createComment(nodeValue);
                        ReactDOMComponentTree.precacheNode(this, node);
                        return DOMLazyTree(node);
                    } else {
                        if (transaction.renderToStaticMarkup) {
                            // Normally we'd insert a comment node, but since this is a situation
                            // where React won't take over (static pages), we can simply return
                            // nothing.
                            return '';
                        }
                        return '<!--' + nodeValue + '-->';
                    }
                },
                receiveComponent: function() {},
                getHostNode: function() {
                    return ReactDOMComponentTree.getNodeFromInstance(this);
                },
                unmountComponent: function() {
                    ReactDOMComponentTree.uncacheNode(this);
                }
            });

            module.exports = ReactDOMEmptyComponent;
        }, {
            "./DOMLazyTree": 38,
            "./ReactDOMComponentTree": 62,
            "object-assign": 27
        }],
        65: [function(_dereq_, module, exports) {

            var ReactDOMFeatureFlags = {
                useCreateElement: true,
                useFiber: false
            };

            module.exports = ReactDOMFeatureFlags;
        }, {}],
        66: [function(_dereq_, module, exports) {

            var DOMChildrenOperations = _dereq_('./DOMChildrenOperations');
            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');

            var ReactDOMIDOperations = {


                dangerouslyProcessChildrenUpdates: function(parentInst, updates) {
                    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
                    DOMChildrenOperations.processUpdates(node, updates);
                }
            };

            module.exports = ReactDOMIDOperations;
        }, {
            "./DOMChildrenOperations": 37,
            "./ReactDOMComponentTree": 62
        }],
        67: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var DOMPropertyOperations = _dereq_('./DOMPropertyOperations');
                var LinkedValueUtils = _dereq_('./LinkedValueUtils');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactUpdates = _dereq_('./ReactUpdates');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                var didWarnValueLink = false;
                var didWarnCheckedLink = false;
                var didWarnValueDefaultValue = false;
                var didWarnCheckedDefaultChecked = false;
                var didWarnControlledToUncontrolled = false;
                var didWarnUncontrolledToControlled = false;

                function forceUpdateIfMounted() {
                    if (this._rootNodeID) {
                        // DOM component is still mounted; update
                        ReactDOMInput.updateWrapper(this);
                    }
                }

                function isControlled(props) {
                    var usesChecked = props.type === 'checkbox' || props.type === 'radio';
                    return usesChecked ? props.checked != null : props.value != null;
                }

                var ReactDOMInput = {
                    getHostProps: function(inst, props) {
                        var value = LinkedValueUtils.getValue(props);
                        var checked = LinkedValueUtils.getChecked(props);

                        var hostProps = _assign({
                            // Make sure we set .type before any other properties (setting .value
                            // before .type means .value is lost in IE11 and below)
                            type: undefined,
                            // Make sure we set .step before .value (setting .value before .step
                            // means .value is rounded on mount, based upon step precision)
                            step: undefined,
                            // Make sure we set .min & .max before .value (to ensure proper order
                            // in corner cases such as min or max deriving from value, e.g. Issue #7170)
                            min: undefined,
                            max: undefined
                        }, props, {
                            defaultChecked: undefined,
                            defaultValue: undefined,
                            value: value != null ? value : inst._wrapperState.initialValue,
                            checked: checked != null ? checked : inst._wrapperState.initialChecked,
                            onChange: inst._wrapperState.onChange
                        });

                        return hostProps;
                    },

                    mountWrapper: function(inst, props) {
                        if (process.env.NODE_ENV !== 'production') {
                            LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

                            var owner = inst._currentElement._owner;

                            if (props.valueLink !== undefined && !didWarnValueLink) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
                                didWarnValueLink = true;
                            }
                            if (props.checkedLink !== undefined && !didWarnCheckedLink) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
                                didWarnCheckedLink = true;
                            }
                            if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                                didWarnCheckedDefaultChecked = true;
                            }
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                                didWarnValueDefaultValue = true;
                            }
                        }

                        var defaultValue = props.defaultValue;
                        inst._wrapperState = {
                            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
                            initialValue: props.value != null ? props.value : defaultValue,
                            listeners: null,
                            onChange: _handleChange.bind(inst)
                        };

                        if (process.env.NODE_ENV !== 'production') {
                            inst._wrapperState.controlled = isControlled(props);
                        }
                    },

                    updateWrapper: function(inst) {
                        var props = inst._currentElement.props;

                        if (process.env.NODE_ENV !== 'production') {
                            var controlled = isControlled(props);
                            var owner = inst._currentElement._owner;

                            if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                                didWarnUncontrolledToControlled = true;
                            }
                            if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                                didWarnControlledToUncontrolled = true;
                            }
                        }

                        // TODO: Shouldn't this be getChecked(props)?
                        var checked = props.checked;
                        if (checked != null) {
                            DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
                        }

                        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                        var value = LinkedValueUtils.getValue(props);
                        if (value != null) {

                            // Cast `value` to a string to ensure the value is set correctly. While
                            // browsers typically do this as necessary, jsdom doesn't.
                            var newValue = '' + value;

                            // To avoid side effects (such as losing text selection), only set value if changed
                            if (newValue !== node.value) {
                                node.value = newValue;
                            }
                        } else {
                            if (props.value == null && props.defaultValue != null) {
                                node.defaultValue = '' + props.defaultValue;
                            }
                            if (props.checked == null && props.defaultChecked != null) {
                                node.defaultChecked = !!props.defaultChecked;
                            }
                        }
                    },

                    postMountWrapper: function(inst) {
                        var props = inst._currentElement.props;

                        // This is in postMount because we need access to the DOM node, which is not
                        // available until after the component has mounted.
                        var node = ReactDOMComponentTree.getNodeFromInstance(inst);

                        // Detach value from defaultValue. We won't do anything if we're working on
                        // submit or reset inputs as those values & defaultValues are linked. They
                        // are not resetable nodes so this operation doesn't matter and actually
                        // removes browser-default values (eg "Submit Query") when no value is
                        // provided.

                        switch (props.type) {
                            case 'submit':
                            case 'reset':
                                break;
                            case 'color':
                            case 'date':
                            case 'datetime':
                            case 'datetime-local':
                            case 'month':
                            case 'time':
                            case 'week':
                                // This fixes the no-show issue on iOS Safari and Android Chrome:
                                // https://github.com/facebook/react/issues/7233
                                node.value = '';
                                node.value = node.defaultValue;
                                break;
                            default:
                                node.value = node.value;
                                break;
                        }

                        // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
                        // this is needed to work around a chrome bug where setting defaultChecked
                        // will sometimes influence the value of checked (even after detachment).
                        // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
                        // We need to temporarily unset name to avoid disrupting radio button groups.
                        var name = node.name;
                        if (name !== '') {
                            node.name = '';
                        }
                        node.defaultChecked = !node.defaultChecked;
                        node.defaultChecked = !node.defaultChecked;
                        if (name !== '') {
                            node.name = name;
                        }
                    }
                };

                function _handleChange(event) {
                    var props = this._currentElement.props;

                    var returnValue = LinkedValueUtils.executeOnChange(props, event);

                    // Here we use asap to wait until all updates have propagated, which
                    // is important when using controlled components within layers:
                    // https://github.com/facebook/react/issues/1698
                    ReactUpdates.asap(forceUpdateIfMounted, this);

                    var name = props.name;
                    if (props.type === 'radio' && name != null) {
                        var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
                        var queryRoot = rootNode;

                        while (queryRoot.parentNode) {
                            queryRoot = queryRoot.parentNode;
                        }

                        // If `rootNode.form` was non-null, then we could try `form.elements`,
                        // but that sometimes behaves strangely in IE8. We could also try using
                        // `form.getElementsByName`, but that will only return direct children
                        // and won't include inputs that use the HTML5 `form=` attribute. Since
                        // the input might not even be in a form, let's just use the global
                        // `querySelectorAll` to ensure we don't miss anything.
                        var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

                        for (var i = 0; i < group.length; i++) {
                            var otherNode = group[i];
                            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                                continue;
                            }
                            // This will throw if radio buttons rendered by different copies of React
                            // and the same name are rendered into the same form (same as #1939).
                            // That's probably okay; we don't support it just as we don't support
                            // mixing React radio buttons with non-React ones.
                            var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
                            !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
                            // If this is a controlled radio button group, forcing the input that
                            // was previously checked to update will cause it to be come re-checked
                            // as appropriate.
                            ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
                        }
                    }

                    return returnValue;
                }

                module.exports = ReactDOMInput;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMPropertyOperations": 41,
            "./LinkedValueUtils": 52,
            "./ReactDOMComponentTree": 62,
            "./ReactUpdates": 106,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        68: [function(_dereq_, module, exports) {
            (function(process) {

                var DOMProperty = _dereq_('./DOMProperty');
                var ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');

                var warning = _dereq_('fbjs/lib/warning');

                var warnedProperties = {};
                var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

                function validateProperty(tagName, name, debugID) {
                    if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
                        return true;
                    }

                    if (rARIA.test(name)) {
                        var lowerCasedName = name.toLowerCase();
                        var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

                        // If this is an aria-* attribute, but is not listed in the known DOM
                        // DOM properties, then it is an invalid aria-* attribute.
                        if (standardName == null) {
                            warnedProperties[name] = true;
                            return false;
                        }
                        // aria-* attributes should be lowercase; suggest the lowercase version.
                        if (name !== standardName) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                            warnedProperties[name] = true;
                            return true;
                        }
                    }

                    return true;
                }

                function warnInvalidARIAProps(debugID, element) {
                    var invalidProps = [];

                    for (var key in element.props) {
                        var isValid = validateProperty(element.type, key, debugID);
                        if (!isValid) {
                            invalidProps.push(key);
                        }
                    }

                    var unknownPropString = invalidProps.map(function(prop) {
                        return '`' + prop + '`';
                    }).join(', ');

                    if (invalidProps.length === 1) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                    } else if (invalidProps.length > 1) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                    }
                }

                function handleElement(debugID, element) {
                    if (element == null || typeof element.type !== 'string') {
                        return;
                    }
                    if (element.type.indexOf('-') >= 0 || element.props.is) {
                        return;
                    }

                    warnInvalidARIAProps(debugID, element);
                }

                var ReactDOMInvalidARIAHook = {
                    onBeforeMountComponent: function(debugID, element) {
                        if (process.env.NODE_ENV !== 'production') {
                            handleElement(debugID, element);
                        }
                    },
                    onBeforeUpdateComponent: function(debugID, element) {
                        if (process.env.NODE_ENV !== 'production') {
                            handleElement(debugID, element);
                        }
                    }
                };

                module.exports = ReactDOMInvalidARIAHook;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMProperty": 40,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "react/lib/ReactComponentTreeHook": 162
        }],
        69: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');

                var warning = _dereq_('fbjs/lib/warning');

                var didWarnValueNull = false;

                function handleElement(debugID, element) {
                    if (element == null) {
                        return;
                    }
                    if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
                        return;
                    }
                    if (element.props != null && element.props.value === null && !didWarnValueNull) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

                        didWarnValueNull = true;
                    }
                }

                var ReactDOMNullInputValuePropHook = {
                    onBeforeMountComponent: function(debugID, element) {
                        handleElement(debugID, element);
                    },
                    onBeforeUpdateComponent: function(debugID, element) {
                        handleElement(debugID, element);
                    }
                };

                module.exports = ReactDOMNullInputValuePropHook;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28,
            "fbjs/lib/warning": 24,
            "react/lib/ReactComponentTreeHook": 162
        }],
        70: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var React = _dereq_('react/lib/React');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactDOMSelect = _dereq_('./ReactDOMSelect');

                var warning = _dereq_('fbjs/lib/warning');
                var didWarnInvalidOptionChildren = false;

                function flattenChildren(children) {
                    var content = '';

                    // Flatten children and warn if they aren't strings or numbers;
                    // invalid types are ignored.
                    React.Children.forEach(children, function(child) {
                        if (child == null) {
                            return;
                        }
                        if (typeof child === 'string' || typeof child === 'number') {
                            content += child;
                        } else if (!didWarnInvalidOptionChildren) {
                            didWarnInvalidOptionChildren = true;
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
                        }
                    });

                    return content;
                }

                var ReactDOMOption = {
                    mountWrapper: function(inst, props, hostParent) {
                        // TODO (yungsters): Remove support for `selected` in <option>.
                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
                        }

                        // Look up whether this option is 'selected'
                        var selectValue = null;
                        if (hostParent != null) {
                            var selectParent = hostParent;

                            if (selectParent._tag === 'optgroup') {
                                selectParent = selectParent._hostParent;
                            }

                            if (selectParent != null && selectParent._tag === 'select') {
                                selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
                            }
                        }

                        // If the value is null (e.g., no specified value or after initial mount)
                        // or missing (e.g., for <datalist>), we don't change props.selected
                        var selected = null;
                        if (selectValue != null) {
                            var value;
                            if (props.value != null) {
                                value = props.value + '';
                            } else {
                                value = flattenChildren(props.children);
                            }
                            selected = false;
                            if (Array.isArray(selectValue)) {
                                // multiple
                                for (var i = 0; i < selectValue.length; i++) {
                                    if ('' + selectValue[i] === value) {
                                        selected = true;
                                        break;
                                    }
                                }
                            } else {
                                selected = '' + selectValue === value;
                            }
                        }

                        inst._wrapperState = {
                            selected: selected
                        };
                    },

                    postMountWrapper: function(inst) {
                        // value="" should make a value attribute (#6219)
                        var props = inst._currentElement.props;
                        if (props.value != null) {
                            var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                            node.setAttribute('value', props.value);
                        }
                    },

                    getHostProps: function(inst, props) {
                        var hostProps = _assign({
                            selected: undefined,
                            children: undefined
                        }, props);

                        // Read state only from initial mount because <select> updates value
                        // manually; we need the initial state only for server rendering
                        if (inst._wrapperState.selected != null) {
                            hostProps.selected = inst._wrapperState.selected;
                        }

                        var content = flattenChildren(props.children);

                        if (content) {
                            hostProps.children = content;
                        }

                        return hostProps;
                    }

                };

                module.exports = ReactDOMOption;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactDOMComponentTree": 62,
            "./ReactDOMSelect": 71,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "object-assign": 27,
            "react/lib/React": 158
        }],
        71: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var LinkedValueUtils = _dereq_('./LinkedValueUtils');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactUpdates = _dereq_('./ReactUpdates');

                var warning = _dereq_('fbjs/lib/warning');

                var didWarnValueLink = false;
                var didWarnValueDefaultValue = false;

                function updateOptionsIfPendingUpdateAndMounted() {
                    if (this._rootNodeID && this._wrapperState.pendingUpdate) {
                        this._wrapperState.pendingUpdate = false;

                        var props = this._currentElement.props;
                        var value = LinkedValueUtils.getValue(props);

                        if (value != null) {
                            updateOptions(this, Boolean(props.multiple), value);
                        }
                    }
                }

                function getDeclarationErrorAddendum(owner) {
                    if (owner) {
                        var name = owner.getName();
                        if (name) {
                            return ' Check the render method of `' + name + '`.';
                        }
                    }
                    return '';
                }

                var valuePropNames = ['value', 'defaultValue'];

                function checkSelectPropTypes(inst, props) {
                    var owner = inst._currentElement._owner;
                    LinkedValueUtils.checkPropTypes('select', props, owner);

                    if (props.valueLink !== undefined && !didWarnValueLink) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
                        didWarnValueLink = true;
                    }

                    for (var i = 0; i < valuePropNames.length; i++) {
                        var propName = valuePropNames[i];
                        if (props[propName] == null) {
                            continue;
                        }
                        var isArray = Array.isArray(props[propName]);
                        if (props.multiple && !isArray) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
                        } else if (!props.multiple && isArray) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
                        }
                    }
                }

                function updateOptions(inst, multiple, propValue) {
                    var selectedValue, i;
                    var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

                    if (multiple) {
                        selectedValue = {};
                        for (i = 0; i < propValue.length; i++) {
                            selectedValue['' + propValue[i]] = true;
                        }
                        for (i = 0; i < options.length; i++) {
                            var selected = selectedValue.hasOwnProperty(options[i].value);
                            if (options[i].selected !== selected) {
                                options[i].selected = selected;
                            }
                        }
                    } else {
                        // Do not set `select.value` as exact behavior isn't consistent across all
                        // browsers for all cases.
                        selectedValue = '' + propValue;
                        for (i = 0; i < options.length; i++) {
                            if (options[i].value === selectedValue) {
                                options[i].selected = true;
                                return;
                            }
                        }
                        if (options.length) {
                            options[0].selected = true;
                        }
                    }
                }

                var ReactDOMSelect = {
                    getHostProps: function(inst, props) {
                        return _assign({}, props, {
                            onChange: inst._wrapperState.onChange,
                            value: undefined
                        });
                    },

                    mountWrapper: function(inst, props) {
                        if (process.env.NODE_ENV !== 'production') {
                            checkSelectPropTypes(inst, props);
                        }

                        var value = LinkedValueUtils.getValue(props);
                        inst._wrapperState = {
                            pendingUpdate: false,
                            initialValue: value != null ? value : props.defaultValue,
                            listeners: null,
                            onChange: _handleChange.bind(inst),
                            wasMultiple: Boolean(props.multiple)
                        };

                        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
                            didWarnValueDefaultValue = true;
                        }
                    },

                    getSelectValueContext: function(inst) {
                        // ReactDOMOption looks at this initial value so the initial generated
                        // markup has correct `selected` attributes
                        return inst._wrapperState.initialValue;
                    },

                    postUpdateWrapper: function(inst) {
                        var props = inst._currentElement.props;

                        // After the initial mount, we control selected-ness manually so don't pass
                        // this value down
                        inst._wrapperState.initialValue = undefined;

                        var wasMultiple = inst._wrapperState.wasMultiple;
                        inst._wrapperState.wasMultiple = Boolean(props.multiple);

                        var value = LinkedValueUtils.getValue(props);
                        if (value != null) {
                            inst._wrapperState.pendingUpdate = false;
                            updateOptions(inst, Boolean(props.multiple), value);
                        } else if (wasMultiple !== Boolean(props.multiple)) {
                            // For simplicity, reapply `defaultValue` if `multiple` is toggled.
                            if (props.defaultValue != null) {
                                updateOptions(inst, Boolean(props.multiple), props.defaultValue);
                            } else {
                                // Revert the select back to its default unselected state.
                                updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
                            }
                        }
                    }
                };

                function _handleChange(event) {
                    var props = this._currentElement.props;
                    var returnValue = LinkedValueUtils.executeOnChange(props, event);

                    if (this._rootNodeID) {
                        this._wrapperState.pendingUpdate = true;
                    }
                    ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
                    return returnValue;
                }

                module.exports = ReactDOMSelect;
            }).call(this, _dereq_('_process'))
        }, {
            "./LinkedValueUtils": 52,
            "./ReactDOMComponentTree": 62,
            "./ReactUpdates": 106,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        72: [function(_dereq_, module, exports) {

            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');

            var getNodeForCharacterOffset = _dereq_('./getNodeForCharacterOffset');
            var getTextContentAccessor = _dereq_('./getTextContentAccessor');

            function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
                return anchorNode === focusNode && anchorOffset === focusOffset;
            }

            function getIEOffsets(node) {
                var selection = document.selection;
                var selectedRange = selection.createRange();
                var selectedLength = selectedRange.text.length;

                // Duplicate selection so we can move range without breaking user selection.
                var fromStart = selectedRange.duplicate();
                fromStart.moveToElementText(node);
                fromStart.setEndPoint('EndToStart', selectedRange);

                var startOffset = fromStart.text.length;
                var endOffset = startOffset + selectedLength;

                return {
                    start: startOffset,
                    end: endOffset
                };
            }

            function getModernOffsets(node) {
                var selection = window.getSelection && window.getSelection();

                if (!selection || selection.rangeCount === 0) {
                    return null;
                }

                var anchorNode = selection.anchorNode;
                var anchorOffset = selection.anchorOffset;
                var focusNode = selection.focusNode;
                var focusOffset = selection.focusOffset;

                var currentRange = selection.getRangeAt(0);

                // In Firefox, range.startContainer and range.endContainer can be "anonymous
                // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
                // divs do not seem to expose properties, triggering a "Permission denied
                // error" if any of its properties are accessed. The only seemingly possible
                // way to avoid erroring is to access a property that typically works for
                // non-anonymous divs and catch any error that may otherwise arise. See
                // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
                try {

                    currentRange.startContainer.nodeType;
                    currentRange.endContainer.nodeType;

                } catch (e) {
                    return null;
                }

                // If the node and offset values are the same, the selection is collapsed.
                // `Selection.isCollapsed` is available natively, but IE sometimes gets
                // this value wrong.
                var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

                var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

                var tempRange = currentRange.cloneRange();
                tempRange.selectNodeContents(node);
                tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

                var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

                var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
                var end = start + rangeLength;

                // Detect whether the selection is backward.
                var detectionRange = document.createRange();
                detectionRange.setStart(anchorNode, anchorOffset);
                detectionRange.setEnd(focusNode, focusOffset);
                var isBackward = detectionRange.collapsed;

                return {
                    start: isBackward ? end : start,
                    end: isBackward ? start : end
                };
            }

            function setIEOffsets(node, offsets) {
                var range = document.selection.createRange().duplicate();
                var start, end;

                if (offsets.end === undefined) {
                    start = offsets.start;
                    end = start;
                } else if (offsets.start > offsets.end) {
                    start = offsets.end;
                    end = offsets.start;
                } else {
                    start = offsets.start;
                    end = offsets.end;
                }

                range.moveToElementText(node);
                range.moveStart('character', start);
                range.setEndPoint('EndToStart', range);
                range.moveEnd('character', end - start);
                range.select();
            }

            function setModernOffsets(node, offsets) {
                if (!window.getSelection) {
                    return;
                }

                var selection = window.getSelection();
                var length = node[getTextContentAccessor()].length;
                var start = Math.min(offsets.start, length);
                var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

                // IE 11 uses modern selection, but doesn't support the extend method.
                // Flip backward selections, so we can set with a single range.
                if (!selection.extend && start > end) {
                    var temp = end;
                    end = start;
                    start = temp;
                }

                var startMarker = getNodeForCharacterOffset(node, start);
                var endMarker = getNodeForCharacterOffset(node, end);

                if (startMarker && endMarker) {
                    var range = document.createRange();
                    range.setStart(startMarker.node, startMarker.offset);
                    selection.removeAllRanges();

                    if (start > end) {
                        selection.addRange(range);
                        selection.extend(endMarker.node, endMarker.offset);
                    } else {
                        range.setEnd(endMarker.node, endMarker.offset);
                        selection.addRange(range);
                    }
                }
            }

            var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

            var ReactDOMSelection = {

                getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,


                setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
            };

            module.exports = ReactDOMSelection;
        }, {
            "./getNodeForCharacterOffset": 142,
            "./getTextContentAccessor": 143,
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        73: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var DOMChildrenOperations = _dereq_('./DOMChildrenOperations');
                var DOMLazyTree = _dereq_('./DOMLazyTree');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');

                var escapeTextContentForBrowser = _dereq_('./escapeTextContentForBrowser');
                var invariant = _dereq_('fbjs/lib/invariant');
                var validateDOMNesting = _dereq_('./validateDOMNesting');

                var ReactDOMTextComponent = function(text) {
                    // TODO: This is really a ReactText (ReactNode), not a ReactElement
                    this._currentElement = text;
                    this._stringText = '' + text;
                    // ReactDOMComponentTree uses these:
                    this._hostNode = null;
                    this._hostParent = null;

                    // Properties
                    this._domID = 0;
                    this._mountIndex = 0;
                    this._closingComment = null;
                    this._commentNodes = null;
                };

                _assign(ReactDOMTextComponent.prototype, {


                    mountComponent: function(transaction, hostParent, hostContainerInfo, context) {
                        if (process.env.NODE_ENV !== 'production') {
                            var parentInfo;
                            if (hostParent != null) {
                                parentInfo = hostParent._ancestorInfo;
                            } else if (hostContainerInfo != null) {
                                parentInfo = hostContainerInfo._ancestorInfo;
                            }
                            if (parentInfo) {
                                // parentInfo should always be present except for the top-level
                                // component when server rendering
                                validateDOMNesting(null, this._stringText, this, parentInfo);
                            }
                        }

                        var domID = hostContainerInfo._idCounter++;
                        var openingValue = ' react-text: ' + domID + ' ';
                        var closingValue = ' /react-text ';
                        this._domID = domID;
                        this._hostParent = hostParent;
                        if (transaction.useCreateElement) {
                            var ownerDocument = hostContainerInfo._ownerDocument;
                            var openingComment = ownerDocument.createComment(openingValue);
                            var closingComment = ownerDocument.createComment(closingValue);
                            var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
                            DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
                            if (this._stringText) {
                                DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
                            }
                            DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
                            ReactDOMComponentTree.precacheNode(this, openingComment);
                            this._closingComment = closingComment;
                            return lazyTree;
                        } else {
                            var escapedText = escapeTextContentForBrowser(this._stringText);

                            if (transaction.renderToStaticMarkup) {
                                // Normally we'd wrap this between comment nodes for the reasons stated
                                // above, but since this is a situation where React won't take over
                                // (static pages), we can simply return the text as it is.
                                return escapedText;
                            }

                            return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
                        }
                    },


                    receiveComponent: function(nextText, transaction) {
                        if (nextText !== this._currentElement) {
                            this._currentElement = nextText;
                            var nextStringText = '' + nextText;
                            if (nextStringText !== this._stringText) {
                                // TODO: Save this as pending props and use performUpdateIfNecessary
                                // and/or updateComponent to do the actual update for consistency with
                                // other component types?
                                this._stringText = nextStringText;
                                var commentNodes = this.getHostNode();
                                DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
                            }
                        }
                    },

                    getHostNode: function() {
                        var hostNode = this._commentNodes;
                        if (hostNode) {
                            return hostNode;
                        }
                        if (!this._closingComment) {
                            var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
                            var node = openingComment.nextSibling;
                            while (true) {
                                !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID): void 0;
                                if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
                                    this._closingComment = node;
                                    break;
                                }
                                node = node.nextSibling;
                            }
                        }
                        hostNode = [this._hostNode, this._closingComment];
                        this._commentNodes = hostNode;
                        return hostNode;
                    },

                    unmountComponent: function() {
                        this._closingComment = null;
                        this._commentNodes = null;
                        ReactDOMComponentTree.uncacheNode(this);
                    }

                });

                module.exports = ReactDOMTextComponent;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMChildrenOperations": 37,
            "./DOMLazyTree": 38,
            "./ReactDOMComponentTree": 62,
            "./escapeTextContentForBrowser": 131,
            "./reactProdInvariant": 149,
            "./validateDOMNesting": 155,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "object-assign": 27
        }],
        74: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var LinkedValueUtils = _dereq_('./LinkedValueUtils');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactUpdates = _dereq_('./ReactUpdates');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                var didWarnValueLink = false;
                var didWarnValDefaultVal = false;

                function forceUpdateIfMounted() {
                    if (this._rootNodeID) {
                        // DOM component is still mounted; update
                        ReactDOMTextarea.updateWrapper(this);
                    }
                }

                var ReactDOMTextarea = {
                    getHostProps: function(inst, props) {
                        !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91'): void 0;

                        // Always set children to the same thing. In IE9, the selection range will
                        // get reset if `textContent` is mutated.  We could add a check in setTextContent
                        // to only set the value if/when the value differs from the node value (which would
                        // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
                        // The value can be a boolean or object so that's why it's forced to be a string.
                        var hostProps = _assign({}, props, {
                            value: undefined,
                            defaultValue: undefined,
                            children: '' + inst._wrapperState.initialValue,
                            onChange: inst._wrapperState.onChange
                        });

                        return hostProps;
                    },

                    mountWrapper: function(inst, props) {
                        if (process.env.NODE_ENV !== 'production') {
                            LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
                            if (props.valueLink !== undefined && !didWarnValueLink) {
                                process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
                                didWarnValueLink = true;
                            }
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
                                didWarnValDefaultVal = true;
                            }
                        }

                        var value = LinkedValueUtils.getValue(props);
                        var initialValue = value;

                        // Only bother fetching default value if we're going to use it
                        if (value == null) {
                            var defaultValue = props.defaultValue;
                            // TODO (yungsters): Remove support for children content in <textarea>.
                            var children = props.children;
                            if (children != null) {
                                if (process.env.NODE_ENV !== 'production') {
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
                                }!(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92'): void 0;
                                if (Array.isArray(children)) {
                                    !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93'): void 0;
                                    children = children[0];
                                }

                                defaultValue = '' + children;
                            }
                            if (defaultValue == null) {
                                defaultValue = '';
                            }
                            initialValue = defaultValue;
                        }

                        inst._wrapperState = {
                            initialValue: '' + initialValue,
                            listeners: null,
                            onChange: _handleChange.bind(inst)
                        };
                    },

                    updateWrapper: function(inst) {
                        var props = inst._currentElement.props;

                        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                        var value = LinkedValueUtils.getValue(props);
                        if (value != null) {
                            // Cast `value` to a string to ensure the value is set correctly. While
                            // browsers typically do this as necessary, jsdom doesn't.
                            var newValue = '' + value;

                            // To avoid side effects (such as losing text selection), only set value if changed
                            if (newValue !== node.value) {
                                node.value = newValue;
                            }
                            if (props.defaultValue == null) {
                                node.defaultValue = newValue;
                            }
                        }
                        if (props.defaultValue != null) {
                            node.defaultValue = props.defaultValue;
                        }
                    },

                    postMountWrapper: function(inst) {
                        // This is in postMount because we need access to the DOM node, which is not
                        // available until after the component has mounted.
                        var node = ReactDOMComponentTree.getNodeFromInstance(inst);

                        // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
                        node.value = node.textContent; // Detach value from defaultValue
                    }
                };

                function _handleChange(event) {
                    var props = this._currentElement.props;
                    var returnValue = LinkedValueUtils.executeOnChange(props, event);
                    ReactUpdates.asap(forceUpdateIfMounted, this);
                    return returnValue;
                }

                module.exports = ReactDOMTextarea;
            }).call(this, _dereq_('_process'))
        }, {
            "./LinkedValueUtils": 52,
            "./ReactDOMComponentTree": 62,
            "./ReactUpdates": 106,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        75: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                function getLowestCommonAncestor(instA, instB) {
                    !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33'): void 0;
                    !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33'): void 0;

                    var depthA = 0;
                    for (var tempA = instA; tempA; tempA = tempA._hostParent) {
                        depthA++;
                    }
                    var depthB = 0;
                    for (var tempB = instB; tempB; tempB = tempB._hostParent) {
                        depthB++;
                    }

                    // If A is deeper, crawl up.
                    while (depthA - depthB > 0) {
                        instA = instA._hostParent;
                        depthA--;
                    }

                    // If B is deeper, crawl up.
                    while (depthB - depthA > 0) {
                        instB = instB._hostParent;
                        depthB--;
                    }

                    // Walk in lockstep until we find a match.
                    var depth = depthA;
                    while (depth--) {
                        if (instA === instB) {
                            return instA;
                        }
                        instA = instA._hostParent;
                        instB = instB._hostParent;
                    }
                    return null;
                }

                function isAncestor(instA, instB) {
                    !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35'): void 0;
                    !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35'): void 0;

                    while (instB) {
                        if (instB === instA) {
                            return true;
                        }
                        instB = instB._hostParent;
                    }
                    return false;
                }

                function getParentInstance(inst) {
                    !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36'): void 0;

                    return inst._hostParent;
                }

                function traverseTwoPhase(inst, fn, arg) {
                    var path = [];
                    while (inst) {
                        path.push(inst);
                        inst = inst._hostParent;
                    }
                    var i;
                    for (i = path.length; i-- > 0;) {
                        fn(path[i], 'captured', arg);
                    }
                    for (i = 0; i < path.length; i++) {
                        fn(path[i], 'bubbled', arg);
                    }
                }

                function traverseEnterLeave(from, to, fn, argFrom, argTo) {
                    var common = from && to ? getLowestCommonAncestor(from, to) : null;
                    var pathFrom = [];
                    while (from && from !== common) {
                        pathFrom.push(from);
                        from = from._hostParent;
                    }
                    var pathTo = [];
                    while (to && to !== common) {
                        pathTo.push(to);
                        to = to._hostParent;
                    }
                    var i;
                    for (i = 0; i < pathFrom.length; i++) {
                        fn(pathFrom[i], 'bubbled', argFrom);
                    }
                    for (i = pathTo.length; i-- > 0;) {
                        fn(pathTo[i], 'captured', argTo);
                    }
                }

                module.exports = {
                    isAncestor: isAncestor,
                    getLowestCommonAncestor: getLowestCommonAncestor,
                    getParentInstance: getParentInstance,
                    traverseTwoPhase: traverseTwoPhase,
                    traverseEnterLeave: traverseEnterLeave
                };
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        76: [function(_dereq_, module, exports) {
            (function(process) {

                var DOMProperty = _dereq_('./DOMProperty');
                var EventPluginRegistry = _dereq_('./EventPluginRegistry');
                var ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');

                var warning = _dereq_('fbjs/lib/warning');

                if (process.env.NODE_ENV !== 'production') {
                    var reactProps = {
                        children: true,
                        dangerouslySetInnerHTML: true,
                        key: true,
                        ref: true,

                        autoFocus: true,
                        defaultValue: true,
                        valueLink: true,
                        defaultChecked: true,
                        checkedLink: true,
                        innerHTML: true,
                        suppressContentEditableWarning: true,
                        onFocusIn: true,
                        onFocusOut: true
                    };
                    var warnedProperties = {};

                    var validateProperty = function(tagName, name, debugID) {
                        if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
                            return true;
                        }
                        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
                            return true;
                        }
                        if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
                            return true;
                        }
                        warnedProperties[name] = true;
                        var lowerCasedName = name.toLowerCase();

                        // data-* attributes should be lowercase; suggest the lowercase version
                        var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

                        var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

                        if (standardName != null) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                            return true;
                        } else if (registrationName != null) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                            return true;
                        } else {
                            // We were unable to guess which prop the user intended.
                            // It is likely that the user was just blindly spreading/forwarding props
                            // Components should be careful to only render valid props/attributes.
                            // Warning will be invoked in warnUnknownProperties to allow grouping.
                            return false;
                        }
                    };
                }

                var warnUnknownProperties = function(debugID, element) {
                    var unknownProps = [];
                    for (var key in element.props) {
                        var isValid = validateProperty(element.type, key, debugID);
                        if (!isValid) {
                            unknownProps.push(key);
                        }
                    }

                    var unknownPropString = unknownProps.map(function(prop) {
                        return '`' + prop + '`';
                    }).join(', ');

                    if (unknownProps.length === 1) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                    } else if (unknownProps.length > 1) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                    }
                };

                function handleElement(debugID, element) {
                    if (element == null || typeof element.type !== 'string') {
                        return;
                    }
                    if (element.type.indexOf('-') >= 0 || element.props.is) {
                        return;
                    }
                    warnUnknownProperties(debugID, element);
                }

                var ReactDOMUnknownPropertyHook = {
                    onBeforeMountComponent: function(debugID, element) {
                        handleElement(debugID, element);
                    },
                    onBeforeUpdateComponent: function(debugID, element) {
                        handleElement(debugID, element);
                    }
                };

                module.exports = ReactDOMUnknownPropertyHook;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMProperty": 40,
            "./EventPluginRegistry": 46,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "react/lib/ReactComponentTreeHook": 162
        }],
        77: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactInvalidSetStateWarningHook = _dereq_('./ReactInvalidSetStateWarningHook');
                var ReactHostOperationHistoryHook = _dereq_('./ReactHostOperationHistoryHook');
                var ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');
                var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');

                var performanceNow = _dereq_('fbjs/lib/performanceNow');
                var warning = _dereq_('fbjs/lib/warning');

                var hooks = [];
                var didHookThrowForEvent = {};

                function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
                    try {
                        fn.call(context, arg1, arg2, arg3, arg4, arg5);
                    } catch (e) {
                        process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
                        didHookThrowForEvent[event] = true;
                    }
                }

                function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
                    for (var i = 0; i < hooks.length; i++) {
                        var hook = hooks[i];
                        var fn = hook[event];
                        if (fn) {
                            callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
                        }
                    }
                }

                var isProfiling = false;
                var flushHistory = [];
                var lifeCycleTimerStack = [];
                var currentFlushNesting = 0;
                var currentFlushMeasurements = [];
                var currentFlushStartTime = 0;
                var currentTimerDebugID = null;
                var currentTimerStartTime = 0;
                var currentTimerNestedFlushDuration = 0;
                var currentTimerType = null;

                var lifeCycleTimerHasWarned = false;

                function clearHistory() {
                    ReactComponentTreeHook.purgeUnmountedComponents();
                    ReactHostOperationHistoryHook.clearHistory();
                }

                function getTreeSnapshot(registeredIDs) {
                    return registeredIDs.reduce(function(tree, id) {
                        var ownerID = ReactComponentTreeHook.getOwnerID(id);
                        var parentID = ReactComponentTreeHook.getParentID(id);
                        tree[id] = {
                            displayName: ReactComponentTreeHook.getDisplayName(id),
                            text: ReactComponentTreeHook.getText(id),
                            updateCount: ReactComponentTreeHook.getUpdateCount(id),
                            childIDs: ReactComponentTreeHook.getChildIDs(id),
                            // Text nodes don't have owners but this is close enough.
                            ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
                            parentID: parentID
                        };
                        return tree;
                    }, {});
                }

                function resetMeasurements() {
                    var previousStartTime = currentFlushStartTime;
                    var previousMeasurements = currentFlushMeasurements;
                    var previousOperations = ReactHostOperationHistoryHook.getHistory();

                    if (currentFlushNesting === 0) {
                        currentFlushStartTime = 0;
                        currentFlushMeasurements = [];
                        clearHistory();
                        return;
                    }

                    if (previousMeasurements.length || previousOperations.length) {
                        var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
                        flushHistory.push({
                            duration: performanceNow() - previousStartTime,
                            measurements: previousMeasurements || [],
                            operations: previousOperations || [],
                            treeSnapshot: getTreeSnapshot(registeredIDs)
                        });
                    }

                    clearHistory();
                    currentFlushStartTime = performanceNow();
                    currentFlushMeasurements = [];
                }

                function checkDebugID(debugID) {
                    var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                    if (allowRoot && debugID === 0) {
                        return;
                    }
                    if (!debugID) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
                    }
                }

                function beginLifeCycleTimer(debugID, timerType) {
                    if (currentFlushNesting === 0) {
                        return;
                    }
                    if (currentTimerType && !lifeCycleTimerHasWarned) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
                        lifeCycleTimerHasWarned = true;
                    }
                    currentTimerStartTime = performanceNow();
                    currentTimerNestedFlushDuration = 0;
                    currentTimerDebugID = debugID;
                    currentTimerType = timerType;
                }

                function endLifeCycleTimer(debugID, timerType) {
                    if (currentFlushNesting === 0) {
                        return;
                    }
                    if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
                        lifeCycleTimerHasWarned = true;
                    }
                    if (isProfiling) {
                        currentFlushMeasurements.push({
                            timerType: timerType,
                            instanceID: debugID,
                            duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
                        });
                    }
                    currentTimerStartTime = 0;
                    currentTimerNestedFlushDuration = 0;
                    currentTimerDebugID = null;
                    currentTimerType = null;
                }

                function pauseCurrentLifeCycleTimer() {
                    var currentTimer = {
                        startTime: currentTimerStartTime,
                        nestedFlushStartTime: performanceNow(),
                        debugID: currentTimerDebugID,
                        timerType: currentTimerType
                    };
                    lifeCycleTimerStack.push(currentTimer);
                    currentTimerStartTime = 0;
                    currentTimerNestedFlushDuration = 0;
                    currentTimerDebugID = null;
                    currentTimerType = null;
                }

                function resumeCurrentLifeCycleTimer() {
                    var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
                        startTime = _lifeCycleTimerStack$.startTime,
                        nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
                        debugID = _lifeCycleTimerStack$.debugID,
                        timerType = _lifeCycleTimerStack$.timerType;

                    var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
                    currentTimerStartTime = startTime;
                    currentTimerNestedFlushDuration += nestedFlushDuration;
                    currentTimerDebugID = debugID;
                    currentTimerType = timerType;
                }

                var lastMarkTimeStamp = 0;
                var canUsePerformanceMeasure =
                    // $FlowFixMe https://github.com/facebook/flow/issues/2345
                    typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

                function shouldMark(debugID) {
                    if (!isProfiling || !canUsePerformanceMeasure) {
                        return false;
                    }
                    var element = ReactComponentTreeHook.getElement(debugID);
                    if (element == null || typeof element !== 'object') {
                        return false;
                    }
                    var isHostElement = typeof element.type === 'string';
                    if (isHostElement) {
                        return false;
                    }
                    return true;
                }

                function markBegin(debugID, markType) {
                    if (!shouldMark(debugID)) {
                        return;
                    }

                    var markName = debugID + '::' + markType;
                    lastMarkTimeStamp = performanceNow();
                    performance.mark(markName);
                }

                function markEnd(debugID, markType) {
                    if (!shouldMark(debugID)) {
                        return;
                    }

                    var markName = debugID + '::' + markType;
                    var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

                    // Chrome has an issue of dropping markers recorded too fast:
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
                    // To work around this, we will not report very small measurements.
                    // I determined the magic number by tweaking it back and forth.
                    // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
                    // When the bug is fixed, we can `measure()` unconditionally if we want to.
                    var timeStamp = performanceNow();
                    if (timeStamp - lastMarkTimeStamp > 0.1) {
                        var measurementName = displayName + ' [' + markType + ']';
                        performance.measure(measurementName, markName);
                    }

                    performance.clearMarks(markName);
                    performance.clearMeasures(measurementName);
                }

                var ReactDebugTool = {
                    addHook: function(hook) {
                        hooks.push(hook);
                    },
                    removeHook: function(hook) {
                        for (var i = 0; i < hooks.length; i++) {
                            if (hooks[i] === hook) {
                                hooks.splice(i, 1);
                                i--;
                            }
                        }
                    },
                    isProfiling: function() {
                        return isProfiling;
                    },
                    beginProfiling: function() {
                        if (isProfiling) {
                            return;
                        }

                        isProfiling = true;
                        flushHistory.length = 0;
                        resetMeasurements();
                        ReactDebugTool.addHook(ReactHostOperationHistoryHook);
                    },
                    endProfiling: function() {
                        if (!isProfiling) {
                            return;
                        }

                        isProfiling = false;
                        resetMeasurements();
                        ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
                    },
                    getFlushHistory: function() {
                        return flushHistory;
                    },
                    onBeginFlush: function() {
                        currentFlushNesting++;
                        resetMeasurements();
                        pauseCurrentLifeCycleTimer();
                        emitEvent('onBeginFlush');
                    },
                    onEndFlush: function() {
                        resetMeasurements();
                        currentFlushNesting--;
                        resumeCurrentLifeCycleTimer();
                        emitEvent('onEndFlush');
                    },
                    onBeginLifeCycleTimer: function(debugID, timerType) {
                        checkDebugID(debugID);
                        emitEvent('onBeginLifeCycleTimer', debugID, timerType);
                        markBegin(debugID, timerType);
                        beginLifeCycleTimer(debugID, timerType);
                    },
                    onEndLifeCycleTimer: function(debugID, timerType) {
                        checkDebugID(debugID);
                        endLifeCycleTimer(debugID, timerType);
                        markEnd(debugID, timerType);
                        emitEvent('onEndLifeCycleTimer', debugID, timerType);
                    },
                    onBeginProcessingChildContext: function() {
                        emitEvent('onBeginProcessingChildContext');
                    },
                    onEndProcessingChildContext: function() {
                        emitEvent('onEndProcessingChildContext');
                    },
                    onHostOperation: function(operation) {
                        checkDebugID(operation.instanceID);
                        emitEvent('onHostOperation', operation);
                    },
                    onSetState: function() {
                        emitEvent('onSetState');
                    },
                    onSetChildren: function(debugID, childDebugIDs) {
                        checkDebugID(debugID);
                        childDebugIDs.forEach(checkDebugID);
                        emitEvent('onSetChildren', debugID, childDebugIDs);
                    },
                    onBeforeMountComponent: function(debugID, element, parentDebugID) {
                        checkDebugID(debugID);
                        checkDebugID(parentDebugID, true);
                        emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
                        markBegin(debugID, 'mount');
                    },
                    onMountComponent: function(debugID) {
                        checkDebugID(debugID);
                        markEnd(debugID, 'mount');
                        emitEvent('onMountComponent', debugID);
                    },
                    onBeforeUpdateComponent: function(debugID, element) {
                        checkDebugID(debugID);
                        emitEvent('onBeforeUpdateComponent', debugID, element);
                        markBegin(debugID, 'update');
                    },
                    onUpdateComponent: function(debugID) {
                        checkDebugID(debugID);
                        markEnd(debugID, 'update');
                        emitEvent('onUpdateComponent', debugID);
                    },
                    onBeforeUnmountComponent: function(debugID) {
                        checkDebugID(debugID);
                        emitEvent('onBeforeUnmountComponent', debugID);
                        markBegin(debugID, 'unmount');
                    },
                    onUnmountComponent: function(debugID) {
                        checkDebugID(debugID);
                        markEnd(debugID, 'unmount');
                        emitEvent('onUnmountComponent', debugID);
                    },
                    onTestEvent: function() {
                        emitEvent('onTestEvent');
                    }
                };

                // TODO remove these when RN/www gets updated
                ReactDebugTool.addDevtool = ReactDebugTool.addHook;
                ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

                ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
                ReactDebugTool.addHook(ReactComponentTreeHook);
                var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
                if (/[?&]react_perf\b/.test(url)) {
                    ReactDebugTool.beginProfiling();
                }

                module.exports = ReactDebugTool;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactHostOperationHistoryHook": 87,
            "./ReactInvalidSetStateWarningHook": 92,
            "_process": 28,
            "fbjs/lib/ExecutionEnvironment": 3,
            "fbjs/lib/performanceNow": 22,
            "fbjs/lib/warning": 24,
            "react/lib/ReactComponentTreeHook": 162
        }],
        78: [function(_dereq_, module, exports) {

            var _assign = _dereq_('object-assign');

            var ReactUpdates = _dereq_('./ReactUpdates');
            var Transaction = _dereq_('./Transaction');

            var emptyFunction = _dereq_('fbjs/lib/emptyFunction');

            var RESET_BATCHED_UPDATES = {
                initialize: emptyFunction,
                close: function() {
                    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
                }
            };

            var FLUSH_BATCHED_UPDATES = {
                initialize: emptyFunction,
                close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
            };

            var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

            function ReactDefaultBatchingStrategyTransaction() {
                this.reinitializeTransaction();
            }

            _assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
                getTransactionWrappers: function() {
                    return TRANSACTION_WRAPPERS;
                }
            });

            var transaction = new ReactDefaultBatchingStrategyTransaction();

            var ReactDefaultBatchingStrategy = {
                isBatchingUpdates: false,


                batchedUpdates: function(callback, a, b, c, d, e) {
                    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

                    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

                    // The code is written this way to avoid extra allocations
                    if (alreadyBatchingUpdates) {
                        return callback(a, b, c, d, e);
                    } else {
                        return transaction.perform(callback, null, a, b, c, d, e);
                    }
                }
            };

            module.exports = ReactDefaultBatchingStrategy;
        }, {
            "./ReactUpdates": 106,
            "./Transaction": 124,
            "fbjs/lib/emptyFunction": 9,
            "object-assign": 27
        }],
        79: [function(_dereq_, module, exports) {

            var ARIADOMPropertyConfig = _dereq_('./ARIADOMPropertyConfig');
            var BeforeInputEventPlugin = _dereq_('./BeforeInputEventPlugin');
            var ChangeEventPlugin = _dereq_('./ChangeEventPlugin');
            var DefaultEventPluginOrder = _dereq_('./DefaultEventPluginOrder');
            var EnterLeaveEventPlugin = _dereq_('./EnterLeaveEventPlugin');
            var HTMLDOMPropertyConfig = _dereq_('./HTMLDOMPropertyConfig');
            var ReactComponentBrowserEnvironment = _dereq_('./ReactComponentBrowserEnvironment');
            var ReactDOMComponent = _dereq_('./ReactDOMComponent');
            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
            var ReactDOMEmptyComponent = _dereq_('./ReactDOMEmptyComponent');
            var ReactDOMTreeTraversal = _dereq_('./ReactDOMTreeTraversal');
            var ReactDOMTextComponent = _dereq_('./ReactDOMTextComponent');
            var ReactDefaultBatchingStrategy = _dereq_('./ReactDefaultBatchingStrategy');
            var ReactEventListener = _dereq_('./ReactEventListener');
            var ReactInjection = _dereq_('./ReactInjection');
            var ReactReconcileTransaction = _dereq_('./ReactReconcileTransaction');
            var SVGDOMPropertyConfig = _dereq_('./SVGDOMPropertyConfig');
            var SelectEventPlugin = _dereq_('./SelectEventPlugin');
            var SimpleEventPlugin = _dereq_('./SimpleEventPlugin');

            var alreadyInjected = false;

            function inject() {
                if (alreadyInjected) {
                    // TODO: This is currently true because these injections are shared between
                    // the client and the server package. They should be built independently
                    // and not share any injection state. Then this problem will be solved.
                    return;
                }
                alreadyInjected = true;

                ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);


                ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
                ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
                ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);


                ReactInjection.EventPluginHub.injectEventPluginsByName({
                    SimpleEventPlugin: SimpleEventPlugin,
                    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
                    ChangeEventPlugin: ChangeEventPlugin,
                    SelectEventPlugin: SelectEventPlugin,
                    BeforeInputEventPlugin: BeforeInputEventPlugin
                });

                ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

                ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

                ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
                ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
                ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

                ReactInjection.EmptyComponent.injectEmptyComponentFactory(function(instantiate) {
                    return new ReactDOMEmptyComponent(instantiate);
                });

                ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
                ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

                ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
            }

            module.exports = {
                inject: inject
            };
        }, {
            "./ARIADOMPropertyConfig": 30,
            "./BeforeInputEventPlugin": 32,
            "./ChangeEventPlugin": 36,
            "./DefaultEventPluginOrder": 43,
            "./EnterLeaveEventPlugin": 44,
            "./HTMLDOMPropertyConfig": 50,
            "./ReactComponentBrowserEnvironment": 56,
            "./ReactDOMComponent": 60,
            "./ReactDOMComponentTree": 62,
            "./ReactDOMEmptyComponent": 64,
            "./ReactDOMTextComponent": 73,
            "./ReactDOMTreeTraversal": 75,
            "./ReactDefaultBatchingStrategy": 78,
            "./ReactEventListener": 84,
            "./ReactInjection": 88,
            "./ReactReconcileTransaction": 100,
            "./SVGDOMPropertyConfig": 108,
            "./SelectEventPlugin": 109,
            "./SimpleEventPlugin": 110
        }],
        80: [function(_dereq_, module, exports) {

            // The Symbol used to tag the ReactElement type. If there is no native Symbol
            // nor polyfill, then a plain number is used for performance.

            var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

            module.exports = REACT_ELEMENT_TYPE;
        }, {}],
        81: [function(_dereq_, module, exports) {

            var emptyComponentFactory;

            var ReactEmptyComponentInjection = {
                injectEmptyComponentFactory: function(factory) {
                    emptyComponentFactory = factory;
                }
            };

            var ReactEmptyComponent = {
                create: function(instantiate) {
                    return emptyComponentFactory(instantiate);
                }
            };

            ReactEmptyComponent.injection = ReactEmptyComponentInjection;

            module.exports = ReactEmptyComponent;
        }, {}],
        82: [function(_dereq_, module, exports) {
            (function(process) {

                var caughtError = null;

                function invokeGuardedCallback(name, func, a) {
                    try {
                        func(a);
                    } catch (x) {
                        if (caughtError === null) {
                            caughtError = x;
                        }
                    }
                }

                var ReactErrorUtils = {
                    invokeGuardedCallback: invokeGuardedCallback,


                    invokeGuardedCallbackWithCatch: invokeGuardedCallback,


                    rethrowCaughtError: function() {
                        if (caughtError) {
                            var error = caughtError;
                            caughtError = null;
                            throw error;
                        }
                    }
                };

                if (process.env.NODE_ENV !== 'production') {

                    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                        var fakeNode = document.createElement('react');
                        ReactErrorUtils.invokeGuardedCallback = function(name, func, a) {
                            var boundFunc = func.bind(null, a);
                            var evtType = 'react-' + name;
                            fakeNode.addEventListener(evtType, boundFunc, false);
                            var evt = document.createEvent('Event');
                            // $FlowFixMe https://github.com/facebook/flow/issues/2336
                            evt.initEvent(evtType, false, false);
                            fakeNode.dispatchEvent(evt);
                            fakeNode.removeEventListener(evtType, boundFunc, false);
                        };
                    }
                }

                module.exports = ReactErrorUtils;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28
        }],
        83: [function(_dereq_, module, exports) {

            var EventPluginHub = _dereq_('./EventPluginHub');

            function runEventQueueInBatch(events) {
                EventPluginHub.enqueueEvents(events);
                EventPluginHub.processEventQueue(false);
            }

            var ReactEventEmitterMixin = {


                handleTopLevel: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
                    runEventQueueInBatch(events);
                }
            };

            module.exports = ReactEventEmitterMixin;
        }, {
            "./EventPluginHub": 45
        }],
        84: [function(_dereq_, module, exports) {

            var _assign = _dereq_('object-assign');

            var EventListener = _dereq_('fbjs/lib/EventListener');
            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
            var PooledClass = _dereq_('./PooledClass');
            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
            var ReactUpdates = _dereq_('./ReactUpdates');

            var getEventTarget = _dereq_('./getEventTarget');
            var getUnboundedScrollPosition = _dereq_('fbjs/lib/getUnboundedScrollPosition');

            function findParent(inst) {
                // TODO: It may be a good idea to cache this to prevent unnecessary DOM
                // traversal, but caching is difficult to do correctly without using a
                // mutation observer to listen for all DOM changes.
                while (inst._hostParent) {
                    inst = inst._hostParent;
                }
                var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
                var container = rootNode.parentNode;
                return ReactDOMComponentTree.getClosestInstanceFromNode(container);
            }

            // Used to store ancestor hierarchy in top level callback
            function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
                this.topLevelType = topLevelType;
                this.nativeEvent = nativeEvent;
                this.ancestors = [];
            }
            _assign(TopLevelCallbackBookKeeping.prototype, {
                destructor: function() {
                    this.topLevelType = null;
                    this.nativeEvent = null;
                    this.ancestors.length = 0;
                }
            });
            PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

            function handleTopLevelImpl(bookKeeping) {
                var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
                var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

                // Loop through the hierarchy, in case there's any nested components.
                // It's important that we build the array of ancestors before calling any
                // event handlers, because event handlers can modify the DOM, leading to
                // inconsistencies with ReactMount's node cache. See #1105.
                var ancestor = targetInst;
                do {
                    bookKeeping.ancestors.push(ancestor);
                    ancestor = ancestor && findParent(ancestor);
                } while (ancestor);

                for (var i = 0; i < bookKeeping.ancestors.length; i++) {
                    targetInst = bookKeeping.ancestors[i];
                    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
                }
            }

            function scrollValueMonitor(cb) {
                var scrollPosition = getUnboundedScrollPosition(window);
                cb(scrollPosition);
            }

            var ReactEventListener = {
                _enabled: true,
                _handleTopLevel: null,

                WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

                setHandleTopLevel: function(handleTopLevel) {
                    ReactEventListener._handleTopLevel = handleTopLevel;
                },

                setEnabled: function(enabled) {
                    ReactEventListener._enabled = !!enabled;
                },

                isEnabled: function() {
                    return ReactEventListener._enabled;
                },


                trapBubbledEvent: function(topLevelType, handlerBaseName, element) {
                    if (!element) {
                        return null;
                    }
                    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
                },


                trapCapturedEvent: function(topLevelType, handlerBaseName, element) {
                    if (!element) {
                        return null;
                    }
                    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
                },

                monitorScrollValue: function(refresh) {
                    var callback = scrollValueMonitor.bind(null, refresh);
                    EventListener.listen(window, 'scroll', callback);
                },

                dispatchEvent: function(topLevelType, nativeEvent) {
                    if (!ReactEventListener._enabled) {
                        return;
                    }

                    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
                    try {
                        // Event queue being processed in the same cycle allows
                        // `preventDefault`.
                        ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
                    } finally {
                        TopLevelCallbackBookKeeping.release(bookKeeping);
                    }
                }
            };

            module.exports = ReactEventListener;
        }, {
            "./PooledClass": 53,
            "./ReactDOMComponentTree": 62,
            "./ReactUpdates": 106,
            "./getEventTarget": 138,
            "fbjs/lib/EventListener": 2,
            "fbjs/lib/ExecutionEnvironment": 3,
            "fbjs/lib/getUnboundedScrollPosition": 14,
            "object-assign": 27
        }],
        85: [function(_dereq_, module, exports) {

            var ReactFeatureFlags = {
                // When true, call console.time() before and .timeEnd() after each top-level
                // render (both initial renders and updates). Useful when looking at prod-mode
                // timeline profiles in Chrome, for example.
                logTopLevelRenders: false
            };

            module.exports = ReactFeatureFlags;
        }, {}],
        86: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var invariant = _dereq_('fbjs/lib/invariant');

                var genericComponentClass = null;
                // This registry keeps track of wrapper classes around host tags.
                var tagToComponentClass = {};
                var textComponentClass = null;

                var ReactHostComponentInjection = {
                    // This accepts a class that receives the tag string. This is a catch all
                    // that can render any kind of tag.
                    injectGenericComponentClass: function(componentClass) {
                        genericComponentClass = componentClass;
                    },
                    // This accepts a text component class that takes the text string to be
                    // rendered as props.
                    injectTextComponentClass: function(componentClass) {
                        textComponentClass = componentClass;
                    },
                    // This accepts a keyed object with classes as values. Each key represents a
                    // tag. That particular tag will use this class instead of the generic one.
                    injectComponentClasses: function(componentClasses) {
                        _assign(tagToComponentClass, componentClasses);
                    }
                };

                function createInternalComponent(element) {
                    !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
                    return new genericComponentClass(element);
                }

                function createInstanceForText(text) {
                    return new textComponentClass(text);
                }

                function isTextComponent(component) {
                    return component instanceof textComponentClass;
                }

                var ReactHostComponent = {
                    createInternalComponent: createInternalComponent,
                    createInstanceForText: createInstanceForText,
                    isTextComponent: isTextComponent,
                    injection: ReactHostComponentInjection
                };

                module.exports = ReactHostComponent;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "object-assign": 27
        }],
        87: [function(_dereq_, module, exports) {

            var history = [];

            var ReactHostOperationHistoryHook = {
                onHostOperation: function(operation) {
                    history.push(operation);
                },
                clearHistory: function() {
                    if (ReactHostOperationHistoryHook._preventClearing) {
                        // Should only be used for tests.
                        return;
                    }

                    history = [];
                },
                getHistory: function() {
                    return history;
                }
            };

            module.exports = ReactHostOperationHistoryHook;
        }, {}],
        88: [function(_dereq_, module, exports) {

            var DOMProperty = _dereq_('./DOMProperty');
            var EventPluginHub = _dereq_('./EventPluginHub');
            var EventPluginUtils = _dereq_('./EventPluginUtils');
            var ReactComponentEnvironment = _dereq_('./ReactComponentEnvironment');
            var ReactEmptyComponent = _dereq_('./ReactEmptyComponent');
            var ReactBrowserEventEmitter = _dereq_('./ReactBrowserEventEmitter');
            var ReactHostComponent = _dereq_('./ReactHostComponent');
            var ReactUpdates = _dereq_('./ReactUpdates');

            var ReactInjection = {
                Component: ReactComponentEnvironment.injection,
                DOMProperty: DOMProperty.injection,
                EmptyComponent: ReactEmptyComponent.injection,
                EventPluginHub: EventPluginHub.injection,
                EventPluginUtils: EventPluginUtils.injection,
                EventEmitter: ReactBrowserEventEmitter.injection,
                HostComponent: ReactHostComponent.injection,
                Updates: ReactUpdates.injection
            };

            module.exports = ReactInjection;
        }, {
            "./DOMProperty": 40,
            "./EventPluginHub": 45,
            "./EventPluginUtils": 47,
            "./ReactBrowserEventEmitter": 54,
            "./ReactComponentEnvironment": 57,
            "./ReactEmptyComponent": 81,
            "./ReactHostComponent": 86,
            "./ReactUpdates": 106
        }],
        89: [function(_dereq_, module, exports) {

            var ReactDOMSelection = _dereq_('./ReactDOMSelection');

            var containsNode = _dereq_('fbjs/lib/containsNode');
            var focusNode = _dereq_('fbjs/lib/focusNode');
            var getActiveElement = _dereq_('fbjs/lib/getActiveElement');

            function isInDocument(node) {
                return containsNode(document.documentElement, node);
            }

            var ReactInputSelection = {

                hasSelectionCapabilities: function(elem) {
                    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
                    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
                },

                getSelectionInformation: function() {
                    var focusedElem = getActiveElement();
                    return {
                        focusedElem: focusedElem,
                        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
                    };
                },


                restoreSelection: function(priorSelectionInformation) {
                    var curFocusedElem = getActiveElement();
                    var priorFocusedElem = priorSelectionInformation.focusedElem;
                    var priorSelectionRange = priorSelectionInformation.selectionRange;
                    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
                        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
                            ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
                        }
                        focusNode(priorFocusedElem);
                    }
                },


                getSelection: function(input) {
                    var selection;

                    if ('selectionStart' in input) {
                        // Modern browser with input or textarea.
                        selection = {
                            start: input.selectionStart,
                            end: input.selectionEnd
                        };
                    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
                        // IE8 input.
                        var range = document.selection.createRange();
                        // There can only be one selection per document in IE, so it must
                        // be in our element.
                        if (range.parentElement() === input) {
                            selection = {
                                start: -range.moveStart('character', -input.value.length),
                                end: -range.moveEnd('character', -input.value.length)
                            };
                        }
                    } else {
                        // Content editable or old IE textarea.
                        selection = ReactDOMSelection.getOffsets(input);
                    }

                    return selection || {
                        start: 0,
                        end: 0
                    };
                },


                setSelection: function(input, offsets) {
                    var start = offsets.start;
                    var end = offsets.end;
                    if (end === undefined) {
                        end = start;
                    }

                    if ('selectionStart' in input) {
                        input.selectionStart = start;
                        input.selectionEnd = Math.min(end, input.value.length);
                    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
                        var range = input.createTextRange();
                        range.collapse(true);
                        range.moveStart('character', start);
                        range.moveEnd('character', end - start);
                        range.select();
                    } else {
                        ReactDOMSelection.setOffsets(input, offsets);
                    }
                }
            };

            module.exports = ReactInputSelection;
        }, {
            "./ReactDOMSelection": 72,
            "fbjs/lib/containsNode": 6,
            "fbjs/lib/focusNode": 11,
            "fbjs/lib/getActiveElement": 12
        }],
        90: [function(_dereq_, module, exports) {

            // TODO: Replace this with ES6: var ReactInstanceMap = new Map();

            var ReactInstanceMap = {


                remove: function(key) {
                    key._reactInternalInstance = undefined;
                },

                get: function(key) {
                    return key._reactInternalInstance;
                },

                has: function(key) {
                    return key._reactInternalInstance !== undefined;
                },

                set: function(key, value) {
                    key._reactInternalInstance = value;
                }

            };

            module.exports = ReactInstanceMap;
        }, {}],
        91: [function(_dereq_, module, exports) {
            (function(process) {

                // Trust the developer to only use ReactInstrumentation with a __DEV__ check

                var debugTool = null;

                if (process.env.NODE_ENV !== 'production') {
                    var ReactDebugTool = _dereq_('./ReactDebugTool');
                    debugTool = ReactDebugTool;
                }

                module.exports = {
                    debugTool: debugTool
                };
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactDebugTool": 77,
            "_process": 28
        }],
        92: [function(_dereq_, module, exports) {
            (function(process) {

                var warning = _dereq_('fbjs/lib/warning');

                if (process.env.NODE_ENV !== 'production') {
                    var processingChildContext = false;

                    var warnInvalidSetState = function() {
                        process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
                    };
                }

                var ReactInvalidSetStateWarningHook = {
                    onBeginProcessingChildContext: function() {
                        processingChildContext = true;
                    },
                    onEndProcessingChildContext: function() {
                        processingChildContext = false;
                    },
                    onSetState: function() {
                        warnInvalidSetState();
                    }
                };

                module.exports = ReactInvalidSetStateWarningHook;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        93: [function(_dereq_, module, exports) {

            var adler32 = _dereq_('./adler32');

            var TAG_END = /\/?>/;
            var COMMENT_START = /^<\!\-\-/;

            var ReactMarkupChecksum = {
                CHECKSUM_ATTR_NAME: 'data-react-checksum',


                addChecksumToMarkup: function(markup) {
                    var checksum = adler32(markup);

                    // Add checksum (handle both parent tags, comments and self-closing tags)
                    if (COMMENT_START.test(markup)) {
                        return markup;
                    } else {
                        return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
                    }
                },


                canReuseMarkup: function(markup, element) {
                    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
                    var markupChecksum = adler32(markup);
                    return markupChecksum === existingChecksum;
                }
            };

            module.exports = ReactMarkupChecksum;
        }, {
            "./adler32": 127
        }],
        94: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var DOMLazyTree = _dereq_('./DOMLazyTree');
                var DOMProperty = _dereq_('./DOMProperty');
                var React = _dereq_('react/lib/React');
                var ReactBrowserEventEmitter = _dereq_('./ReactBrowserEventEmitter');
                var ReactCurrentOwner = _dereq_('react/lib/ReactCurrentOwner');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactDOMContainerInfo = _dereq_('./ReactDOMContainerInfo');
                var ReactDOMFeatureFlags = _dereq_('./ReactDOMFeatureFlags');
                var ReactFeatureFlags = _dereq_('./ReactFeatureFlags');
                var ReactInstanceMap = _dereq_('./ReactInstanceMap');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');
                var ReactMarkupChecksum = _dereq_('./ReactMarkupChecksum');
                var ReactReconciler = _dereq_('./ReactReconciler');
                var ReactUpdateQueue = _dereq_('./ReactUpdateQueue');
                var ReactUpdates = _dereq_('./ReactUpdates');

                var emptyObject = _dereq_('fbjs/lib/emptyObject');
                var instantiateReactComponent = _dereq_('./instantiateReactComponent');
                var invariant = _dereq_('fbjs/lib/invariant');
                var setInnerHTML = _dereq_('./setInnerHTML');
                var shouldUpdateReactComponent = _dereq_('./shouldUpdateReactComponent');
                var warning = _dereq_('fbjs/lib/warning');

                var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
                var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

                var ELEMENT_NODE_TYPE = 1;
                var DOC_NODE_TYPE = 9;
                var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

                var instancesByReactRootID = {};

                function firstDifferenceIndex(string1, string2) {
                    var minLen = Math.min(string1.length, string2.length);
                    for (var i = 0; i < minLen; i++) {
                        if (string1.charAt(i) !== string2.charAt(i)) {
                            return i;
                        }
                    }
                    return string1.length === string2.length ? -1 : minLen;
                }

                function getReactRootElementInContainer(container) {
                    if (!container) {
                        return null;
                    }

                    if (container.nodeType === DOC_NODE_TYPE) {
                        return container.documentElement;
                    } else {
                        return container.firstChild;
                    }
                }

                function internalGetID(node) {
                    // If node is something like a window, document, or text node, none of
                    // which support attributes or a .getAttribute method, gracefully return
                    // the empty string, as if the attribute were missing.
                    return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
                }

                function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
                    var markerName;
                    if (ReactFeatureFlags.logTopLevelRenders) {
                        var wrappedElement = wrapperInstance._currentElement.props.child;
                        var type = wrappedElement.type;
                        markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
                        console.time(markerName);
                    }

                    var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0);

                    if (markerName) {
                        console.timeEnd(markerName);
                    }

                    wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
                    ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
                }

                function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
                    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(

                        !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
                    transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
                    ReactUpdates.ReactReconcileTransaction.release(transaction);
                }

                function unmountComponentFromNode(instance, container, safely) {
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onBeginFlush();
                    }
                    ReactReconciler.unmountComponent(instance, safely);
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onEndFlush();
                    }

                    if (container.nodeType === DOC_NODE_TYPE) {
                        container = container.documentElement;
                    }

                    // http://jsperf.com/emptying-a-node
                    while (container.lastChild) {
                        container.removeChild(container.lastChild);
                    }
                }

                function hasNonRootReactChild(container) {
                    var rootEl = getReactRootElementInContainer(container);
                    if (rootEl) {
                        var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
                        return !!(inst && inst._hostParent);
                    }
                }

                function nodeIsRenderedByOtherInstance(container) {
                    var rootEl = getReactRootElementInContainer(container);
                    return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
                }

                function isValidContainer(node) {
                    return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
                }

                function isReactNode(node) {
                    return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
                }

                function getHostRootInstanceInContainer(container) {
                    var rootEl = getReactRootElementInContainer(container);
                    var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
                    return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
                }

                function getTopLevelWrapperInContainer(container) {
                    var root = getHostRootInstanceInContainer(container);
                    return root ? root._hostContainerInfo._topLevelWrapper : null;
                }

                var topLevelRootCounter = 1;
                var TopLevelWrapper = function() {
                    this.rootID = topLevelRootCounter++;
                };
                TopLevelWrapper.prototype.isReactComponent = {};
                if (process.env.NODE_ENV !== 'production') {
                    TopLevelWrapper.displayName = 'TopLevelWrapper';
                }
                TopLevelWrapper.prototype.render = function() {
                    return this.props.child;
                };
                TopLevelWrapper.isReactTopLevelWrapper = true;

                var ReactMount = {

                    TopLevelWrapper: TopLevelWrapper,


                    _instancesByReactRootID: instancesByReactRootID,


                    scrollMonitor: function(container, renderCallback) {
                        renderCallback();
                    },


                    _updateRootComponent: function(prevComponent, nextElement, nextContext, container, callback) {
                        ReactMount.scrollMonitor(container, function() {
                            ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
                            if (callback) {
                                ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
                            }
                        });

                        return prevComponent;
                    },


                    _renderNewRootComponent: function(nextElement, container, shouldReuseMarkup, context) {
                        // Various parts of our code (such as ReactCompositeComponent's
                        // _renderValidatedComponent) assume that calls to render aren't nested;
                        // verify that that's the case.
                        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

                        !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

                        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
                        var componentInstance = instantiateReactComponent(nextElement, false);

                        // The initial render is synchronous but any updates that happen during
                        // rendering, in componentWillMount or componentDidMount, will be batched
                        // according to the current batching strategy.

                        ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

                        var wrapperID = componentInstance._instance.rootID;
                        instancesByReactRootID[wrapperID] = componentInstance;

                        return componentInstance;
                    },


                    renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
                        !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38'): void 0;
                        return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
                    },

                    _renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
                        ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
                        !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
                            // Check if it quacks like an element
                            nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

                        process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

                        var nextWrappedElement = React.createElement(TopLevelWrapper, {
                            child: nextElement
                        });

                        var nextContext;
                        if (parentComponent) {
                            var parentInst = ReactInstanceMap.get(parentComponent);
                            nextContext = parentInst._processChildContext(parentInst._context);
                        } else {
                            nextContext = emptyObject;
                        }

                        var prevComponent = getTopLevelWrapperInContainer(container);

                        if (prevComponent) {
                            var prevWrappedElement = prevComponent._currentElement;
                            var prevElement = prevWrappedElement.props.child;
                            if (shouldUpdateReactComponent(prevElement, nextElement)) {
                                var publicInst = prevComponent._renderedComponent.getPublicInstance();
                                var updatedCallback = callback && function() {
                                    callback.call(publicInst);
                                };
                                ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
                                return publicInst;
                            } else {
                                ReactMount.unmountComponentAtNode(container);
                            }
                        }

                        var reactRootElement = getReactRootElementInContainer(container);
                        var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
                        var containerHasNonRootReactChild = hasNonRootReactChild(container);

                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

                            if (!containerHasReactMarkup || reactRootElement.nextSibling) {
                                var rootElementSibling = reactRootElement;
                                while (rootElementSibling) {
                                    if (internalGetID(rootElementSibling)) {
                                        process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
                                        break;
                                    }
                                    rootElementSibling = rootElementSibling.nextSibling;
                                }
                            }
                        }

                        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
                        var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
                        if (callback) {
                            callback.call(component);
                        }
                        return component;
                    },


                    render: function(nextElement, container, callback) {
                        return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
                    },


                    unmountComponentAtNode: function(container) {
                        // Various parts of our code (such as ReactCompositeComponent's
                        // _renderValidatedComponent) assume that calls to render aren't nested;
                        // verify that that's the case. (Strictly speaking, unmounting won't cause a
                        // render but we still don't expect to be in a render call here.)
                        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

                        !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
                        }

                        var prevComponent = getTopLevelWrapperInContainer(container);
                        if (!prevComponent) {
                            // Check if the node being unmounted was rendered by React, but isn't a
                            // root node.
                            var containerHasNonRootReactChild = hasNonRootReactChild(container);

                            // Check if the container itself is a React root node.
                            var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

                            if (process.env.NODE_ENV !== 'production') {
                                process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
                            }

                            return false;
                        }
                        delete instancesByReactRootID[prevComponent._instance.rootID];
                        ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
                        return true;
                    },

                    _mountImageIntoNode: function(markup, container, instance, shouldReuseMarkup, transaction) {
                        !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

                        if (shouldReuseMarkup) {
                            var rootElement = getReactRootElementInContainer(container);
                            if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
                                ReactDOMComponentTree.precacheNode(instance, rootElement);
                                return;
                            } else {
                                var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                                rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

                                var rootMarkup = rootElement.outerHTML;
                                rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

                                var normalizedMarkup = markup;
                                if (process.env.NODE_ENV !== 'production') {
                                    // because rootMarkup is retrieved from the DOM, various normalizations
                                    // will have occurred which will not be present in `markup`. Here,
                                    // insert markup into a <div> or <iframe> depending on the container
                                    // type to perform the same normalizations before comparing.
                                    var normalizer;
                                    if (container.nodeType === ELEMENT_NODE_TYPE) {
                                        normalizer = document.createElement('div');
                                        normalizer.innerHTML = markup;
                                        normalizedMarkup = normalizer.innerHTML;
                                    } else {
                                        normalizer = document.createElement('iframe');
                                        document.body.appendChild(normalizer);
                                        normalizer.contentDocument.write(markup);
                                        normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
                                        document.body.removeChild(normalizer);
                                    }
                                }

                                var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
                                var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

                                !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference): void 0;

                                if (process.env.NODE_ENV !== 'production') {
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
                                }
                            }
                        }

                        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43'): void 0;

                        if (transaction.useCreateElement) {
                            while (container.lastChild) {
                                container.removeChild(container.lastChild);
                            }
                            DOMLazyTree.insertTreeBefore(container, markup, null);
                        } else {
                            setInnerHTML(container, markup);
                            ReactDOMComponentTree.precacheNode(instance, container.firstChild);
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
                            if (hostNode._debugID !== 0) {
                                ReactInstrumentation.debugTool.onHostOperation({
                                    instanceID: hostNode._debugID,
                                    type: 'mount',
                                    payload: markup.toString()
                                });
                            }
                        }
                    }
                };

                module.exports = ReactMount;
            }).call(this, _dereq_('_process'))
        }, {
            "./DOMLazyTree": 38,
            "./DOMProperty": 40,
            "./ReactBrowserEventEmitter": 54,
            "./ReactDOMComponentTree": 62,
            "./ReactDOMContainerInfo": 63,
            "./ReactDOMFeatureFlags": 65,
            "./ReactFeatureFlags": 85,
            "./ReactInstanceMap": 90,
            "./ReactInstrumentation": 91,
            "./ReactMarkupChecksum": 93,
            "./ReactReconciler": 101,
            "./ReactUpdateQueue": 105,
            "./ReactUpdates": 106,
            "./instantiateReactComponent": 145,
            "./reactProdInvariant": 149,
            "./setInnerHTML": 151,
            "./shouldUpdateReactComponent": 153,
            "_process": 28,
            "fbjs/lib/emptyObject": 10,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "react/lib/React": 158,
            "react/lib/ReactCurrentOwner": 163
        }],
        95: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactComponentEnvironment = _dereq_('./ReactComponentEnvironment');
                var ReactInstanceMap = _dereq_('./ReactInstanceMap');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');

                var ReactCurrentOwner = _dereq_('react/lib/ReactCurrentOwner');
                var ReactReconciler = _dereq_('./ReactReconciler');
                var ReactChildReconciler = _dereq_('./ReactChildReconciler');

                var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
                var flattenChildren = _dereq_('./flattenChildren');
                var invariant = _dereq_('fbjs/lib/invariant');

                function makeInsertMarkup(markup, afterNode, toIndex) {
                    // NOTE: Null values reduce hidden classes.
                    return {
                        type: 'INSERT_MARKUP',
                        content: markup,
                        fromIndex: null,
                        fromNode: null,
                        toIndex: toIndex,
                        afterNode: afterNode
                    };
                }

                function makeMove(child, afterNode, toIndex) {
                    // NOTE: Null values reduce hidden classes.
                    return {
                        type: 'MOVE_EXISTING',
                        content: null,
                        fromIndex: child._mountIndex,
                        fromNode: ReactReconciler.getHostNode(child),
                        toIndex: toIndex,
                        afterNode: afterNode
                    };
                }

                function makeRemove(child, node) {
                    // NOTE: Null values reduce hidden classes.
                    return {
                        type: 'REMOVE_NODE',
                        content: null,
                        fromIndex: child._mountIndex,
                        fromNode: node,
                        toIndex: null,
                        afterNode: null
                    };
                }

                function makeSetMarkup(markup) {
                    // NOTE: Null values reduce hidden classes.
                    return {
                        type: 'SET_MARKUP',
                        content: markup,
                        fromIndex: null,
                        fromNode: null,
                        toIndex: null,
                        afterNode: null
                    };
                }

                function makeTextContent(textContent) {
                    // NOTE: Null values reduce hidden classes.
                    return {
                        type: 'TEXT_CONTENT',
                        content: textContent,
                        fromIndex: null,
                        fromNode: null,
                        toIndex: null,
                        afterNode: null
                    };
                }

                function enqueue(queue, update) {
                    if (update) {
                        queue = queue || [];
                        queue.push(update);
                    }
                    return queue;
                }

                function processQueue(inst, updateQueue) {
                    ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
                }

                var setChildrenForInstrumentation = emptyFunction;
                if (process.env.NODE_ENV !== 'production') {
                    var getDebugID = function(inst) {
                        if (!inst._debugID) {
                            // Check for ART-like instances. TODO: This is silly/gross.
                            var internal;
                            if (internal = ReactInstanceMap.get(inst)) {
                                inst = internal;
                            }
                        }
                        return inst._debugID;
                    };
                    setChildrenForInstrumentation = function(children) {
                        var debugID = getDebugID(this);
                        // TODO: React Native empty components are also multichild.
                        // This means they still get into this method but don't have _debugID.
                        if (debugID !== 0) {
                            ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function(key) {
                                return children[key]._debugID;
                            }) : []);
                        }
                    };
                }

                var ReactMultiChild = {


                    Mixin: {

                        _reconcilerInstantiateChildren: function(nestedChildren, transaction, context) {
                            if (process.env.NODE_ENV !== 'production') {
                                var selfDebugID = getDebugID(this);
                                if (this._currentElement) {
                                    try {
                                        ReactCurrentOwner.current = this._currentElement._owner;
                                        return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
                                    } finally {
                                        ReactCurrentOwner.current = null;
                                    }
                                }
                            }
                            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
                        },

                        _reconcilerUpdateChildren: function(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
                            var nextChildren;
                            var selfDebugID = 0;
                            if (process.env.NODE_ENV !== 'production') {
                                selfDebugID = getDebugID(this);
                                if (this._currentElement) {
                                    try {
                                        ReactCurrentOwner.current = this._currentElement._owner;
                                        nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
                                    } finally {
                                        ReactCurrentOwner.current = null;
                                    }
                                    ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
                                    return nextChildren;
                                }
                            }
                            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
                            ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
                            return nextChildren;
                        },


                        mountChildren: function(nestedChildren, transaction, context) {
                            var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
                            this._renderedChildren = children;

                            var mountImages = [];
                            var index = 0;
                            for (var name in children) {
                                if (children.hasOwnProperty(name)) {
                                    var child = children[name];
                                    var selfDebugID = 0;
                                    if (process.env.NODE_ENV !== 'production') {
                                        selfDebugID = getDebugID(this);
                                    }
                                    var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
                                    child._mountIndex = index++;
                                    mountImages.push(mountImage);
                                }
                            }

                            if (process.env.NODE_ENV !== 'production') {
                                setChildrenForInstrumentation.call(this, children);
                            }

                            return mountImages;
                        },


                        updateTextContent: function(nextContent) {
                            var prevChildren = this._renderedChildren;
                            // Remove any rendered children.
                            ReactChildReconciler.unmountChildren(prevChildren, false);
                            for (var name in prevChildren) {
                                if (prevChildren.hasOwnProperty(name)) {
                                    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
                                }
                            }
                            // Set new text content.
                            var updates = [makeTextContent(nextContent)];
                            processQueue(this, updates);
                        },


                        updateMarkup: function(nextMarkup) {
                            var prevChildren = this._renderedChildren;
                            // Remove any rendered children.
                            ReactChildReconciler.unmountChildren(prevChildren, false);
                            for (var name in prevChildren) {
                                if (prevChildren.hasOwnProperty(name)) {
                                    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
                                }
                            }
                            var updates = [makeSetMarkup(nextMarkup)];
                            processQueue(this, updates);
                        },


                        updateChildren: function(nextNestedChildrenElements, transaction, context) {
                            // Hook used by React ART
                            this._updateChildren(nextNestedChildrenElements, transaction, context);
                        },


                        _updateChildren: function(nextNestedChildrenElements, transaction, context) {
                            var prevChildren = this._renderedChildren;
                            var removedNodes = {};
                            var mountImages = [];
                            var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
                            if (!nextChildren && !prevChildren) {
                                return;
                            }
                            var updates = null;
                            var name;
                            // `nextIndex` will increment for each child in `nextChildren`, but
                            // `lastIndex` will be the last index visited in `prevChildren`.
                            var nextIndex = 0;
                            var lastIndex = 0;
                            // `nextMountIndex` will increment for each newly mounted child.
                            var nextMountIndex = 0;
                            var lastPlacedNode = null;
                            for (name in nextChildren) {
                                if (!nextChildren.hasOwnProperty(name)) {
                                    continue;
                                }
                                var prevChild = prevChildren && prevChildren[name];
                                var nextChild = nextChildren[name];
                                if (prevChild === nextChild) {
                                    updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
                                    lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                                    prevChild._mountIndex = nextIndex;
                                } else {
                                    if (prevChild) {
                                        // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
                                        lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                                        // The `removedNodes` loop below will actually remove the child.
                                    }
                                    // The child must be instantiated before it's mounted.
                                    updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
                                    nextMountIndex++;
                                }
                                nextIndex++;
                                lastPlacedNode = ReactReconciler.getHostNode(nextChild);
                            }
                            // Remove children that are no longer present.
                            for (name in removedNodes) {
                                if (removedNodes.hasOwnProperty(name)) {
                                    updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
                                }
                            }
                            if (updates) {
                                processQueue(this, updates);
                            }
                            this._renderedChildren = nextChildren;

                            if (process.env.NODE_ENV !== 'production') {
                                setChildrenForInstrumentation.call(this, nextChildren);
                            }
                        },


                        unmountChildren: function(safely) {
                            var renderedChildren = this._renderedChildren;
                            ReactChildReconciler.unmountChildren(renderedChildren, safely);
                            this._renderedChildren = null;
                        },


                        moveChild: function(child, afterNode, toIndex, lastIndex) {
                            // If the index of `child` is less than `lastIndex`, then it needs to
                            // be moved. Otherwise, we do not need to move it because a child will be
                            // inserted or moved before `child`.
                            if (child._mountIndex < lastIndex) {
                                return makeMove(child, afterNode, toIndex);
                            }
                        },


                        createChild: function(child, afterNode, mountImage) {
                            return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
                        },


                        removeChild: function(child, node) {
                            return makeRemove(child, node);
                        },


                        _mountChildAtIndex: function(child, mountImage, afterNode, index, transaction, context) {
                            child._mountIndex = index;
                            return this.createChild(child, afterNode, mountImage);
                        },


                        _unmountChild: function(child, node) {
                            var update = this.removeChild(child, node);
                            child._mountIndex = null;
                            return update;
                        }

                    }

                };

                module.exports = ReactMultiChild;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactChildReconciler": 55,
            "./ReactComponentEnvironment": 57,
            "./ReactInstanceMap": 90,
            "./ReactInstrumentation": 91,
            "./ReactReconciler": 101,
            "./flattenChildren": 133,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/emptyFunction": 9,
            "fbjs/lib/invariant": 17,
            "react/lib/ReactCurrentOwner": 163
        }],
        96: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var React = _dereq_('react/lib/React');

                var invariant = _dereq_('fbjs/lib/invariant');

                var ReactNodeTypes = {
                    HOST: 0,
                    COMPOSITE: 1,
                    EMPTY: 2,

                    getType: function(node) {
                        if (node === null || node === false) {
                            return ReactNodeTypes.EMPTY;
                        } else if (React.isValidElement(node)) {
                            if (typeof node.type === 'function') {
                                return ReactNodeTypes.COMPOSITE;
                            } else {
                                return ReactNodeTypes.HOST;
                            }
                        }!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
                    }
                };

                module.exports = ReactNodeTypes;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "react/lib/React": 158
        }],
        97: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                function isValidOwner(object) {
                    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
                }

                var ReactOwner = {

                    addComponentAsRefTo: function(component, ref, owner) {
                        !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
                        owner.attachRef(ref, component);
                    },


                    removeComponentAsRefFrom: function(component, ref, owner) {
                        !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
                        var ownerPublicInstance = owner.getPublicInstance();
                        // Check that `component`'s owner is still alive and that `component` is still the current ref
                        // because we do not want to detach the ref if another component stole it.
                        if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
                            owner.detachRef(ref);
                        }
                    }

                };

                module.exports = ReactOwner;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        98: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactPropTypeLocationNames = {};

                if (process.env.NODE_ENV !== 'production') {
                    ReactPropTypeLocationNames = {
                        prop: 'prop',
                        context: 'context',
                        childContext: 'child context'
                    };
                }

                module.exports = ReactPropTypeLocationNames;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28
        }],
        99: [function(_dereq_, module, exports) {

            var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

            module.exports = ReactPropTypesSecret;
        }, {}],
        100: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var CallbackQueue = _dereq_('./CallbackQueue');
                var PooledClass = _dereq_('./PooledClass');
                var ReactBrowserEventEmitter = _dereq_('./ReactBrowserEventEmitter');
                var ReactInputSelection = _dereq_('./ReactInputSelection');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');
                var Transaction = _dereq_('./Transaction');
                var ReactUpdateQueue = _dereq_('./ReactUpdateQueue');

                var SELECTION_RESTORATION = {

                    initialize: ReactInputSelection.getSelectionInformation,

                    close: ReactInputSelection.restoreSelection
                };

                var EVENT_SUPPRESSION = {

                    initialize: function() {
                        var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
                        ReactBrowserEventEmitter.setEnabled(false);
                        return currentlyEnabled;
                    },


                    close: function(previouslyEnabled) {
                        ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
                    }
                };

                var ON_DOM_READY_QUEUEING = {

                    initialize: function() {
                        this.reactMountReady.reset();
                    },


                    close: function() {
                        this.reactMountReady.notifyAll();
                    }
                };

                var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

                if (process.env.NODE_ENV !== 'production') {
                    TRANSACTION_WRAPPERS.push({
                        initialize: ReactInstrumentation.debugTool.onBeginFlush,
                        close: ReactInstrumentation.debugTool.onEndFlush
                    });
                }

                function ReactReconcileTransaction(useCreateElement) {
                    this.reinitializeTransaction();
                    // Only server-side rendering really needs this option (see
                    // `ReactServerRendering`), but server-side uses
                    // `ReactServerRenderingTransaction` instead. This option is here so that it's
                    // accessible and defaults to false when `ReactDOMComponent` and
                    // `ReactDOMTextComponent` checks it in `mountComponent`.`
                    this.renderToStaticMarkup = false;
                    this.reactMountReady = CallbackQueue.getPooled(null);
                    this.useCreateElement = useCreateElement;
                }

                var Mixin = {

                    getTransactionWrappers: function() {
                        return TRANSACTION_WRAPPERS;
                    },


                    getReactMountReady: function() {
                        return this.reactMountReady;
                    },


                    getUpdateQueue: function() {
                        return ReactUpdateQueue;
                    },


                    checkpoint: function() {
                        // reactMountReady is the our only stateful wrapper
                        return this.reactMountReady.checkpoint();
                    },

                    rollback: function(checkpoint) {
                        this.reactMountReady.rollback(checkpoint);
                    },


                    destructor: function() {
                        CallbackQueue.release(this.reactMountReady);
                        this.reactMountReady = null;
                    }
                };

                _assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

                PooledClass.addPoolingTo(ReactReconcileTransaction);

                module.exports = ReactReconcileTransaction;
            }).call(this, _dereq_('_process'))
        }, {
            "./CallbackQueue": 35,
            "./PooledClass": 53,
            "./ReactBrowserEventEmitter": 54,
            "./ReactInputSelection": 89,
            "./ReactInstrumentation": 91,
            "./ReactUpdateQueue": 105,
            "./Transaction": 124,
            "_process": 28,
            "object-assign": 27
        }],
        101: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactRef = _dereq_('./ReactRef');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');

                var warning = _dereq_('fbjs/lib/warning');

                function attachRefs() {
                    ReactRef.attachRefs(this, this._currentElement);
                }

                var ReactReconciler = {


                    mountComponent: function(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
                    ) {
                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
                            }
                        }
                        var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
                        if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
                            transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
                        }
                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
                            }
                        }
                        return markup;
                    },


                    getHostNode: function(internalInstance) {
                        return internalInstance.getHostNode();
                    },


                    unmountComponent: function(internalInstance, safely) {
                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
                            }
                        }
                        ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
                        internalInstance.unmountComponent(safely);
                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
                            }
                        }
                    },


                    receiveComponent: function(internalInstance, nextElement, transaction, context) {
                        var prevElement = internalInstance._currentElement;

                        if (nextElement === prevElement && context === internalInstance._context) {
                            // Since elements are immutable after the owner is rendered,
                            // we can do a cheap identity compare here to determine if this is a
                            // superfluous reconcile. It's possible for state to be mutable but such
                            // change should trigger an update of the owner which would recreate
                            // the element. We explicitly check for the existence of an owner since
                            // it's possible for an element created outside a composite to be
                            // deeply mutated and reused.

                            // TODO: Bailing out early is just a perf optimization right?
                            // TODO: Removing the return statement should affect correctness?
                            return;
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
                            }
                        }

                        var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

                        if (refsChanged) {
                            ReactRef.detachRefs(internalInstance, prevElement);
                        }

                        internalInstance.receiveComponent(nextElement, transaction, context);

                        if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
                            transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
                            }
                        }
                    },


                    performUpdateIfNecessary: function(internalInstance, transaction, updateBatchNumber) {
                        if (internalInstance._updateBatchNumber !== updateBatchNumber) {
                            // The component's enqueued batch number should always be the current
                            // batch or the following one.
                            process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
                            return;
                        }
                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
                            }
                        }
                        internalInstance.performUpdateIfNecessary(transaction);
                        if (process.env.NODE_ENV !== 'production') {
                            if (internalInstance._debugID !== 0) {
                                ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
                            }
                        }
                    }

                };

                module.exports = ReactReconciler;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactInstrumentation": 91,
            "./ReactRef": 102,
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        102: [function(_dereq_, module, exports) {

            var ReactOwner = _dereq_('./ReactOwner');

            var ReactRef = {};

            function attachRef(ref, component, owner) {
                if (typeof ref === 'function') {
                    ref(component.getPublicInstance());
                } else {
                    // Legacy ref
                    ReactOwner.addComponentAsRefTo(component, ref, owner);
                }
            }

            function detachRef(ref, component, owner) {
                if (typeof ref === 'function') {
                    ref(null);
                } else {
                    // Legacy ref
                    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
                }
            }

            ReactRef.attachRefs = function(instance, element) {
                if (element === null || typeof element !== 'object') {
                    return;
                }
                var ref = element.ref;
                if (ref != null) {
                    attachRef(ref, instance, element._owner);
                }
            };

            ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
                // If either the owner or a `ref` has changed, make sure the newest owner
                // has stored a reference to `this`, and the previous owner (if different)
                // has forgotten the reference to `this`. We use the element instead
                // of the public this.props because the post processing cannot determine
                // a ref. The ref conceptually lives on the element.

                // TODO: Should this even be possible? The owner cannot change because
                // it's forbidden by shouldUpdateReactComponent. The ref can change
                // if you swap the keys of but not the refs. Reconsider where this check
                // is made. It probably belongs where the key checking and
                // instantiateReactComponent is done.

                var prevRef = null;
                var prevOwner = null;
                if (prevElement !== null && typeof prevElement === 'object') {
                    prevRef = prevElement.ref;
                    prevOwner = prevElement._owner;
                }

                var nextRef = null;
                var nextOwner = null;
                if (nextElement !== null && typeof nextElement === 'object') {
                    nextRef = nextElement.ref;
                    nextOwner = nextElement._owner;
                }

                return prevRef !== nextRef ||
                    // If owner changes but we have an unchanged function ref, don't update refs
                    typeof nextRef === 'string' && nextOwner !== prevOwner;
            };

            ReactRef.detachRefs = function(instance, element) {
                if (element === null || typeof element !== 'object') {
                    return;
                }
                var ref = element.ref;
                if (ref != null) {
                    detachRef(ref, instance, element._owner);
                }
            };

            module.exports = ReactRef;
        }, {
            "./ReactOwner": 97
        }],
        103: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var PooledClass = _dereq_('./PooledClass');
                var Transaction = _dereq_('./Transaction');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');
                var ReactServerUpdateQueue = _dereq_('./ReactServerUpdateQueue');

                var TRANSACTION_WRAPPERS = [];

                if (process.env.NODE_ENV !== 'production') {
                    TRANSACTION_WRAPPERS.push({
                        initialize: ReactInstrumentation.debugTool.onBeginFlush,
                        close: ReactInstrumentation.debugTool.onEndFlush
                    });
                }

                var noopCallbackQueue = {
                    enqueue: function() {}
                };

                function ReactServerRenderingTransaction(renderToStaticMarkup) {
                    this.reinitializeTransaction();
                    this.renderToStaticMarkup = renderToStaticMarkup;
                    this.useCreateElement = false;
                    this.updateQueue = new ReactServerUpdateQueue(this);
                }

                var Mixin = {

                    getTransactionWrappers: function() {
                        return TRANSACTION_WRAPPERS;
                    },


                    getReactMountReady: function() {
                        return noopCallbackQueue;
                    },


                    getUpdateQueue: function() {
                        return this.updateQueue;
                    },


                    destructor: function() {},

                    checkpoint: function() {},

                    rollback: function() {}
                };

                _assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

                PooledClass.addPoolingTo(ReactServerRenderingTransaction);

                module.exports = ReactServerRenderingTransaction;
            }).call(this, _dereq_('_process'))
        }, {
            "./PooledClass": 53,
            "./ReactInstrumentation": 91,
            "./ReactServerUpdateQueue": 104,
            "./Transaction": 124,
            "_process": 28,
            "object-assign": 27
        }],
        104: [function(_dereq_, module, exports) {
            (function(process) {

                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }

                var ReactUpdateQueue = _dereq_('./ReactUpdateQueue');

                var warning = _dereq_('fbjs/lib/warning');

                function warnNoop(publicInstance, callerName) {
                    if (process.env.NODE_ENV !== 'production') {
                        var constructor = publicInstance.constructor;
                        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
                    }
                }

                var ReactServerUpdateQueue = function() {
                    function ReactServerUpdateQueue(transaction) {
                        _classCallCheck(this, ReactServerUpdateQueue);

                        this.transaction = transaction;
                    }



                    ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
                        return false;
                    };



                    ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
                        if (this.transaction.isInTransaction()) {
                            ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
                        }
                    };



                    ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
                        if (this.transaction.isInTransaction()) {
                            ReactUpdateQueue.enqueueForceUpdate(publicInstance);
                        } else {
                            warnNoop(publicInstance, 'forceUpdate');
                        }
                    };



                    ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
                        if (this.transaction.isInTransaction()) {
                            ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
                        } else {
                            warnNoop(publicInstance, 'replaceState');
                        }
                    };



                    ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
                        if (this.transaction.isInTransaction()) {
                            ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
                        } else {
                            warnNoop(publicInstance, 'setState');
                        }
                    };

                    return ReactServerUpdateQueue;
                }();

                module.exports = ReactServerUpdateQueue;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactUpdateQueue": 105,
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        105: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactCurrentOwner = _dereq_('react/lib/ReactCurrentOwner');
                var ReactInstanceMap = _dereq_('./ReactInstanceMap');
                var ReactInstrumentation = _dereq_('./ReactInstrumentation');
                var ReactUpdates = _dereq_('./ReactUpdates');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                function enqueueUpdate(internalInstance) {
                    ReactUpdates.enqueueUpdate(internalInstance);
                }

                function formatUnexpectedArgument(arg) {
                    var type = typeof arg;
                    if (type !== 'object') {
                        return type;
                    }
                    var displayName = arg.constructor && arg.constructor.name || type;
                    var keys = Object.keys(arg);
                    if (keys.length > 0 && keys.length < 20) {
                        return displayName + ' (keys: ' + keys.join(', ') + ')';
                    }
                    return displayName;
                }

                function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
                    var internalInstance = ReactInstanceMap.get(publicInstance);
                    if (!internalInstance) {
                        if (process.env.NODE_ENV !== 'production') {
                            var ctor = publicInstance.constructor;
                            // Only warn when we have a callerName. Otherwise we should be silent.
                            // We're probably calling from enqueueCallback. We don't want to warn
                            // there because we already warned for the corresponding lifecycle method.
                            process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
                        }
                        return null;
                    }

                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
                    }

                    return internalInstance;
                }

                var ReactUpdateQueue = {


                    isMounted: function(publicInstance) {
                        if (process.env.NODE_ENV !== 'production') {
                            var owner = ReactCurrentOwner.current;
                            if (owner !== null) {
                                process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
                                owner._warnedAboutRefsInRender = true;
                            }
                        }
                        var internalInstance = ReactInstanceMap.get(publicInstance);
                        if (internalInstance) {
                            // During componentWillMount and render this will still be null but after
                            // that will always render to something. At least for now. So we can use
                            // this hack.
                            return !!internalInstance._renderedComponent;
                        } else {
                            return false;
                        }
                    },


                    enqueueCallback: function(publicInstance, callback, callerName) {
                        ReactUpdateQueue.validateCallback(callback, callerName);
                        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

                        // Previously we would throw an error if we didn't have an internal
                        // instance. Since we want to make it a no-op instead, we mirror the same
                        // behavior we have in other enqueue* methods.
                        // We also need to ignore callbacks in componentWillMount. See
                        // enqueueUpdates.
                        if (!internalInstance) {
                            return null;
                        }

                        if (internalInstance._pendingCallbacks) {
                            internalInstance._pendingCallbacks.push(callback);
                        } else {
                            internalInstance._pendingCallbacks = [callback];
                        }
                        // TODO: The callback here is ignored when setState is called from
                        // componentWillMount. Either fix it or disallow doing so completely in
                        // favor of getInitialState. Alternatively, we can disallow
                        // componentWillMount during server-side rendering.
                        enqueueUpdate(internalInstance);
                    },

                    enqueueCallbackInternal: function(internalInstance, callback) {
                        if (internalInstance._pendingCallbacks) {
                            internalInstance._pendingCallbacks.push(callback);
                        } else {
                            internalInstance._pendingCallbacks = [callback];
                        }
                        enqueueUpdate(internalInstance);
                    },


                    enqueueForceUpdate: function(publicInstance) {
                        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

                        if (!internalInstance) {
                            return;
                        }

                        internalInstance._pendingForceUpdate = true;

                        enqueueUpdate(internalInstance);
                    },


                    enqueueReplaceState: function(publicInstance, completeState) {
                        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

                        if (!internalInstance) {
                            return;
                        }

                        internalInstance._pendingStateQueue = [completeState];
                        internalInstance._pendingReplaceState = true;

                        enqueueUpdate(internalInstance);
                    },


                    enqueueSetState: function(publicInstance, partialState) {
                        if (process.env.NODE_ENV !== 'production') {
                            ReactInstrumentation.debugTool.onSetState();
                            process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
                        }

                        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

                        if (!internalInstance) {
                            return;
                        }

                        var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
                        queue.push(partialState);

                        enqueueUpdate(internalInstance);
                    },

                    enqueueElementInternal: function(internalInstance, nextElement, nextContext) {
                        internalInstance._pendingElement = nextElement;
                        // TODO: introduce _pendingContext instead of setting it directly.
                        internalInstance._context = nextContext;
                        enqueueUpdate(internalInstance);
                    },

                    validateCallback: function(callback, callerName) {
                        !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)): void 0;
                    }

                };

                module.exports = ReactUpdateQueue;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactInstanceMap": 90,
            "./ReactInstrumentation": 91,
            "./ReactUpdates": 106,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "react/lib/ReactCurrentOwner": 163
        }],
        106: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var CallbackQueue = _dereq_('./CallbackQueue');
                var PooledClass = _dereq_('./PooledClass');
                var ReactFeatureFlags = _dereq_('./ReactFeatureFlags');
                var ReactReconciler = _dereq_('./ReactReconciler');
                var Transaction = _dereq_('./Transaction');

                var invariant = _dereq_('fbjs/lib/invariant');

                var dirtyComponents = [];
                var updateBatchNumber = 0;
                var asapCallbackQueue = CallbackQueue.getPooled();
                var asapEnqueued = false;

                var batchingStrategy = null;

                function ensureInjected() {
                    !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123'): void 0;
                }

                var NESTED_UPDATES = {
                    initialize: function() {
                        this.dirtyComponentsLength = dirtyComponents.length;
                    },
                    close: function() {
                        if (this.dirtyComponentsLength !== dirtyComponents.length) {
                            // Additional updates were enqueued by componentDidUpdate handlers or
                            // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
                            // these new updates so that if A's componentDidUpdate calls setState on
                            // B, B will update before the callback A's updater provided when calling
                            // setState.
                            dirtyComponents.splice(0, this.dirtyComponentsLength);
                            flushBatchedUpdates();
                        } else {
                            dirtyComponents.length = 0;
                        }
                    }
                };

                var UPDATE_QUEUEING = {
                    initialize: function() {
                        this.callbackQueue.reset();
                    },
                    close: function() {
                        this.callbackQueue.notifyAll();
                    }
                };

                var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

                function ReactUpdatesFlushTransaction() {
                    this.reinitializeTransaction();
                    this.dirtyComponentsLength = null;
                    this.callbackQueue = CallbackQueue.getPooled();
                    this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
                        true);
                }

                _assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
                    getTransactionWrappers: function() {
                        return TRANSACTION_WRAPPERS;
                    },

                    destructor: function() {
                        this.dirtyComponentsLength = null;
                        CallbackQueue.release(this.callbackQueue);
                        this.callbackQueue = null;
                        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
                        this.reconcileTransaction = null;
                    },

                    perform: function(method, scope, a) {
                        // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
                        // with this transaction's wrappers around it.
                        return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
                    }
                });

                PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

                function batchedUpdates(callback, a, b, c, d, e) {
                    ensureInjected();
                    return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
                }

                function mountOrderComparator(c1, c2) {
                    return c1._mountOrder - c2._mountOrder;
                }

                function runBatchedUpdates(transaction) {
                    var len = transaction.dirtyComponentsLength;
                    !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length): void 0;

                    // Since reconciling a component higher in the owner hierarchy usually (not
                    // always -- see shouldComponentUpdate()) will reconcile children, reconcile
                    // them before their children by sorting the array.
                    dirtyComponents.sort(mountOrderComparator);

                    // Any updates enqueued while reconciling must be performed after this entire
                    // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
                    // C, B could update twice in a single batch if C's render enqueues an update
                    // to B (since B would have already updated, we should skip it, and the only
                    // way we can know to do so is by checking the batch counter).
                    updateBatchNumber++;

                    for (var i = 0; i < len; i++) {
                        // If a component is unmounted before pending changes apply, it will still
                        // be here, but we assume that it has cleared its _pendingCallbacks and
                        // that performUpdateIfNecessary is a noop.
                        var component = dirtyComponents[i];

                        // If performUpdateIfNecessary happens to enqueue any new updates, we
                        // shouldn't execute the callbacks until the next render happens, so
                        // stash the callbacks first
                        var callbacks = component._pendingCallbacks;
                        component._pendingCallbacks = null;

                        var markerName;
                        if (ReactFeatureFlags.logTopLevelRenders) {
                            var namedComponent = component;
                            // Duck type TopLevelWrapper. This is probably always true.
                            if (component._currentElement.type.isReactTopLevelWrapper) {
                                namedComponent = component._renderedComponent;
                            }
                            markerName = 'React update: ' + namedComponent.getName();
                            console.time(markerName);
                        }

                        ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

                        if (markerName) {
                            console.timeEnd(markerName);
                        }

                        if (callbacks) {
                            for (var j = 0; j < callbacks.length; j++) {
                                transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
                            }
                        }
                    }
                }

                var flushBatchedUpdates = function() {
                    // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
                    // array and perform any updates enqueued by mount-ready handlers (i.e.,
                    // componentDidUpdate) but we need to check here too in order to catch
                    // updates enqueued by setState callbacks and asap calls.
                    while (dirtyComponents.length || asapEnqueued) {
                        if (dirtyComponents.length) {
                            var transaction = ReactUpdatesFlushTransaction.getPooled();
                            transaction.perform(runBatchedUpdates, null, transaction);
                            ReactUpdatesFlushTransaction.release(transaction);
                        }

                        if (asapEnqueued) {
                            asapEnqueued = false;
                            var queue = asapCallbackQueue;
                            asapCallbackQueue = CallbackQueue.getPooled();
                            queue.notifyAll();
                            CallbackQueue.release(queue);
                        }
                    }
                };

                function enqueueUpdate(component) {
                    ensureInjected();

                    // Various parts of our code (such as ReactCompositeComponent's
                    // _renderValidatedComponent) assume that calls to render aren't nested;
                    // verify that that's the case. (This is called by each top-level update
                    // function, like setState, forceUpdate, etc.; creation and
                    // destruction of top-level components is guarded in ReactMount.)

                    if (!batchingStrategy.isBatchingUpdates) {
                        batchingStrategy.batchedUpdates(enqueueUpdate, component);
                        return;
                    }

                    dirtyComponents.push(component);
                    if (component._updateBatchNumber == null) {
                        component._updateBatchNumber = updateBatchNumber + 1;
                    }
                }

                function asap(callback, context) {
                    !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
                    asapCallbackQueue.enqueue(callback, context);
                    asapEnqueued = true;
                }

                var ReactUpdatesInjection = {
                    injectReconcileTransaction: function(ReconcileTransaction) {
                        !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
                        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
                    },

                    injectBatchingStrategy: function(_batchingStrategy) {
                        !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
                        !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128'): void 0;
                        !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129'): void 0;
                        batchingStrategy = _batchingStrategy;
                    }
                };

                var ReactUpdates = {

                    ReactReconcileTransaction: null,

                    batchedUpdates: batchedUpdates,
                    enqueueUpdate: enqueueUpdate,
                    flushBatchedUpdates: flushBatchedUpdates,
                    injection: ReactUpdatesInjection,
                    asap: asap
                };

                module.exports = ReactUpdates;
            }).call(this, _dereq_('_process'))
        }, {
            "./CallbackQueue": 35,
            "./PooledClass": 53,
            "./ReactFeatureFlags": 85,
            "./ReactReconciler": 101,
            "./Transaction": 124,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "object-assign": 27
        }],
        107: [function(_dereq_, module, exports) {

            module.exports = '15.4.1';
        }, {}],
        108: [function(_dereq_, module, exports) {

            var NS = {
                xlink: 'http://www.w3.org/1999/xlink',
                xml: 'http://www.w3.org/XML/1998/namespace'
            };

            // We use attributes for everything SVG so let's avoid some duplication and run
            // code instead.
            // The following are all specified in the HTML config already so we exclude here.
            // - class (as className)
            // - color
            // - height
            // - id
            // - lang
            // - max
            // - media
            // - method
            // - min
            // - name
            // - style
            // - target
            // - type
            // - width
            var ATTRS = {
                accentHeight: 'accent-height',
                accumulate: 0,
                additive: 0,
                alignmentBaseline: 'alignment-baseline',
                allowReorder: 'allowReorder',
                alphabetic: 0,
                amplitude: 0,
                arabicForm: 'arabic-form',
                ascent: 0,
                attributeName: 'attributeName',
                attributeType: 'attributeType',
                autoReverse: 'autoReverse',
                azimuth: 0,
                baseFrequency: 'baseFrequency',
                baseProfile: 'baseProfile',
                baselineShift: 'baseline-shift',
                bbox: 0,
                begin: 0,
                bias: 0,
                by: 0,
                calcMode: 'calcMode',
                capHeight: 'cap-height',
                clip: 0,
                clipPath: 'clip-path',
                clipRule: 'clip-rule',
                clipPathUnits: 'clipPathUnits',
                colorInterpolation: 'color-interpolation',
                colorInterpolationFilters: 'color-interpolation-filters',
                colorProfile: 'color-profile',
                colorRendering: 'color-rendering',
                contentScriptType: 'contentScriptType',
                contentStyleType: 'contentStyleType',
                cursor: 0,
                cx: 0,
                cy: 0,
                d: 0,
                decelerate: 0,
                descent: 0,
                diffuseConstant: 'diffuseConstant',
                direction: 0,
                display: 0,
                divisor: 0,
                dominantBaseline: 'dominant-baseline',
                dur: 0,
                dx: 0,
                dy: 0,
                edgeMode: 'edgeMode',
                elevation: 0,
                enableBackground: 'enable-background',
                end: 0,
                exponent: 0,
                externalResourcesRequired: 'externalResourcesRequired',
                fill: 0,
                fillOpacity: 'fill-opacity',
                fillRule: 'fill-rule',
                filter: 0,
                filterRes: 'filterRes',
                filterUnits: 'filterUnits',
                floodColor: 'flood-color',
                floodOpacity: 'flood-opacity',
                focusable: 0,
                fontFamily: 'font-family',
                fontSize: 'font-size',
                fontSizeAdjust: 'font-size-adjust',
                fontStretch: 'font-stretch',
                fontStyle: 'font-style',
                fontVariant: 'font-variant',
                fontWeight: 'font-weight',
                format: 0,
                from: 0,
                fx: 0,
                fy: 0,
                g1: 0,
                g2: 0,
                glyphName: 'glyph-name',
                glyphOrientationHorizontal: 'glyph-orientation-horizontal',
                glyphOrientationVertical: 'glyph-orientation-vertical',
                glyphRef: 'glyphRef',
                gradientTransform: 'gradientTransform',
                gradientUnits: 'gradientUnits',
                hanging: 0,
                horizAdvX: 'horiz-adv-x',
                horizOriginX: 'horiz-origin-x',
                ideographic: 0,
                imageRendering: 'image-rendering',
                'in': 0,
                in2: 0,
                intercept: 0,
                k: 0,
                k1: 0,
                k2: 0,
                k3: 0,
                k4: 0,
                kernelMatrix: 'kernelMatrix',
                kernelUnitLength: 'kernelUnitLength',
                kerning: 0,
                keyPoints: 'keyPoints',
                keySplines: 'keySplines',
                keyTimes: 'keyTimes',
                lengthAdjust: 'lengthAdjust',
                letterSpacing: 'letter-spacing',
                lightingColor: 'lighting-color',
                limitingConeAngle: 'limitingConeAngle',
                local: 0,
                markerEnd: 'marker-end',
                markerMid: 'marker-mid',
                markerStart: 'marker-start',
                markerHeight: 'markerHeight',
                markerUnits: 'markerUnits',
                markerWidth: 'markerWidth',
                mask: 0,
                maskContentUnits: 'maskContentUnits',
                maskUnits: 'maskUnits',
                mathematical: 0,
                mode: 0,
                numOctaves: 'numOctaves',
                offset: 0,
                opacity: 0,
                operator: 0,
                order: 0,
                orient: 0,
                orientation: 0,
                origin: 0,
                overflow: 0,
                overlinePosition: 'overline-position',
                overlineThickness: 'overline-thickness',
                paintOrder: 'paint-order',
                panose1: 'panose-1',
                pathLength: 'pathLength',
                patternContentUnits: 'patternContentUnits',
                patternTransform: 'patternTransform',
                patternUnits: 'patternUnits',
                pointerEvents: 'pointer-events',
                points: 0,
                pointsAtX: 'pointsAtX',
                pointsAtY: 'pointsAtY',
                pointsAtZ: 'pointsAtZ',
                preserveAlpha: 'preserveAlpha',
                preserveAspectRatio: 'preserveAspectRatio',
                primitiveUnits: 'primitiveUnits',
                r: 0,
                radius: 0,
                refX: 'refX',
                refY: 'refY',
                renderingIntent: 'rendering-intent',
                repeatCount: 'repeatCount',
                repeatDur: 'repeatDur',
                requiredExtensions: 'requiredExtensions',
                requiredFeatures: 'requiredFeatures',
                restart: 0,
                result: 0,
                rotate: 0,
                rx: 0,
                ry: 0,
                scale: 0,
                seed: 0,
                shapeRendering: 'shape-rendering',
                slope: 0,
                spacing: 0,
                specularConstant: 'specularConstant',
                specularExponent: 'specularExponent',
                speed: 0,
                spreadMethod: 'spreadMethod',
                startOffset: 'startOffset',
                stdDeviation: 'stdDeviation',
                stemh: 0,
                stemv: 0,
                stitchTiles: 'stitchTiles',
                stopColor: 'stop-color',
                stopOpacity: 'stop-opacity',
                strikethroughPosition: 'strikethrough-position',
                strikethroughThickness: 'strikethrough-thickness',
                string: 0,
                stroke: 0,
                strokeDasharray: 'stroke-dasharray',
                strokeDashoffset: 'stroke-dashoffset',
                strokeLinecap: 'stroke-linecap',
                strokeLinejoin: 'stroke-linejoin',
                strokeMiterlimit: 'stroke-miterlimit',
                strokeOpacity: 'stroke-opacity',
                strokeWidth: 'stroke-width',
                surfaceScale: 'surfaceScale',
                systemLanguage: 'systemLanguage',
                tableValues: 'tableValues',
                targetX: 'targetX',
                targetY: 'targetY',
                textAnchor: 'text-anchor',
                textDecoration: 'text-decoration',
                textRendering: 'text-rendering',
                textLength: 'textLength',
                to: 0,
                transform: 0,
                u1: 0,
                u2: 0,
                underlinePosition: 'underline-position',
                underlineThickness: 'underline-thickness',
                unicode: 0,
                unicodeBidi: 'unicode-bidi',
                unicodeRange: 'unicode-range',
                unitsPerEm: 'units-per-em',
                vAlphabetic: 'v-alphabetic',
                vHanging: 'v-hanging',
                vIdeographic: 'v-ideographic',
                vMathematical: 'v-mathematical',
                values: 0,
                vectorEffect: 'vector-effect',
                version: 0,
                vertAdvY: 'vert-adv-y',
                vertOriginX: 'vert-origin-x',
                vertOriginY: 'vert-origin-y',
                viewBox: 'viewBox',
                viewTarget: 'viewTarget',
                visibility: 0,
                widths: 0,
                wordSpacing: 'word-spacing',
                writingMode: 'writing-mode',
                x: 0,
                xHeight: 'x-height',
                x1: 0,
                x2: 0,
                xChannelSelector: 'xChannelSelector',
                xlinkActuate: 'xlink:actuate',
                xlinkArcrole: 'xlink:arcrole',
                xlinkHref: 'xlink:href',
                xlinkRole: 'xlink:role',
                xlinkShow: 'xlink:show',
                xlinkTitle: 'xlink:title',
                xlinkType: 'xlink:type',
                xmlBase: 'xml:base',
                xmlns: 0,
                xmlnsXlink: 'xmlns:xlink',
                xmlLang: 'xml:lang',
                xmlSpace: 'xml:space',
                y: 0,
                y1: 0,
                y2: 0,
                yChannelSelector: 'yChannelSelector',
                z: 0,
                zoomAndPan: 'zoomAndPan'
            };

            var SVGDOMPropertyConfig = {
                Properties: {},
                DOMAttributeNamespaces: {
                    xlinkActuate: NS.xlink,
                    xlinkArcrole: NS.xlink,
                    xlinkHref: NS.xlink,
                    xlinkRole: NS.xlink,
                    xlinkShow: NS.xlink,
                    xlinkTitle: NS.xlink,
                    xlinkType: NS.xlink,
                    xmlBase: NS.xml,
                    xmlLang: NS.xml,
                    xmlSpace: NS.xml
                },
                DOMAttributeNames: {}
            };

            Object.keys(ATTRS).forEach(function(key) {
                SVGDOMPropertyConfig.Properties[key] = 0;
                if (ATTRS[key]) {
                    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
                }
            });

            module.exports = SVGDOMPropertyConfig;
        }, {}],
        109: [function(_dereq_, module, exports) {

            var EventPropagators = _dereq_('./EventPropagators');
            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
            var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
            var ReactInputSelection = _dereq_('./ReactInputSelection');
            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var getActiveElement = _dereq_('fbjs/lib/getActiveElement');
            var isTextInputElement = _dereq_('./isTextInputElement');
            var shallowEqual = _dereq_('fbjs/lib/shallowEqual');

            var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

            var eventTypes = {
                select: {
                    phasedRegistrationNames: {
                        bubbled: 'onSelect',
                        captured: 'onSelectCapture'
                    },
                    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
                }
            };

            var activeElement = null;
            var activeElementInst = null;
            var lastSelection = null;
            var mouseDown = false;

            // Track whether a listener exists for this plugin. If none exist, we do
            // not extract events. See #3639.
            var hasListener = false;

            function getSelection(node) {
                if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
                    return {
                        start: node.selectionStart,
                        end: node.selectionEnd
                    };
                } else if (window.getSelection) {
                    var selection = window.getSelection();
                    return {
                        anchorNode: selection.anchorNode,
                        anchorOffset: selection.anchorOffset,
                        focusNode: selection.focusNode,
                        focusOffset: selection.focusOffset
                    };
                } else if (document.selection) {
                    var range = document.selection.createRange();
                    return {
                        parentElement: range.parentElement(),
                        text: range.text,
                        top: range.boundingTop,
                        left: range.boundingLeft
                    };
                }
            }

            function constructSelectEvent(nativeEvent, nativeEventTarget) {
                // Ensure we have the right element, and that the user is not dragging a
                // selection (this matches native `select` event behavior). In HTML5, select
                // fires only on input and textarea thus if there's no focused element we
                // won't dispatch.
                if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
                    return null;
                }

                // Only fire when selection has actually changed.
                var currentSelection = getSelection(activeElement);
                if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
                    lastSelection = currentSelection;

                    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

                    syntheticEvent.type = 'select';
                    syntheticEvent.target = activeElement;

                    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

                    return syntheticEvent;
                }

                return null;
            }

            var SelectEventPlugin = {

                eventTypes: eventTypes,

                extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                    if (!hasListener) {
                        return null;
                    }

                    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

                    switch (topLevelType) {
                        // Track the input node that has focus.
                        case 'topFocus':
                            if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
                                activeElement = targetNode;
                                activeElementInst = targetInst;
                                lastSelection = null;
                            }
                            break;
                        case 'topBlur':
                            activeElement = null;
                            activeElementInst = null;
                            lastSelection = null;
                            break;

                            // Don't fire the event while the user is dragging. This matches the
                            // semantics of the native select event.
                        case 'topMouseDown':
                            mouseDown = true;
                            break;
                        case 'topContextMenu':
                        case 'topMouseUp':
                            mouseDown = false;
                            return constructSelectEvent(nativeEvent, nativeEventTarget);

                            // Chrome and IE fire non-standard event when selection is changed (and
                            // sometimes when it hasn't). IE's event fires out of order with respect
                            // to key and input events on deletion, so we discard it.
                            //
                            // Firefox doesn't support selectionchange, so check selection status
                            // after each key entry. The selection changes after keydown and before
                            // keyup, but we check on keydown as well in the case of holding down a
                            // key, when multiple keydown events are fired but only one keyup is.
                            // This is also our approach for IE handling, for the reason above.
                        case 'topSelectionChange':
                            if (skipSelectionChangeEvent) {
                                break;
                            }
                            // falls through
                        case 'topKeyDown':
                        case 'topKeyUp':
                            return constructSelectEvent(nativeEvent, nativeEventTarget);
                    }

                    return null;
                },

                didPutListener: function(inst, registrationName, listener) {
                    if (registrationName === 'onSelect') {
                        hasListener = true;
                    }
                }
            };

            module.exports = SelectEventPlugin;
        }, {
            "./EventPropagators": 48,
            "./ReactDOMComponentTree": 62,
            "./ReactInputSelection": 89,
            "./SyntheticEvent": 115,
            "./isTextInputElement": 147,
            "fbjs/lib/ExecutionEnvironment": 3,
            "fbjs/lib/getActiveElement": 12,
            "fbjs/lib/shallowEqual": 23
        }],
        110: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var EventListener = _dereq_('fbjs/lib/EventListener');
                var EventPropagators = _dereq_('./EventPropagators');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var SyntheticAnimationEvent = _dereq_('./SyntheticAnimationEvent');
                var SyntheticClipboardEvent = _dereq_('./SyntheticClipboardEvent');
                var SyntheticEvent = _dereq_('./SyntheticEvent');
                var SyntheticFocusEvent = _dereq_('./SyntheticFocusEvent');
                var SyntheticKeyboardEvent = _dereq_('./SyntheticKeyboardEvent');
                var SyntheticMouseEvent = _dereq_('./SyntheticMouseEvent');
                var SyntheticDragEvent = _dereq_('./SyntheticDragEvent');
                var SyntheticTouchEvent = _dereq_('./SyntheticTouchEvent');
                var SyntheticTransitionEvent = _dereq_('./SyntheticTransitionEvent');
                var SyntheticUIEvent = _dereq_('./SyntheticUIEvent');
                var SyntheticWheelEvent = _dereq_('./SyntheticWheelEvent');

                var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
                var getEventCharCode = _dereq_('./getEventCharCode');
                var invariant = _dereq_('fbjs/lib/invariant');

                var eventTypes = {};
                var topLevelEventsToDispatchConfig = {};
                ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function(event) {
                    var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
                    var onEvent = 'on' + capitalizedEvent;
                    var topEvent = 'top' + capitalizedEvent;

                    var type = {
                        phasedRegistrationNames: {
                            bubbled: onEvent,
                            captured: onEvent + 'Capture'
                        },
                        dependencies: [topEvent]
                    };
                    eventTypes[event] = type;
                    topLevelEventsToDispatchConfig[topEvent] = type;
                });

                var onClickListeners = {};

                function getDictionaryKey(inst) {
                    // Prevents V8 performance issue:
                    // https://github.com/facebook/react/pull/7232
                    return '.' + inst._rootNodeID;
                }

                function isInteractive(tag) {
                    return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
                }

                var SimpleEventPlugin = {

                    eventTypes: eventTypes,

                    extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
                        if (!dispatchConfig) {
                            return null;
                        }
                        var EventConstructor;
                        switch (topLevelType) {
                            case 'topAbort':
                            case 'topCanPlay':
                            case 'topCanPlayThrough':
                            case 'topDurationChange':
                            case 'topEmptied':
                            case 'topEncrypted':
                            case 'topEnded':
                            case 'topError':
                            case 'topInput':
                            case 'topInvalid':
                            case 'topLoad':
                            case 'topLoadedData':
                            case 'topLoadedMetadata':
                            case 'topLoadStart':
                            case 'topPause':
                            case 'topPlay':
                            case 'topPlaying':
                            case 'topProgress':
                            case 'topRateChange':
                            case 'topReset':
                            case 'topSeeked':
                            case 'topSeeking':
                            case 'topStalled':
                            case 'topSubmit':
                            case 'topSuspend':
                            case 'topTimeUpdate':
                            case 'topVolumeChange':
                            case 'topWaiting':
                                // HTML Events
                                // @see http://www.w3.org/TR/html5/index.html#events-0
                                EventConstructor = SyntheticEvent;
                                break;
                            case 'topKeyPress':
                                // Firefox creates a keypress event for function keys too. This removes
                                // the unwanted keypress events. Enter is however both printable and
                                // non-printable. One would expect Tab to be as well (but it isn't).
                                if (getEventCharCode(nativeEvent) === 0) {
                                    return null;
                                }

                            case 'topKeyDown':
                            case 'topKeyUp':
                                EventConstructor = SyntheticKeyboardEvent;
                                break;
                            case 'topBlur':
                            case 'topFocus':
                                EventConstructor = SyntheticFocusEvent;
                                break;
                            case 'topClick':
                                // Firefox creates a click event on right mouse clicks. This removes the
                                // unwanted click events.
                                if (nativeEvent.button === 2) {
                                    return null;
                                }

                            case 'topDoubleClick':
                            case 'topMouseDown':
                            case 'topMouseMove':
                            case 'topMouseUp':
                                // TODO: Disabled elements should not respond to mouse events

                            case 'topMouseOut':
                            case 'topMouseOver':
                            case 'topContextMenu':
                                EventConstructor = SyntheticMouseEvent;
                                break;
                            case 'topDrag':
                            case 'topDragEnd':
                            case 'topDragEnter':
                            case 'topDragExit':
                            case 'topDragLeave':
                            case 'topDragOver':
                            case 'topDragStart':
                            case 'topDrop':
                                EventConstructor = SyntheticDragEvent;
                                break;
                            case 'topTouchCancel':
                            case 'topTouchEnd':
                            case 'topTouchMove':
                            case 'topTouchStart':
                                EventConstructor = SyntheticTouchEvent;
                                break;
                            case 'topAnimationEnd':
                            case 'topAnimationIteration':
                            case 'topAnimationStart':
                                EventConstructor = SyntheticAnimationEvent;
                                break;
                            case 'topTransitionEnd':
                                EventConstructor = SyntheticTransitionEvent;
                                break;
                            case 'topScroll':
                                EventConstructor = SyntheticUIEvent;
                                break;
                            case 'topWheel':
                                EventConstructor = SyntheticWheelEvent;
                                break;
                            case 'topCopy':
                            case 'topCut':
                            case 'topPaste':
                                EventConstructor = SyntheticClipboardEvent;
                                break;
                        }!EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
                        var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
                        EventPropagators.accumulateTwoPhaseDispatches(event);
                        return event;
                    },

                    didPutListener: function(inst, registrationName, listener) {
                        // Mobile Safari does not fire properly bubble click events on
                        // non-interactive elements, which means delegated click listeners do not
                        // fire. The workaround for this bug involves attaching an empty click
                        // listener on the target node.
                        // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
                        if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
                            var key = getDictionaryKey(inst);
                            var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                            if (!onClickListeners[key]) {
                                onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
                            }
                        }
                    },

                    willDeleteListener: function(inst, registrationName) {
                        if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
                            var key = getDictionaryKey(inst);
                            onClickListeners[key].remove();
                            delete onClickListeners[key];
                        }
                    }

                };

                module.exports = SimpleEventPlugin;
            }).call(this, _dereq_('_process'))
        }, {
            "./EventPropagators": 48,
            "./ReactDOMComponentTree": 62,
            "./SyntheticAnimationEvent": 111,
            "./SyntheticClipboardEvent": 112,
            "./SyntheticDragEvent": 114,
            "./SyntheticEvent": 115,
            "./SyntheticFocusEvent": 116,
            "./SyntheticKeyboardEvent": 118,
            "./SyntheticMouseEvent": 119,
            "./SyntheticTouchEvent": 120,
            "./SyntheticTransitionEvent": 121,
            "./SyntheticUIEvent": 122,
            "./SyntheticWheelEvent": 123,
            "./getEventCharCode": 135,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/EventListener": 2,
            "fbjs/lib/emptyFunction": 9,
            "fbjs/lib/invariant": 17
        }],
        111: [function(_dereq_, module, exports) {

            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var AnimationEventInterface = {
                animationName: null,
                elapsedTime: null,
                pseudoElement: null
            };

            function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

            module.exports = SyntheticAnimationEvent;
        }, {
            "./SyntheticEvent": 115
        }],
        112: [function(_dereq_, module, exports) {

            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var ClipboardEventInterface = {
                clipboardData: function(event) {
                    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
                }
            };

            function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

            module.exports = SyntheticClipboardEvent;
        }, {
            "./SyntheticEvent": 115
        }],
        113: [function(_dereq_, module, exports) {

            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var CompositionEventInterface = {
                data: null
            };

            function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

            module.exports = SyntheticCompositionEvent;
        }, {
            "./SyntheticEvent": 115
        }],
        114: [function(_dereq_, module, exports) {

            var SyntheticMouseEvent = _dereq_('./SyntheticMouseEvent');

            var DragEventInterface = {
                dataTransfer: null
            };

            function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

            module.exports = SyntheticDragEvent;
        }, {
            "./SyntheticMouseEvent": 119
        }],
        115: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var PooledClass = _dereq_('./PooledClass');

                var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
                var warning = _dereq_('fbjs/lib/warning');

                var didWarnForAddedNewProperty = false;
                var isProxySupported = typeof Proxy === 'function';

                var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

                var EventInterface = {
                    type: null,
                    target: null,
                    // currentTarget is set when dispatching; no use in copying it here
                    currentTarget: emptyFunction.thatReturnsNull,
                    eventPhase: null,
                    bubbles: null,
                    cancelable: null,
                    timeStamp: function(event) {
                        return event.timeStamp || Date.now();
                    },
                    defaultPrevented: null,
                    isTrusted: null
                };

                function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
                    if (process.env.NODE_ENV !== 'production') {
                        // these have a getter/setter for warnings
                        delete this.nativeEvent;
                        delete this.preventDefault;
                        delete this.stopPropagation;
                    }

                    this.dispatchConfig = dispatchConfig;
                    this._targetInst = targetInst;
                    this.nativeEvent = nativeEvent;

                    var Interface = this.constructor.Interface;
                    for (var propName in Interface) {
                        if (!Interface.hasOwnProperty(propName)) {
                            continue;
                        }
                        if (process.env.NODE_ENV !== 'production') {
                            delete this[propName]; // this has a getter/setter for warnings
                        }
                        var normalize = Interface[propName];
                        if (normalize) {
                            this[propName] = normalize(nativeEvent);
                        } else {
                            if (propName === 'target') {
                                this.target = nativeEventTarget;
                            } else {
                                this[propName] = nativeEvent[propName];
                            }
                        }
                    }

                    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
                    if (defaultPrevented) {
                        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
                    } else {
                        this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
                    }
                    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
                    return this;
                }

                _assign(SyntheticEvent.prototype, {

                    preventDefault: function() {
                        this.defaultPrevented = true;
                        var event = this.nativeEvent;
                        if (!event) {
                            return;
                        }

                        if (event.preventDefault) {
                            event.preventDefault();
                        } else if (typeof event.returnValue !== 'unknown') {
                            // eslint-disable-line valid-typeof
                            event.returnValue = false;
                        }
                        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
                    },

                    stopPropagation: function() {
                        var event = this.nativeEvent;
                        if (!event) {
                            return;
                        }

                        if (event.stopPropagation) {
                            event.stopPropagation();
                        } else if (typeof event.cancelBubble !== 'unknown') {
                            // eslint-disable-line valid-typeof
                            // The ChangeEventPlugin registers a "propertychange" event for
                            // IE. This event does not support bubbling or cancelling, and
                            // any references to cancelBubble throw "Member not found".  A
                            // typeof check of "unknown" circumvents this issue (and is also
                            // IE specific).
                            event.cancelBubble = true;
                        }

                        this.isPropagationStopped = emptyFunction.thatReturnsTrue;
                    },


                    persist: function() {
                        this.isPersistent = emptyFunction.thatReturnsTrue;
                    },


                    isPersistent: emptyFunction.thatReturnsFalse,


                    destructor: function() {
                        var Interface = this.constructor.Interface;
                        for (var propName in Interface) {
                            if (process.env.NODE_ENV !== 'production') {
                                Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
                            } else {
                                this[propName] = null;
                            }
                        }
                        for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
                            this[shouldBeReleasedProperties[i]] = null;
                        }
                        if (process.env.NODE_ENV !== 'production') {
                            Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
                            Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
                            Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
                        }
                    }

                });

                SyntheticEvent.Interface = EventInterface;

                if (process.env.NODE_ENV !== 'production') {
                    if (isProxySupported) {

                        SyntheticEvent = new Proxy(SyntheticEvent, {
                            construct: function(target, args) {
                                return this.apply(target, Object.create(target.prototype), args);
                            },
                            apply: function(constructor, that, args) {
                                return new Proxy(constructor.apply(that, args), {
                                    set: function(target, prop, value) {
                                        if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                                            process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
                                            didWarnForAddedNewProperty = true;
                                        }
                                        target[prop] = value;
                                        return true;
                                    }
                                });
                            }
                        });

                    }
                }

                SyntheticEvent.augmentClass = function(Class, Interface) {
                    var Super = this;

                    var E = function() {};
                    E.prototype = Super.prototype;
                    var prototype = new E();

                    _assign(prototype, Class.prototype);
                    Class.prototype = prototype;
                    Class.prototype.constructor = Class;

                    Class.Interface = _assign({}, Super.Interface, Interface);
                    Class.augmentClass = Super.augmentClass;

                    PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
                };

                PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

                module.exports = SyntheticEvent;

                function getPooledWarningPropertyDefinition(propName, getVal) {
                    var isFunction = typeof getVal === 'function';
                    return {
                        configurable: true,
                        set: set,
                        get: get
                    };

                    function set(val) {
                        var action = isFunction ? 'setting the method' : 'setting the property';
                        warn(action, 'This is effectively a no-op');
                        return val;
                    }

                    function get() {
                        var action = isFunction ? 'accessing the method' : 'accessing the property';
                        var result = isFunction ? 'This is a no-op function' : 'This is set to null';
                        warn(action, result);
                        return getVal;
                    }

                    function warn(action, result) {
                        var warningCondition = false;
                        process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
                    }
                }
            }).call(this, _dereq_('_process'))
        }, {
            "./PooledClass": 53,
            "_process": 28,
            "fbjs/lib/emptyFunction": 9,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        116: [function(_dereq_, module, exports) {

            var SyntheticUIEvent = _dereq_('./SyntheticUIEvent');

            var FocusEventInterface = {
                relatedTarget: null
            };

            function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

            module.exports = SyntheticFocusEvent;
        }, {
            "./SyntheticUIEvent": 122
        }],
        117: [function(_dereq_, module, exports) {

            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var InputEventInterface = {
                data: null
            };

            function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

            module.exports = SyntheticInputEvent;
        }, {
            "./SyntheticEvent": 115
        }],
        118: [function(_dereq_, module, exports) {

            var SyntheticUIEvent = _dereq_('./SyntheticUIEvent');

            var getEventCharCode = _dereq_('./getEventCharCode');
            var getEventKey = _dereq_('./getEventKey');
            var getEventModifierState = _dereq_('./getEventModifierState');

            var KeyboardEventInterface = {
                key: getEventKey,
                location: null,
                ctrlKey: null,
                shiftKey: null,
                altKey: null,
                metaKey: null,
                repeat: null,
                locale: null,
                getModifierState: getEventModifierState,
                // Legacy Interface
                charCode: function(event) {
                    // `charCode` is the result of a KeyPress event and represents the value of
                    // the actual printable character.

                    // KeyPress is deprecated, but its replacement is not yet final and not
                    // implemented in any major browser. Only KeyPress has charCode.
                    if (event.type === 'keypress') {
                        return getEventCharCode(event);
                    }
                    return 0;
                },
                keyCode: function(event) {
                    // `keyCode` is the result of a KeyDown/Up event and represents the value of
                    // physical keyboard key.

                    // The actual meaning of the value depends on the users' keyboard layout
                    // which cannot be detected. Assuming that it is a US keyboard layout
                    // provides a surprisingly accurate mapping for US and European users.
                    // Due to this, it is left to the user to implement at this time.
                    if (event.type === 'keydown' || event.type === 'keyup') {
                        return event.keyCode;
                    }
                    return 0;
                },
                which: function(event) {
                    // `which` is an alias for either `keyCode` or `charCode` depending on the
                    // type of the event.
                    if (event.type === 'keypress') {
                        return getEventCharCode(event);
                    }
                    if (event.type === 'keydown' || event.type === 'keyup') {
                        return event.keyCode;
                    }
                    return 0;
                }
            };

            function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

            module.exports = SyntheticKeyboardEvent;
        }, {
            "./SyntheticUIEvent": 122,
            "./getEventCharCode": 135,
            "./getEventKey": 136,
            "./getEventModifierState": 137
        }],
        119: [function(_dereq_, module, exports) {

            var SyntheticUIEvent = _dereq_('./SyntheticUIEvent');
            var ViewportMetrics = _dereq_('./ViewportMetrics');

            var getEventModifierState = _dereq_('./getEventModifierState');

            var MouseEventInterface = {
                screenX: null,
                screenY: null,
                clientX: null,
                clientY: null,
                ctrlKey: null,
                shiftKey: null,
                altKey: null,
                metaKey: null,
                getModifierState: getEventModifierState,
                button: function(event) {
                    // Webkit, Firefox, IE9+
                    // which:  1 2 3
                    // button: 0 1 2 (standard)
                    var button = event.button;
                    if ('which' in event) {
                        return button;
                    }
                    // IE<9
                    // which:  undefined
                    // button: 0 0 0
                    // button: 1 4 2 (onmouseup)
                    return button === 2 ? 2 : button === 4 ? 1 : 0;
                },
                buttons: null,
                relatedTarget: function(event) {
                    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
                },
                // "Proprietary" Interface.
                pageX: function(event) {
                    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
                },
                pageY: function(event) {
                    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
                }
            };

            function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

            module.exports = SyntheticMouseEvent;
        }, {
            "./SyntheticUIEvent": 122,
            "./ViewportMetrics": 125,
            "./getEventModifierState": 137
        }],
        120: [function(_dereq_, module, exports) {

            var SyntheticUIEvent = _dereq_('./SyntheticUIEvent');

            var getEventModifierState = _dereq_('./getEventModifierState');

            var TouchEventInterface = {
                touches: null,
                targetTouches: null,
                changedTouches: null,
                altKey: null,
                metaKey: null,
                ctrlKey: null,
                shiftKey: null,
                getModifierState: getEventModifierState
            };

            function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

            module.exports = SyntheticTouchEvent;
        }, {
            "./SyntheticUIEvent": 122,
            "./getEventModifierState": 137
        }],
        121: [function(_dereq_, module, exports) {

            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var TransitionEventInterface = {
                propertyName: null,
                elapsedTime: null,
                pseudoElement: null
            };

            function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

            module.exports = SyntheticTransitionEvent;
        }, {
            "./SyntheticEvent": 115
        }],
        122: [function(_dereq_, module, exports) {

            var SyntheticEvent = _dereq_('./SyntheticEvent');

            var getEventTarget = _dereq_('./getEventTarget');

            var UIEventInterface = {
                view: function(event) {
                    if (event.view) {
                        return event.view;
                    }

                    var target = getEventTarget(event);
                    if (target.window === target) {
                        // target is a window object
                        return target;
                    }

                    var doc = target.ownerDocument;
                    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
                    if (doc) {
                        return doc.defaultView || doc.parentWindow;
                    } else {
                        return window;
                    }
                },
                detail: function(event) {
                    return event.detail || 0;
                }
            };

            function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

            module.exports = SyntheticUIEvent;
        }, {
            "./SyntheticEvent": 115,
            "./getEventTarget": 138
        }],
        123: [function(_dereq_, module, exports) {

            var SyntheticMouseEvent = _dereq_('./SyntheticMouseEvent');

            var WheelEventInterface = {
                deltaX: function(event) {
                    return 'deltaX' in event ? event.deltaX :
                        // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                        'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
                },
                deltaY: function(event) {
                    return 'deltaY' in event ? event.deltaY :
                        // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                        'wheelDeltaY' in event ? -event.wheelDeltaY :
                        // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                        'wheelDelta' in event ? -event.wheelDelta : 0;
                },
                deltaZ: null,

                // Browsers without "deltaMode" is reporting in raw wheel delta where one
                // notch on the scroll is always +/- 120, roughly equivalent to pixels.
                // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
                // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
                deltaMode: null
            };

            function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
            }

            SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

            module.exports = SyntheticWheelEvent;
        }, {
            "./SyntheticMouseEvent": 119
        }],
        124: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                var OBSERVED_ERROR = {};

                var TransactionImpl = {

                    reinitializeTransaction: function() {
                        this.transactionWrappers = this.getTransactionWrappers();
                        if (this.wrapperInitData) {
                            this.wrapperInitData.length = 0;
                        } else {
                            this.wrapperInitData = [];
                        }
                        this._isInTransaction = false;
                    },

                    _isInTransaction: false,


                    getTransactionWrappers: null,

                    isInTransaction: function() {
                        return !!this._isInTransaction;
                    },


                    perform: function(method, scope, a, b, c, d, e, f) {
                        !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
                        var errorThrown;
                        var ret;
                        try {
                            this._isInTransaction = true;
                            // Catching errors makes debugging more difficult, so we start with
                            // errorThrown set to true before setting it to false after calling
                            // close -- if it's still set to true in the finally block, it means
                            // one of these calls threw.
                            errorThrown = true;
                            this.initializeAll(0);
                            ret = method.call(scope, a, b, c, d, e, f);
                            errorThrown = false;
                        } finally {
                            try {
                                if (errorThrown) {
                                    // If `method` throws, prefer to show that stack trace over any thrown
                                    // by invoking `closeAll`.
                                    try {
                                        this.closeAll(0);
                                    } catch (err) {}
                                } else {
                                    // Since `method` didn't throw, we don't want to silence the exception
                                    // here.
                                    this.closeAll(0);
                                }
                            } finally {
                                this._isInTransaction = false;
                            }
                        }
                        return ret;
                    },

                    initializeAll: function(startIndex) {
                        var transactionWrappers = this.transactionWrappers;
                        for (var i = startIndex; i < transactionWrappers.length; i++) {
                            var wrapper = transactionWrappers[i];
                            try {
                                // Catching errors makes debugging more difficult, so we start with the
                                // OBSERVED_ERROR state before overwriting it with the real return value
                                // of initialize -- if it's still set to OBSERVED_ERROR in the finally
                                // block, it means wrapper.initialize threw.
                                this.wrapperInitData[i] = OBSERVED_ERROR;
                                this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
                            } finally {
                                if (this.wrapperInitData[i] === OBSERVED_ERROR) {
                                    // The initializer for wrapper i threw an error; initialize the
                                    // remaining wrappers but silence any exceptions from them to ensure
                                    // that the first error is the one to bubble up.
                                    try {
                                        this.initializeAll(i + 1);
                                    } catch (err) {}
                                }
                            }
                        }
                    },


                    closeAll: function(startIndex) {
                        !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
                        var transactionWrappers = this.transactionWrappers;
                        for (var i = startIndex; i < transactionWrappers.length; i++) {
                            var wrapper = transactionWrappers[i];
                            var initData = this.wrapperInitData[i];
                            var errorThrown;
                            try {
                                // Catching errors makes debugging more difficult, so we start with
                                // errorThrown set to true before setting it to false after calling
                                // close -- if it's still set to true in the finally block, it means
                                // wrapper.close threw.
                                errorThrown = true;
                                if (initData !== OBSERVED_ERROR && wrapper.close) {
                                    wrapper.close.call(this, initData);
                                }
                                errorThrown = false;
                            } finally {
                                if (errorThrown) {
                                    // The closer for wrapper i threw an error; close the remaining
                                    // wrappers but silence any exceptions from them to ensure that the
                                    // first error is the one to bubble up.
                                    try {
                                        this.closeAll(i + 1);
                                    } catch (e) {}
                                }
                            }
                        }
                        this.wrapperInitData.length = 0;
                    }
                };

                module.exports = TransactionImpl;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        125: [function(_dereq_, module, exports) {

            var ViewportMetrics = {

                currentScrollLeft: 0,

                currentScrollTop: 0,

                refreshScrollValues: function(scrollPosition) {
                    ViewportMetrics.currentScrollLeft = scrollPosition.x;
                    ViewportMetrics.currentScrollTop = scrollPosition.y;
                }

            };

            module.exports = ViewportMetrics;
        }, {}],
        126: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var invariant = _dereq_('fbjs/lib/invariant');

                function accumulateInto(current, next) {
                    !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30'): void 0;

                    if (current == null) {
                        return next;
                    }

                    // Both are not empty. Warning: Never call x.concat(y) when you are not
                    // certain that x is an Array (x could be a string with concat method).
                    if (Array.isArray(current)) {
                        if (Array.isArray(next)) {
                            current.push.apply(current, next);
                            return current;
                        }
                        current.push(next);
                        return current;
                    }

                    if (Array.isArray(next)) {
                        // A bit too dangerous to mutate `next`.
                        return [current].concat(next);
                    }

                    return [current, next];
                }

                module.exports = accumulateInto;
            }).call(this, _dereq_('_process'))
        }, {
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        127: [function(_dereq_, module, exports) {

            var MOD = 65521;

            // adler32 is not cryptographically strong, and is only used to sanity check that
            // markup generated on the server matches the markup generated on the client.
            // This implementation (a modified version of the SheetJS version) has been optimized
            // for our use case, at the expense of conforming to the adler32 specification
            // for non-ascii inputs.
            function adler32(data) {
                var a = 1;
                var b = 0;
                var i = 0;
                var l = data.length;
                var m = l & ~0x3;
                while (i < m) {
                    var n = Math.min(i + 4096, m);
                    for (; i < n; i += 4) {
                        b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
                    }
                    a %= MOD;
                    b %= MOD;
                }
                for (; i < l; i++) {
                    b += a += data.charCodeAt(i);
                }
                a %= MOD;
                b %= MOD;
                return a | b << 16;
            }

            module.exports = adler32;
        }, {}],
        128: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactPropTypeLocationNames = _dereq_('./ReactPropTypeLocationNames');
                var ReactPropTypesSecret = _dereq_('./ReactPropTypesSecret');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                var ReactComponentTreeHook;

                if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
                    // Temporary hack.
                    // Inline requires don't work well with Jest:
                    // https://github.com/facebook/react/issues/7240
                    // Remove the inline requires when we don't need them anymore:
                    // https://github.com/facebook/react/pull/7178
                    ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');
                }

                var loggedTypeFailures = {};

                function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
                    for (var typeSpecName in typeSpecs) {
                        if (typeSpecs.hasOwnProperty(typeSpecName)) {
                            var error;
                            // Prop type validation may throw. In case they do, we don't want to
                            // fail the render phase where it didn't fail before. So we log it.
                            // After these have been cleaned up, we'll let them throw.
                            try {
                                // This is intentionally an invariant that gets caught. It's the same
                                // behavior as without this statement except with a better message.
                                !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName): void 0;
                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                            } catch (ex) {
                                error = ex;
                            }
                            process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                                // Only monitor this failure once because there tends to be a lot of the
                                // same error.
                                loggedTypeFailures[error.message] = true;

                                var componentStackInfo = '';

                                if (process.env.NODE_ENV !== 'production') {
                                    if (!ReactComponentTreeHook) {
                                        ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');
                                    }
                                    if (debugID !== null) {
                                        componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
                                    } else if (element !== null) {
                                        componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
                                    }
                                }

                                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
                            }
                        }
                    }
                }

                module.exports = checkReactTypeSpec;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactPropTypeLocationNames": 98,
            "./ReactPropTypesSecret": 99,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "react/lib/ReactComponentTreeHook": 162
        }],
        129: [function(_dereq_, module, exports) {

            var createMicrosoftUnsafeLocalFunction = function(func) {
                if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
                    return function(arg0, arg1, arg2, arg3) {
                        MSApp.execUnsafeLocalFunction(function() {
                            return func(arg0, arg1, arg2, arg3);
                        });
                    };
                } else {
                    return func;
                }
            };

            module.exports = createMicrosoftUnsafeLocalFunction;
        }, {}],
        130: [function(_dereq_, module, exports) {
            (function(process) {

                var CSSProperty = _dereq_('./CSSProperty');
                var warning = _dereq_('fbjs/lib/warning');

                var isUnitlessNumber = CSSProperty.isUnitlessNumber;
                var styleWarnings = {};

                function dangerousStyleValue(name, value, component) {
                    // Note that we've removed escapeTextForBrowser() calls here since the
                    // whole string will be escaped when the attribute is injected into
                    // the markup. If you provide unsafe user data here they can inject
                    // arbitrary CSS which may be problematic (I couldn't repro this):
                    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
                    // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
                    // This is not an XSS hole but instead a potential CSS injection issue
                    // which has lead to a greater discussion about how we're going to
                    // trust URLs moving forward. See #2115901

                    var isEmpty = value == null || typeof value === 'boolean' || value === '';
                    if (isEmpty) {
                        return '';
                    }

                    var isNonNumeric = isNaN(value);
                    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
                        return '' + value; // cast to string
                    }

                    if (typeof value === 'string') {
                        if (process.env.NODE_ENV !== 'production') {
                            // Allow '0' to pass through without warning. 0 is already special and
                            // doesn't require units, so we don't need to warn about it.
                            if (component && value !== '0') {
                                var owner = component._currentElement._owner;
                                var ownerName = owner ? owner.getName() : null;
                                if (ownerName && !styleWarnings[ownerName]) {
                                    styleWarnings[ownerName] = {};
                                }
                                var warned = false;
                                if (ownerName) {
                                    var warnings = styleWarnings[ownerName];
                                    warned = warnings[name];
                                    if (!warned) {
                                        warnings[name] = true;
                                    }
                                }
                                if (!warned) {
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
                                }
                            }
                        }
                        value = value.trim();
                    }
                    return value + 'px';
                }

                module.exports = dangerousStyleValue;
            }).call(this, _dereq_('_process'))
        }, {
            "./CSSProperty": 33,
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        131: [function(_dereq_, module, exports) {

            // code copied and modified from escape-html

            var matchHtmlRegExp = /["'&<>]/;

            function escapeHtml(string) {
                var str = '' + string;
                var match = matchHtmlRegExp.exec(str);

                if (!match) {
                    return str;
                }

                var escape;
                var html = '';
                var index = 0;
                var lastIndex = 0;

                for (index = match.index; index < str.length; index++) {
                    switch (str.charCodeAt(index)) {
                        case 34:
                            // "
                            escape = '&quot;';
                            break;
                        case 38:
                            // &
                            escape = '&amp;';
                            break;
                        case 39:
                            // '
                            escape = '&#x27;'; // modified from escape-html; used to be '&#39'
                            break;
                        case 60:
                            // <
                            escape = '&lt;';
                            break;
                        case 62:
                            // >
                            escape = '&gt;';
                            break;
                        default:
                            continue;
                    }

                    if (lastIndex !== index) {
                        html += str.substring(lastIndex, index);
                    }

                    lastIndex = index + 1;
                    html += escape;
                }

                return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
            }
            // end code copied and modified from escape-html

            function escapeTextContentForBrowser(text) {
                if (typeof text === 'boolean' || typeof text === 'number') {
                    // this shortcircuit helps perf for types that we know will never have
                    // special characters, especially given that this function is used often
                    // for numeric dom ids.
                    return '' + text;
                }
                return escapeHtml(text);
            }

            module.exports = escapeTextContentForBrowser;
        }, {}],
        132: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactCurrentOwner = _dereq_('react/lib/ReactCurrentOwner');
                var ReactDOMComponentTree = _dereq_('./ReactDOMComponentTree');
                var ReactInstanceMap = _dereq_('./ReactInstanceMap');

                var getHostComponentFromComposite = _dereq_('./getHostComponentFromComposite');
                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                function findDOMNode(componentOrElement) {
                    if (process.env.NODE_ENV !== 'production') {
                        var owner = ReactCurrentOwner.current;
                        if (owner !== null) {
                            process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
                            owner._warnedAboutRefsInRender = true;
                        }
                    }
                    if (componentOrElement == null) {
                        return null;
                    }
                    if (componentOrElement.nodeType === 1) {
                        return componentOrElement;
                    }

                    var inst = ReactInstanceMap.get(componentOrElement);
                    if (inst) {
                        inst = getHostComponentFromComposite(inst);
                        return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
                    }

                    if (typeof componentOrElement.render === 'function') {
                        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
                    } else {
                        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
                    }
                }

                module.exports = findDOMNode;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactDOMComponentTree": 62,
            "./ReactInstanceMap": 90,
            "./getHostComponentFromComposite": 139,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "react/lib/ReactCurrentOwner": 163
        }],
        133: [function(_dereq_, module, exports) {
            (function(process) {

                var KeyEscapeUtils = _dereq_('./KeyEscapeUtils');
                var traverseAllChildren = _dereq_('./traverseAllChildren');
                var warning = _dereq_('fbjs/lib/warning');

                var ReactComponentTreeHook;

                if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
                    // Temporary hack.
                    // Inline requires don't work well with Jest:
                    // https://github.com/facebook/react/issues/7240
                    // Remove the inline requires when we don't need them anymore:
                    // https://github.com/facebook/react/pull/7178
                    ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');
                }

                function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
                    // We found a component instance.
                    if (traverseContext && typeof traverseContext === 'object') {
                        var result = traverseContext;
                        var keyUnique = result[name] === undefined;
                        if (process.env.NODE_ENV !== 'production') {
                            if (!ReactComponentTreeHook) {
                                ReactComponentTreeHook = _dereq_('react/lib/ReactComponentTreeHook');
                            }
                            if (!keyUnique) {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
                            }
                        }
                        if (keyUnique && child != null) {
                            result[name] = child;
                        }
                    }
                }

                function flattenChildren(children, selfDebugID) {
                    if (children == null) {
                        return children;
                    }
                    var result = {};

                    if (process.env.NODE_ENV !== 'production') {
                        traverseAllChildren(children, function(traverseContext, child, name) {
                            return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
                        }, result);
                    } else {
                        traverseAllChildren(children, flattenSingleChildIntoContext, result);
                    }
                    return result;
                }

                module.exports = flattenChildren;
            }).call(this, _dereq_('_process'))
        }, {
            "./KeyEscapeUtils": 51,
            "./traverseAllChildren": 154,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "react/lib/ReactComponentTreeHook": 162
        }],
        134: [function(_dereq_, module, exports) {

            function forEachAccumulated(arr, cb, scope) {
                if (Array.isArray(arr)) {
                    arr.forEach(cb, scope);
                } else if (arr) {
                    cb.call(scope, arr);
                }
            }

            module.exports = forEachAccumulated;
        }, {}],
        135: [function(_dereq_, module, exports) {

            function getEventCharCode(nativeEvent) {
                var charCode;
                var keyCode = nativeEvent.keyCode;

                if ('charCode' in nativeEvent) {
                    charCode = nativeEvent.charCode;

                    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
                    if (charCode === 0 && keyCode === 13) {
                        charCode = 13;
                    }
                } else {
                    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
                    charCode = keyCode;
                }

                // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
                // Must not discard the (non-)printable Enter-key.
                if (charCode >= 32 || charCode === 13) {
                    return charCode;
                }

                return 0;
            }

            module.exports = getEventCharCode;
        }, {}],
        136: [function(_dereq_, module, exports) {

            var getEventCharCode = _dereq_('./getEventCharCode');

            var normalizeKey = {
                'Esc': 'Escape',
                'Spacebar': ' ',
                'Left': 'ArrowLeft',
                'Up': 'ArrowUp',
                'Right': 'ArrowRight',
                'Down': 'ArrowDown',
                'Del': 'Delete',
                'Win': 'OS',
                'Menu': 'ContextMenu',
                'Apps': 'ContextMenu',
                'Scroll': 'ScrollLock',
                'MozPrintableKey': 'Unidentified'
            };

            var translateToKey = {
                8: 'Backspace',
                9: 'Tab',
                12: 'Clear',
                13: 'Enter',
                16: 'Shift',
                17: 'Control',
                18: 'Alt',
                19: 'Pause',
                20: 'CapsLock',
                27: 'Escape',
                32: ' ',
                33: 'PageUp',
                34: 'PageDown',
                35: 'End',
                36: 'Home',
                37: 'ArrowLeft',
                38: 'ArrowUp',
                39: 'ArrowRight',
                40: 'ArrowDown',
                45: 'Insert',
                46: 'Delete',
                112: 'F1',
                113: 'F2',
                114: 'F3',
                115: 'F4',
                116: 'F5',
                117: 'F6',
                118: 'F7',
                119: 'F8',
                120: 'F9',
                121: 'F10',
                122: 'F11',
                123: 'F12',
                144: 'NumLock',
                145: 'ScrollLock',
                224: 'Meta'
            };

            function getEventKey(nativeEvent) {
                if (nativeEvent.key) {
                    // Normalize inconsistent values reported by browsers due to
                    // implementations of a working draft specification.

                    // FireFox implements `key` but returns `MozPrintableKey` for all
                    // printable characters (normalized to `Unidentified`), ignore it.
                    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                    if (key !== 'Unidentified') {
                        return key;
                    }
                }

                // Browser does not implement `key`, polyfill as much of it as we can.
                if (nativeEvent.type === 'keypress') {
                    var charCode = getEventCharCode(nativeEvent);

                    // The enter-key is technically both printable and non-printable and can
                    // thus be captured by `keypress`, no other non-printable key should.
                    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
                }
                if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
                    // While user keyboard layout determines the actual meaning of each
                    // `keyCode` value, almost all function keys have a universal value.
                    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
                }
                return '';
            }

            module.exports = getEventKey;
        }, {
            "./getEventCharCode": 135
        }],
        137: [function(_dereq_, module, exports) {

            var modifierKeyToProp = {
                'Alt': 'altKey',
                'Control': 'ctrlKey',
                'Meta': 'metaKey',
                'Shift': 'shiftKey'
            };

            // IE8 does not implement getModifierState so we simply map it to the only
            // modifier keys exposed by the event itself, does not support Lock-keys.
            // Currently, all major browsers except Chrome seems to support Lock-keys.
            function modifierStateGetter(keyArg) {
                var syntheticEvent = this;
                var nativeEvent = syntheticEvent.nativeEvent;
                if (nativeEvent.getModifierState) {
                    return nativeEvent.getModifierState(keyArg);
                }
                var keyProp = modifierKeyToProp[keyArg];
                return keyProp ? !!nativeEvent[keyProp] : false;
            }

            function getEventModifierState(nativeEvent) {
                return modifierStateGetter;
            }

            module.exports = getEventModifierState;
        }, {}],
        138: [function(_dereq_, module, exports) {

            function getEventTarget(nativeEvent) {
                var target = nativeEvent.target || nativeEvent.srcElement || window;

                // Normalize SVG <use> element events #4963
                if (target.correspondingUseElement) {
                    target = target.correspondingUseElement;
                }

                // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
                // @see http://www.quirksmode.org/js/events_properties.html
                return target.nodeType === 3 ? target.parentNode : target;
            }

            module.exports = getEventTarget;
        }, {}],
        139: [function(_dereq_, module, exports) {

            var ReactNodeTypes = _dereq_('./ReactNodeTypes');

            function getHostComponentFromComposite(inst) {
                var type;

                while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
                    inst = inst._renderedComponent;
                }

                if (type === ReactNodeTypes.HOST) {
                    return inst._renderedComponent;
                } else if (type === ReactNodeTypes.EMPTY) {
                    return null;
                }
            }

            module.exports = getHostComponentFromComposite;
        }, {
            "./ReactNodeTypes": 96
        }],
        140: [function(_dereq_, module, exports) {

            var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

            function getIteratorFn(maybeIterable) {
                var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
                if (typeof iteratorFn === 'function') {
                    return iteratorFn;
                }
            }

            module.exports = getIteratorFn;
        }, {}],
        141: [function(_dereq_, module, exports) {

            var nextDebugID = 1;

            function getNextDebugID() {
                return nextDebugID++;
            }

            module.exports = getNextDebugID;
        }, {}],
        142: [function(_dereq_, module, exports) {

            function getLeafNode(node) {
                while (node && node.firstChild) {
                    node = node.firstChild;
                }
                return node;
            }

            function getSiblingNode(node) {
                while (node) {
                    if (node.nextSibling) {
                        return node.nextSibling;
                    }
                    node = node.parentNode;
                }
            }

            function getNodeForCharacterOffset(root, offset) {
                var node = getLeafNode(root);
                var nodeStart = 0;
                var nodeEnd = 0;

                while (node) {
                    if (node.nodeType === 3) {
                        nodeEnd = nodeStart + node.textContent.length;

                        if (nodeStart <= offset && nodeEnd >= offset) {
                            return {
                                node: node,
                                offset: offset - nodeStart
                            };
                        }

                        nodeStart = nodeEnd;
                    }

                    node = getLeafNode(getSiblingNode(node));
                }
            }

            module.exports = getNodeForCharacterOffset;
        }, {}],
        143: [function(_dereq_, module, exports) {

            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');

            var contentKey = null;

            function getTextContentAccessor() {
                if (!contentKey && ExecutionEnvironment.canUseDOM) {
                    // Prefer textContent to innerText because many browsers support both but
                    // SVG <text> elements don't support innerText even when <div> does.
                    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
                }
                return contentKey;
            }

            module.exports = getTextContentAccessor;
        }, {
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        144: [function(_dereq_, module, exports) {

            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');

            function makePrefixMap(styleProp, eventName) {
                var prefixes = {};

                prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
                prefixes['Webkit' + styleProp] = 'webkit' + eventName;
                prefixes['Moz' + styleProp] = 'moz' + eventName;
                prefixes['ms' + styleProp] = 'MS' + eventName;
                prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

                return prefixes;
            }

            var vendorPrefixes = {
                animationend: makePrefixMap('Animation', 'AnimationEnd'),
                animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
                animationstart: makePrefixMap('Animation', 'AnimationStart'),
                transitionend: makePrefixMap('Transition', 'TransitionEnd')
            };

            var prefixedEventNames = {};

            var style = {};

            if (ExecutionEnvironment.canUseDOM) {
                style = document.createElement('div').style;

                // On some platforms, in particular some releases of Android 4.x,
                // the un-prefixed "animation" and "transition" properties are defined on the
                // style object but the events that fire will still be prefixed, so we need
                // to check if the un-prefixed events are usable, and if not remove them from the map.
                if (!('AnimationEvent' in window)) {
                    delete vendorPrefixes.animationend.animation;
                    delete vendorPrefixes.animationiteration.animation;
                    delete vendorPrefixes.animationstart.animation;
                }

                // Same as above
                if (!('TransitionEvent' in window)) {
                    delete vendorPrefixes.transitionend.transition;
                }
            }

            function getVendorPrefixedEventName(eventName) {
                if (prefixedEventNames[eventName]) {
                    return prefixedEventNames[eventName];
                } else if (!vendorPrefixes[eventName]) {
                    return eventName;
                }

                var prefixMap = vendorPrefixes[eventName];

                for (var styleProp in prefixMap) {
                    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                        return prefixedEventNames[eventName] = prefixMap[styleProp];
                    }
                }

                return '';
            }

            module.exports = getVendorPrefixedEventName;
        }, {
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        145: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var ReactCompositeComponent = _dereq_('./ReactCompositeComponent');
                var ReactEmptyComponent = _dereq_('./ReactEmptyComponent');
                var ReactHostComponent = _dereq_('./ReactHostComponent');

                var getNextDebugID = _dereq_('./getNextDebugID');
                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                // To avoid a cyclic dependency, we create the final class in this module
                var ReactCompositeComponentWrapper = function(element) {
                    this.construct(element);
                };
                _assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
                    _instantiateReactComponent: instantiateReactComponent
                });

                function getDeclarationErrorAddendum(owner) {
                    if (owner) {
                        var name = owner.getName();
                        if (name) {
                            return ' Check the render method of `' + name + '`.';
                        }
                    }
                    return '';
                }

                function isInternalComponentType(type) {
                    return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
                }

                function instantiateReactComponent(node, shouldHaveDebugID) {
                    var instance;

                    if (node === null || node === false) {
                        instance = ReactEmptyComponent.create(instantiateReactComponent);
                    } else if (typeof node === 'object') {
                        var element = node;
                        !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)): void 0;

                        // Special case string values
                        if (typeof element.type === 'string') {
                            instance = ReactHostComponent.createInternalComponent(element);
                        } else if (isInternalComponentType(element.type)) {
                            // This is temporarily available for custom components that are not string
                            // representations. I.e. ART. Once those are updated to use the string
                            // representation, we can drop this code path.
                            instance = new element.type(element);

                            // We renamed this. Allow the old name for compat. :(
                            if (!instance.getHostNode) {
                                instance.getHostNode = instance.getNativeNode;
                            }
                        } else {
                            instance = new ReactCompositeComponentWrapper(element);
                        }
                    } else if (typeof node === 'string' || typeof node === 'number') {
                        instance = ReactHostComponent.createInstanceForText(node);
                    } else {
                        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
                    }

                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
                    }

                    // These two fields are used by the DOM and ART diffing algorithms
                    // respectively. Instead of using expandos on components, we should be
                    // storing the state needed by the diffing algorithms elsewhere.
                    instance._mountIndex = 0;
                    instance._mountImage = null;

                    if (process.env.NODE_ENV !== 'production') {
                        instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
                    }

                    // Internal instances should fully constructed at this point, so they should
                    // not get any new fields added to them at this point.
                    if (process.env.NODE_ENV !== 'production') {
                        if (Object.preventExtensions) {
                            Object.preventExtensions(instance);
                        }
                    }

                    return instance;
                }

                module.exports = instantiateReactComponent;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactCompositeComponent": 58,
            "./ReactEmptyComponent": 81,
            "./ReactHostComponent": 86,
            "./getNextDebugID": 141,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        146: [function(_dereq_, module, exports) {

            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');

            var useHasFeature;
            if (ExecutionEnvironment.canUseDOM) {
                useHasFeature = document.implementation && document.implementation.hasFeature &&
                    // always returns true in newer browsers as per the standard.
                    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
                    document.implementation.hasFeature('', '') !== true;
            }

            function isEventSupported(eventNameSuffix, capture) {
                if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
                    return false;
                }

                var eventName = 'on' + eventNameSuffix;
                var isSupported = eventName in document;

                if (!isSupported) {
                    var element = document.createElement('div');
                    element.setAttribute(eventName, 'return;');
                    isSupported = typeof element[eventName] === 'function';
                }

                if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
                    // This is the only way to test support for the `wheel` event in IE9+.
                    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
                }

                return isSupported;
            }

            module.exports = isEventSupported;
        }, {
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        147: [function(_dereq_, module, exports) {

            var supportedInputTypes = {
                'color': true,
                'date': true,
                'datetime': true,
                'datetime-local': true,
                'email': true,
                'month': true,
                'number': true,
                'password': true,
                'range': true,
                'search': true,
                'tel': true,
                'text': true,
                'time': true,
                'url': true,
                'week': true
            };

            function isTextInputElement(elem) {
                var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

                if (nodeName === 'input') {
                    return !!supportedInputTypes[elem.type];
                }

                if (nodeName === 'textarea') {
                    return true;
                }

                return false;
            }

            module.exports = isTextInputElement;
        }, {}],
        148: [function(_dereq_, module, exports) {

            var escapeTextContentForBrowser = _dereq_('./escapeTextContentForBrowser');

            function quoteAttributeValueForBrowser(value) {
                return '"' + escapeTextContentForBrowser(value) + '"';
            }

            module.exports = quoteAttributeValueForBrowser;
        }, {
            "./escapeTextContentForBrowser": 131
        }],
        149: [function(_dereq_, module, exports) {

            function reactProdInvariant(code) {
                var argCount = arguments.length - 1;

                var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

                for (var argIdx = 0; argIdx < argCount; argIdx++) {
                    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
                }

                message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

                var error = new Error(message);
                error.name = 'Invariant Violation';
                error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

                throw error;
            }

            module.exports = reactProdInvariant;
        }, {}],
        150: [function(_dereq_, module, exports) {

            var ReactMount = _dereq_('./ReactMount');

            module.exports = ReactMount.renderSubtreeIntoContainer;
        }, {
            "./ReactMount": 94
        }],
        151: [function(_dereq_, module, exports) {

            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
            var DOMNamespaces = _dereq_('./DOMNamespaces');

            var WHITESPACE_TEST = /^[ \r\n\t\f]/;
            var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

            var createMicrosoftUnsafeLocalFunction = _dereq_('./createMicrosoftUnsafeLocalFunction');

            // SVG temp container for IE lacking innerHTML
            var reusableSVGContainer;

            var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
                // IE does not have innerHTML for SVG nodes, so instead we inject the
                // new markup in a temp node and then move the child nodes across into
                // the target node
                if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
                    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
                    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
                    var svgNode = reusableSVGContainer.firstChild;
                    while (svgNode.firstChild) {
                        node.appendChild(svgNode.firstChild);
                    }
                } else {
                    node.innerHTML = html;
                }
            });

            if (ExecutionEnvironment.canUseDOM) {
                // IE8: When updating a just created node with innerHTML only leading
                // whitespace is removed. When updating an existing node with innerHTML
                // whitespace in root TextNodes is also collapsed.
                // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

                // Feature detection; only IE8 is known to behave improperly like this.
                var testElement = document.createElement('div');
                testElement.innerHTML = ' ';
                if (testElement.innerHTML === '') {
                    setInnerHTML = function(node, html) {
                        // Magic theory: IE8 supposedly differentiates between added and updated
                        // nodes when processing innerHTML, innerHTML on updated nodes suffers
                        // from worse whitespace behavior. Re-adding a node like this triggers
                        // the initial and more favorable whitespace behavior.
                        // TODO: What to do on a detached node?
                        if (node.parentNode) {
                            node.parentNode.replaceChild(node, node);
                        }

                        // We also implement a workaround for non-visible tags disappearing into
                        // thin air on IE8, this only happens if there is no visible text
                        // in-front of the non-visible tags. Piggyback on the whitespace fix
                        // and simply check if any non-visible tags appear in the source.
                        if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
                            // Recover leading whitespace by temporarily prepending any character.
                            // \uFEFF has the potential advantage of being zero-width/invisible.
                            // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
                            // in hopes that this is preserved even if "\uFEFF" is transformed to
                            // the actual Unicode character (by Babel, for example).
                            // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
                            node.innerHTML = String.fromCharCode(0xFEFF) + html;

                            // deleteData leaves an empty `TextNode` which offsets the index of all
                            // children. Definitely want to avoid this.
                            var textNode = node.firstChild;
                            if (textNode.data.length === 1) {
                                node.removeChild(textNode);
                            } else {
                                textNode.deleteData(0, 1);
                            }
                        } else {
                            node.innerHTML = html;
                        }
                    };
                }
                testElement = null;
            }

            module.exports = setInnerHTML;
        }, {
            "./DOMNamespaces": 39,
            "./createMicrosoftUnsafeLocalFunction": 129,
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        152: [function(_dereq_, module, exports) {

            var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
            var escapeTextContentForBrowser = _dereq_('./escapeTextContentForBrowser');
            var setInnerHTML = _dereq_('./setInnerHTML');

            var setTextContent = function(node, text) {
                if (text) {
                    var firstChild = node.firstChild;

                    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
                        firstChild.nodeValue = text;
                        return;
                    }
                }
                node.textContent = text;
            };

            if (ExecutionEnvironment.canUseDOM) {
                if (!('textContent' in document.documentElement)) {
                    setTextContent = function(node, text) {
                        if (node.nodeType === 3) {
                            node.nodeValue = text;
                            return;
                        }
                        setInnerHTML(node, escapeTextContentForBrowser(text));
                    };
                }
            }

            module.exports = setTextContent;
        }, {
            "./escapeTextContentForBrowser": 131,
            "./setInnerHTML": 151,
            "fbjs/lib/ExecutionEnvironment": 3
        }],
        153: [function(_dereq_, module, exports) {

            function shouldUpdateReactComponent(prevElement, nextElement) {
                var prevEmpty = prevElement === null || prevElement === false;
                var nextEmpty = nextElement === null || nextElement === false;
                if (prevEmpty || nextEmpty) {
                    return prevEmpty === nextEmpty;
                }

                var prevType = typeof prevElement;
                var nextType = typeof nextElement;
                if (prevType === 'string' || prevType === 'number') {
                    return nextType === 'string' || nextType === 'number';
                } else {
                    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
                }
            }

            module.exports = shouldUpdateReactComponent;
        }, {}],
        154: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactCurrentOwner = _dereq_('react/lib/ReactCurrentOwner');
                var REACT_ELEMENT_TYPE = _dereq_('./ReactElementSymbol');

                var getIteratorFn = _dereq_('./getIteratorFn');
                var invariant = _dereq_('fbjs/lib/invariant');
                var KeyEscapeUtils = _dereq_('./KeyEscapeUtils');
                var warning = _dereq_('fbjs/lib/warning');

                var SEPARATOR = '.';
                var SUBSEPARATOR = ':';

                var didWarnAboutMaps = false;

                function getComponentKey(component, index) {
                    // Do some typechecking here since we call this blindly. We want to ensure
                    // that we don't block potential future ES APIs.
                    if (component && typeof component === 'object' && component.key != null) {
                        // Explicit key
                        return KeyEscapeUtils.escape(component.key);
                    }
                    // Implicit key determined by the index in the set
                    return index.toString(36);
                }

                function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
                    var type = typeof children;

                    if (type === 'undefined' || type === 'boolean') {
                        // All of the above are perceived as null.
                        children = null;
                    }

                    if (children === null || type === 'string' || type === 'number' ||
                        // The following is inlined from ReactElement. This means we can optimize
                        // some checks. React Fiber also inlines this logic for similar purposes.
                        type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
                        callback(traverseContext, children,
                            // If it's the only child, treat the name as if it was wrapped in an array
                            // so that it's consistent if the number of children grows.
                            nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
                        return 1;
                    }

                    var child;
                    var nextName;
                    var subtreeCount = 0; // Count of children found in the current subtree.
                    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

                    if (Array.isArray(children)) {
                        for (var i = 0; i < children.length; i++) {
                            child = children[i];
                            nextName = nextNamePrefix + getComponentKey(child, i);
                            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                        }
                    } else {
                        var iteratorFn = getIteratorFn(children);
                        if (iteratorFn) {
                            var iterator = iteratorFn.call(children);
                            var step;
                            if (iteratorFn !== children.entries) {
                                var ii = 0;
                                while (!(step = iterator.next()).done) {
                                    child = step.value;
                                    nextName = nextNamePrefix + getComponentKey(child, ii++);
                                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                                }
                            } else {
                                if (process.env.NODE_ENV !== 'production') {
                                    var mapsAsChildrenAddendum = '';
                                    if (ReactCurrentOwner.current) {
                                        var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                                        if (mapsAsChildrenOwnerName) {
                                            mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                                        }
                                    }
                                    process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
                                    didWarnAboutMaps = true;
                                }
                                // Iterator will provide entry [k,v] tuples rather than values.
                                while (!(step = iterator.next()).done) {
                                    var entry = step.value;
                                    if (entry) {
                                        child = entry[1];
                                        nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                                        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                                    }
                                }
                            }
                        } else if (type === 'object') {
                            var addendum = '';
                            if (process.env.NODE_ENV !== 'production') {
                                addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
                                if (children._isReactElement) {
                                    addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
                                }
                                if (ReactCurrentOwner.current) {
                                    var name = ReactCurrentOwner.current.getName();
                                    if (name) {
                                        addendum += ' Check the render method of `' + name + '`.';
                                    }
                                }
                            }
                            var childrenString = String(children);
                            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
                        }
                    }

                    return subtreeCount;
                }

                function traverseAllChildren(children, callback, traverseContext) {
                    if (children == null) {
                        return 0;
                    }

                    return traverseAllChildrenImpl(children, '', callback, traverseContext);
                }

                module.exports = traverseAllChildren;
            }).call(this, _dereq_('_process'))
        }, {
            "./KeyEscapeUtils": 51,
            "./ReactElementSymbol": 80,
            "./getIteratorFn": 140,
            "./reactProdInvariant": 149,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "react/lib/ReactCurrentOwner": 163
        }],
        155: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
                var warning = _dereq_('fbjs/lib/warning');

                var validateDOMNesting = emptyFunction;

                if (process.env.NODE_ENV !== 'production') {
                    // This validation code was written based on the HTML5 parsing spec:
                    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
                    //
                    // Note: this does not catch all invalid nesting, nor does it try to (as it's
                    // not clear what practical benefit doing so provides); instead, we warn only
                    // for cases where the parser will give a parse tree differing from what React
                    // intended. For example, <b><div></div></b> is invalid but we don't warn
                    // because it still parses correctly; we do warn for other cases like nested
                    // <p> tags where the beginning of the second element implicitly closes the
                    // first, causing a confusing mess.

                    // https://html.spec.whatwg.org/multipage/syntax.html#special
                    var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

                    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
                    var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

                        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
                        // TODO: Distinguish by namespace here -- for <title>, including it here
                        // errs on the side of fewer warnings
                        'foreignObject', 'desc', 'title'
                    ];

                    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
                    var buttonScopeTags = inScopeTags.concat(['button']);

                    // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
                    var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

                    var emptyAncestorInfo = {
                        current: null,

                        formTag: null,
                        aTagInScope: null,
                        buttonTagInScope: null,
                        nobrTagInScope: null,
                        pTagInButtonScope: null,

                        listItemTagAutoclosing: null,
                        dlItemTagAutoclosing: null
                    };

                    var updatedAncestorInfo = function(oldInfo, tag, instance) {
                        var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
                        var info = {
                            tag: tag,
                            instance: instance
                        };

                        if (inScopeTags.indexOf(tag) !== -1) {
                            ancestorInfo.aTagInScope = null;
                            ancestorInfo.buttonTagInScope = null;
                            ancestorInfo.nobrTagInScope = null;
                        }
                        if (buttonScopeTags.indexOf(tag) !== -1) {
                            ancestorInfo.pTagInButtonScope = null;
                        }

                        // See rules for 'li', 'dd', 'dt' start tags in
                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
                        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
                            ancestorInfo.listItemTagAutoclosing = null;
                            ancestorInfo.dlItemTagAutoclosing = null;
                        }

                        ancestorInfo.current = info;

                        if (tag === 'form') {
                            ancestorInfo.formTag = info;
                        }
                        if (tag === 'a') {
                            ancestorInfo.aTagInScope = info;
                        }
                        if (tag === 'button') {
                            ancestorInfo.buttonTagInScope = info;
                        }
                        if (tag === 'nobr') {
                            ancestorInfo.nobrTagInScope = info;
                        }
                        if (tag === 'p') {
                            ancestorInfo.pTagInButtonScope = info;
                        }
                        if (tag === 'li') {
                            ancestorInfo.listItemTagAutoclosing = info;
                        }
                        if (tag === 'dd' || tag === 'dt') {
                            ancestorInfo.dlItemTagAutoclosing = info;
                        }

                        return ancestorInfo;
                    };


                    var isTagValidWithParent = function(tag, parentTag) {
                        // First, let's check if we're in an unusual parsing mode...
                        switch (parentTag) {
                            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
                            case 'select':
                                return tag === 'option' || tag === 'optgroup' || tag === '#text';
                            case 'optgroup':
                                return tag === 'option' || tag === '#text';
                                // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
                                // but
                            case 'option':
                                return tag === '#text';

                                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
                                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
                                // No special behavior since these rules fall back to "in body" mode for
                                // all except special table nodes which cause bad parsing behavior anyway.

                                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
                            case 'tr':
                                return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

                                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
                            case 'tbody':
                            case 'thead':
                            case 'tfoot':
                                return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

                                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
                            case 'colgroup':
                                return tag === 'col' || tag === 'template';

                                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
                            case 'table':
                                return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

                                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
                            case 'head':
                                return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

                                // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
                            case 'html':
                                return tag === 'head' || tag === 'body';
                            case '#document':
                                return tag === 'html';
                        }

                        // Probably in the "in body" parsing mode, so we outlaw only tag combos
                        // where the parsing rules cause implicit opens or closes to be added.
                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
                        switch (tag) {
                            case 'h1':
                            case 'h2':
                            case 'h3':
                            case 'h4':
                            case 'h5':
                            case 'h6':
                                return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

                            case 'rp':
                            case 'rt':
                                return impliedEndTags.indexOf(parentTag) === -1;

                            case 'body':
                            case 'caption':
                            case 'col':
                            case 'colgroup':
                            case 'frame':
                            case 'head':
                            case 'html':
                            case 'tbody':
                            case 'td':
                            case 'tfoot':
                            case 'th':
                            case 'thead':
                            case 'tr':
                                // These tags are only valid with a few parents that have special child
                                // parsing rules -- if we're down here, then none of those matched and
                                // so we allow it only if we don't know what the parent is, as all other
                                // cases are invalid.
                                return parentTag == null;
                        }

                        return true;
                    };


                    var findInvalidAncestorForTag = function(tag, ancestorInfo) {
                        switch (tag) {
                            case 'address':
                            case 'article':
                            case 'aside':
                            case 'blockquote':
                            case 'center':
                            case 'details':
                            case 'dialog':
                            case 'dir':
                            case 'div':
                            case 'dl':
                            case 'fieldset':
                            case 'figcaption':
                            case 'figure':
                            case 'footer':
                            case 'header':
                            case 'hgroup':
                            case 'main':
                            case 'menu':
                            case 'nav':
                            case 'ol':
                            case 'p':
                            case 'section':
                            case 'summary':
                            case 'ul':

                            case 'pre':
                            case 'listing':

                            case 'table':

                            case 'hr':

                            case 'xmp':

                            case 'h1':
                            case 'h2':
                            case 'h3':
                            case 'h4':
                            case 'h5':
                            case 'h6':
                                return ancestorInfo.pTagInButtonScope;

                            case 'form':
                                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

                            case 'li':
                                return ancestorInfo.listItemTagAutoclosing;

                            case 'dd':
                            case 'dt':
                                return ancestorInfo.dlItemTagAutoclosing;

                            case 'button':
                                return ancestorInfo.buttonTagInScope;

                            case 'a':
                                // Spec says something about storing a list of markers, but it sounds
                                // equivalent to this check.
                                return ancestorInfo.aTagInScope;

                            case 'nobr':
                                return ancestorInfo.nobrTagInScope;
                        }

                        return null;
                    };


                    var findOwnerStack = function(instance) {
                        if (!instance) {
                            return [];
                        }

                        var stack = [];
                        do {
                            stack.push(instance);
                        } while (instance = instance._currentElement._owner);
                        stack.reverse();
                        return stack;
                    };

                    var didWarn = {};

                    validateDOMNesting = function(childTag, childText, childInstance, ancestorInfo) {
                        ancestorInfo = ancestorInfo || emptyAncestorInfo;
                        var parentInfo = ancestorInfo.current;
                        var parentTag = parentInfo && parentInfo.tag;

                        if (childText != null) {
                            process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
                            childTag = '#text';
                        }

                        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
                        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
                        var problematic = invalidParent || invalidAncestor;

                        if (problematic) {
                            var ancestorTag = problematic.tag;
                            var ancestorInstance = problematic.instance;

                            var childOwner = childInstance && childInstance._currentElement._owner;
                            var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

                            var childOwners = findOwnerStack(childOwner);
                            var ancestorOwners = findOwnerStack(ancestorOwner);

                            var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
                            var i;

                            var deepestCommon = -1;
                            for (i = 0; i < minStackLen; i++) {
                                if (childOwners[i] === ancestorOwners[i]) {
                                    deepestCommon = i;
                                } else {
                                    break;
                                }
                            }

                            var UNKNOWN = '(unknown)';
                            var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function(inst) {
                                return inst.getName() || UNKNOWN;
                            });
                            var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function(inst) {
                                return inst.getName() || UNKNOWN;
                            });
                            var ownerInfo = [].concat(
                                // If the parent and child instances have a common owner ancestor, start
                                // with that -- otherwise we just start with the parent's owners.
                                deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
                                // If we're warning about an invalid (non-parent) ancestry, add '...'
                                invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

                            var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
                            if (didWarn[warnKey]) {
                                return;
                            }
                            didWarn[warnKey] = true;

                            var tagDisplayName = childTag;
                            var whitespaceInfo = '';
                            if (childTag === '#text') {
                                if (/\S/.test(childText)) {
                                    tagDisplayName = 'Text nodes';
                                } else {
                                    tagDisplayName = 'Whitespace text nodes';
                                    whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
                                }
                            } else {
                                tagDisplayName = '<' + childTag + '>';
                            }

                            if (invalidParent) {
                                var info = '';
                                if (ancestorTag === 'table' && childTag === 'tr') {
                                    info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
                                }
                                process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
                            } else {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
                            }
                        }
                    };

                    validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

                    // For testing
                    validateDOMNesting.isTagValidInContext = function(tag, ancestorInfo) {
                        ancestorInfo = ancestorInfo || emptyAncestorInfo;
                        var parentInfo = ancestorInfo.current;
                        var parentTag = parentInfo && parentInfo.tag;
                        return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
                    };
                }

                module.exports = validateDOMNesting;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28,
            "fbjs/lib/emptyFunction": 9,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        156: [function(_dereq_, module, exports) {
            arguments[4][51][0].apply(exports, arguments)
        }, {
            "dup": 51
        }],
        157: [function(_dereq_, module, exports) {
            arguments[4][53][0].apply(exports, arguments)
        }, {
            "./reactProdInvariant": 178,
            "_process": 28,
            "dup": 53,
            "fbjs/lib/invariant": 17
        }],
        158: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var ReactChildren = _dereq_('./ReactChildren');
                var ReactComponent = _dereq_('./ReactComponent');
                var ReactPureComponent = _dereq_('./ReactPureComponent');
                var ReactClass = _dereq_('./ReactClass');
                var ReactDOMFactories = _dereq_('./ReactDOMFactories');
                var ReactElement = _dereq_('./ReactElement');
                var ReactPropTypes = _dereq_('./ReactPropTypes');
                var ReactVersion = _dereq_('./ReactVersion');

                var onlyChild = _dereq_('./onlyChild');
                var warning = _dereq_('fbjs/lib/warning');

                var createElement = ReactElement.createElement;
                var createFactory = ReactElement.createFactory;
                var cloneElement = ReactElement.cloneElement;

                if (process.env.NODE_ENV !== 'production') {
                    var ReactElementValidator = _dereq_('./ReactElementValidator');
                    createElement = ReactElementValidator.createElement;
                    createFactory = ReactElementValidator.createFactory;
                    cloneElement = ReactElementValidator.cloneElement;
                }

                var __spread = _assign;

                if (process.env.NODE_ENV !== 'production') {
                    var warned = false;
                    __spread = function() {
                        process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
                        warned = true;
                        return _assign.apply(null, arguments);
                    };
                }

                var React = {

                    // Modern

                    Children: {
                        map: ReactChildren.map,
                        forEach: ReactChildren.forEach,
                        count: ReactChildren.count,
                        toArray: ReactChildren.toArray,
                        only: onlyChild
                    },

                    Component: ReactComponent,
                    PureComponent: ReactPureComponent,

                    createElement: createElement,
                    cloneElement: cloneElement,
                    isValidElement: ReactElement.isValidElement,

                    // Classic

                    PropTypes: ReactPropTypes,
                    createClass: ReactClass.createClass,
                    createFactory: createFactory,
                    createMixin: function(mixin) {
                        // Currently a noop. Will be used to validate and trace mixins.
                        return mixin;
                    },

                    // This looks DOM specific but these are actually isomorphic helpers
                    // since they are just generating DOM strings.
                    DOM: ReactDOMFactories,

                    version: ReactVersion,

                    // Deprecated hook for JSX spread, don't use this for anything.
                    __spread: __spread
                };

                module.exports = React;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactChildren": 159,
            "./ReactClass": 160,
            "./ReactComponent": 161,
            "./ReactDOMFactories": 164,
            "./ReactElement": 165,
            "./ReactElementValidator": 167,
            "./ReactPropTypes": 170,
            "./ReactPureComponent": 172,
            "./ReactVersion": 173,
            "./onlyChild": 177,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        159: [function(_dereq_, module, exports) {

            var PooledClass = _dereq_('./PooledClass');
            var ReactElement = _dereq_('./ReactElement');

            var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
            var traverseAllChildren = _dereq_('./traverseAllChildren');

            var twoArgumentPooler = PooledClass.twoArgumentPooler;
            var fourArgumentPooler = PooledClass.fourArgumentPooler;

            var userProvidedKeyEscapeRegex = /\/+/g;

            function escapeUserProvidedKey(text) {
                return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
            }

            function ForEachBookKeeping(forEachFunction, forEachContext) {
                this.func = forEachFunction;
                this.context = forEachContext;
                this.count = 0;
            }
            ForEachBookKeeping.prototype.destructor = function() {
                this.func = null;
                this.context = null;
                this.count = 0;
            };
            PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

            function forEachSingleChild(bookKeeping, child, name) {
                var func = bookKeeping.func,
                    context = bookKeeping.context;

                func.call(context, child, bookKeeping.count++);
            }

            function forEachChildren(children, forEachFunc, forEachContext) {
                if (children == null) {
                    return children;
                }
                var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
                traverseAllChildren(children, forEachSingleChild, traverseContext);
                ForEachBookKeeping.release(traverseContext);
            }

            function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
                this.result = mapResult;
                this.keyPrefix = keyPrefix;
                this.func = mapFunction;
                this.context = mapContext;
                this.count = 0;
            }
            MapBookKeeping.prototype.destructor = function() {
                this.result = null;
                this.keyPrefix = null;
                this.func = null;
                this.context = null;
                this.count = 0;
            };
            PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

            function mapSingleChildIntoContext(bookKeeping, child, childKey) {
                var result = bookKeeping.result,
                    keyPrefix = bookKeeping.keyPrefix,
                    func = bookKeeping.func,
                    context = bookKeeping.context;

                var mappedChild = func.call(context, child, bookKeeping.count++);
                if (Array.isArray(mappedChild)) {
                    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
                } else if (mappedChild != null) {
                    if (ReactElement.isValidElement(mappedChild)) {
                        mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
                            // Keep both the (mapped) and old keys if they differ, just as
                            // traverseAllChildren used to do for objects as children
                            keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
                    }
                    result.push(mappedChild);
                }
            }

            function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
                var escapedPrefix = '';
                if (prefix != null) {
                    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
                }
                var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
                traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
                MapBookKeeping.release(traverseContext);
            }

            function mapChildren(children, func, context) {
                if (children == null) {
                    return children;
                }
                var result = [];
                mapIntoWithKeyPrefixInternal(children, result, null, func, context);
                return result;
            }

            function forEachSingleChildDummy(traverseContext, child, name) {
                return null;
            }

            function countChildren(children, context) {
                return traverseAllChildren(children, forEachSingleChildDummy, null);
            }

            function toArray(children) {
                var result = [];
                mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
                return result;
            }

            var ReactChildren = {
                forEach: forEachChildren,
                map: mapChildren,
                mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
                count: countChildren,
                toArray: toArray
            };

            module.exports = ReactChildren;
        }, {
            "./PooledClass": 157,
            "./ReactElement": 165,
            "./traverseAllChildren": 179,
            "fbjs/lib/emptyFunction": 9
        }],
        160: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant'),
                    _assign = _dereq_('object-assign');

                var ReactComponent = _dereq_('./ReactComponent');
                var ReactElement = _dereq_('./ReactElement');
                var ReactPropTypeLocationNames = _dereq_('./ReactPropTypeLocationNames');
                var ReactNoopUpdateQueue = _dereq_('./ReactNoopUpdateQueue');

                var emptyObject = _dereq_('fbjs/lib/emptyObject');
                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                var MIXINS_KEY = 'mixins';

                // Helper function to allow the creation of anonymous functions which do not
                // have .name set to the name of the variable being assigned to.
                function identity(fn) {
                    return fn;
                }

                var injectedMixins = [];

                var ReactClassInterface = {


                    mixins: 'DEFINE_MANY',


                    statics: 'DEFINE_MANY',


                    propTypes: 'DEFINE_MANY',


                    contextTypes: 'DEFINE_MANY',


                    childContextTypes: 'DEFINE_MANY',

                    // ==== Definition methods ====


                    getDefaultProps: 'DEFINE_MANY_MERGED',


                    getInitialState: 'DEFINE_MANY_MERGED',


                    getChildContext: 'DEFINE_MANY_MERGED',


                    render: 'DEFINE_ONCE',

                    // ==== Delegate methods ====


                    componentWillMount: 'DEFINE_MANY',


                    componentDidMount: 'DEFINE_MANY',


                    componentWillReceiveProps: 'DEFINE_MANY',


                    shouldComponentUpdate: 'DEFINE_ONCE',


                    componentWillUpdate: 'DEFINE_MANY',


                    componentDidUpdate: 'DEFINE_MANY',


                    componentWillUnmount: 'DEFINE_MANY',

                    // ==== Advanced methods ====


                    updateComponent: 'OVERRIDE_BASE'

                };

                var RESERVED_SPEC_KEYS = {
                    displayName: function(Constructor, displayName) {
                        Constructor.displayName = displayName;
                    },
                    mixins: function(Constructor, mixins) {
                        if (mixins) {
                            for (var i = 0; i < mixins.length; i++) {
                                mixSpecIntoComponent(Constructor, mixins[i]);
                            }
                        }
                    },
                    childContextTypes: function(Constructor, childContextTypes) {
                        if (process.env.NODE_ENV !== 'production') {
                            validateTypeDef(Constructor, childContextTypes, 'childContext');
                        }
                        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
                    },
                    contextTypes: function(Constructor, contextTypes) {
                        if (process.env.NODE_ENV !== 'production') {
                            validateTypeDef(Constructor, contextTypes, 'context');
                        }
                        Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
                    },

                    getDefaultProps: function(Constructor, getDefaultProps) {
                        if (Constructor.getDefaultProps) {
                            Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
                        } else {
                            Constructor.getDefaultProps = getDefaultProps;
                        }
                    },
                    propTypes: function(Constructor, propTypes) {
                        if (process.env.NODE_ENV !== 'production') {
                            validateTypeDef(Constructor, propTypes, 'prop');
                        }
                        Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
                    },
                    statics: function(Constructor, statics) {
                        mixStaticSpecIntoComponent(Constructor, statics);
                    },
                    autobind: function() {}
                };

                function validateTypeDef(Constructor, typeDef, location) {
                    for (var propName in typeDef) {
                        if (typeDef.hasOwnProperty(propName)) {
                            // use a warning instead of an invariant so components
                            // don't show up in prod but only in __DEV__
                            process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
                        }
                    }
                }

                function validateMethodOverride(isAlreadyDefined, name) {
                    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

                    // Disallow overriding of base class methods unless explicitly allowed.
                    if (ReactClassMixin.hasOwnProperty(name)) {
                        !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name): void 0;
                    }

                    // Disallow defining methods more than once unless explicitly allowed.
                    if (isAlreadyDefined) {
                        !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name): void 0;
                    }
                }

                function mixSpecIntoComponent(Constructor, spec) {
                    if (!spec) {
                        if (process.env.NODE_ENV !== 'production') {
                            var typeofSpec = typeof spec;
                            var isMixinValid = typeofSpec === 'object' && spec !== null;

                            process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
                        }

                        return;
                    }

                    !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75'): void 0;
                    !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

                    var proto = Constructor.prototype;
                    var autoBindPairs = proto.__reactAutoBindPairs;

                    // By handling mixins before any other properties, we ensure the same
                    // chaining order is applied to methods with DEFINE_MANY policy, whether
                    // mixins are listed before or after these methods in the spec.
                    if (spec.hasOwnProperty(MIXINS_KEY)) {
                        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
                    }

                    for (var name in spec) {
                        if (!spec.hasOwnProperty(name)) {
                            continue;
                        }

                        if (name === MIXINS_KEY) {
                            // We have already handled mixins in a special case above.
                            continue;
                        }

                        var property = spec[name];
                        var isAlreadyDefined = proto.hasOwnProperty(name);
                        validateMethodOverride(isAlreadyDefined, name);

                        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
                            RESERVED_SPEC_KEYS[name](Constructor, property);
                        } else {
                            // Setup methods on prototype:
                            // The following member methods should not be automatically bound:
                            // 1. Expected ReactClass methods (in the "interface").
                            // 2. Overridden methods (that were mixed in).
                            var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
                            var isFunction = typeof property === 'function';
                            var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

                            if (shouldAutoBind) {
                                autoBindPairs.push(name, property);
                                proto[name] = property;
                            } else {
                                if (isAlreadyDefined) {
                                    var specPolicy = ReactClassInterface[name];

                                    // These cases should already be caught by validateMethodOverride.
                                    !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name): void 0;

                                    // For methods which are defined more than once, call the existing
                                    // methods before calling the new property, merging if appropriate.
                                    if (specPolicy === 'DEFINE_MANY_MERGED') {
                                        proto[name] = createMergedResultFunction(proto[name], property);
                                    } else if (specPolicy === 'DEFINE_MANY') {
                                        proto[name] = createChainedFunction(proto[name], property);
                                    }
                                } else {
                                    proto[name] = property;
                                    if (process.env.NODE_ENV !== 'production') {
                                        // Add verbose displayName to the function, which helps when looking
                                        // at profiling tools.
                                        if (typeof property === 'function' && spec.displayName) {
                                            proto[name].displayName = spec.displayName + '_' + name;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                function mixStaticSpecIntoComponent(Constructor, statics) {
                    if (!statics) {
                        return;
                    }
                    for (var name in statics) {
                        var property = statics[name];
                        if (!statics.hasOwnProperty(name)) {
                            continue;
                        }

                        var isReserved = name in RESERVED_SPEC_KEYS;
                        !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

                        var isInherited = name in Constructor;
                        !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
                        Constructor[name] = property;
                    }
                }

                function mergeIntoWithNoDuplicateKeys(one, two) {
                    !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80'): void 0;

                    for (var key in two) {
                        if (two.hasOwnProperty(key)) {
                            !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key): void 0;
                            one[key] = two[key];
                        }
                    }
                    return one;
                }

                function createMergedResultFunction(one, two) {
                    return function mergedResult() {
                        var a = one.apply(this, arguments);
                        var b = two.apply(this, arguments);
                        if (a == null) {
                            return b;
                        } else if (b == null) {
                            return a;
                        }
                        var c = {};
                        mergeIntoWithNoDuplicateKeys(c, a);
                        mergeIntoWithNoDuplicateKeys(c, b);
                        return c;
                    };
                }

                function createChainedFunction(one, two) {
                    return function chainedFunction() {
                        one.apply(this, arguments);
                        two.apply(this, arguments);
                    };
                }

                function bindAutoBindMethod(component, method) {
                    var boundMethod = method.bind(component);
                    if (process.env.NODE_ENV !== 'production') {
                        boundMethod.__reactBoundContext = component;
                        boundMethod.__reactBoundMethod = method;
                        boundMethod.__reactBoundArguments = null;
                        var componentName = component.constructor.displayName;
                        var _bind = boundMethod.bind;
                        boundMethod.bind = function(newThis) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                args[_key - 1] = arguments[_key];
                            }

                            // User is trying to bind() an autobound method; we effectively will
                            // ignore the value of "this" that the user is trying to use, so
                            // let's warn.
                            if (newThis !== component && newThis !== null) {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
                            } else if (!args.length) {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
                                return boundMethod;
                            }
                            var reboundMethod = _bind.apply(boundMethod, arguments);
                            reboundMethod.__reactBoundContext = component;
                            reboundMethod.__reactBoundMethod = method;
                            reboundMethod.__reactBoundArguments = args;
                            return reboundMethod;
                        };
                    }
                    return boundMethod;
                }

                function bindAutoBindMethods(component) {
                    var pairs = component.__reactAutoBindPairs;
                    for (var i = 0; i < pairs.length; i += 2) {
                        var autoBindKey = pairs[i];
                        var method = pairs[i + 1];
                        component[autoBindKey] = bindAutoBindMethod(component, method);
                    }
                }

                var ReactClassMixin = {


                    replaceState: function(newState, callback) {
                        this.updater.enqueueReplaceState(this, newState);
                        if (callback) {
                            this.updater.enqueueCallback(this, callback, 'replaceState');
                        }
                    },


                    isMounted: function() {
                        return this.updater.isMounted(this);
                    }
                };

                var ReactClassComponent = function() {};
                _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

                var ReactClass = {


                    createClass: function(spec) {
                        // To keep our warnings more understandable, we'll use a little hack here to
                        // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
                        // unnecessarily identify a class without displayName as 'Constructor'.
                        var Constructor = identity(function(props, context, updater) {
                            // This constructor gets overridden by mocks. The argument is used
                            // by mocks to assert on what gets mounted.

                            if (process.env.NODE_ENV !== 'production') {
                                process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
                            }

                            // Wire up auto-binding
                            if (this.__reactAutoBindPairs.length) {
                                bindAutoBindMethods(this);
                            }

                            this.props = props;
                            this.context = context;
                            this.refs = emptyObject;
                            this.updater = updater || ReactNoopUpdateQueue;

                            this.state = null;

                            // ReactClasses doesn't have constructors. Instead, they use the
                            // getInitialState and componentWillMount methods for initialization.

                            var initialState = this.getInitialState ? this.getInitialState() : null;
                            if (process.env.NODE_ENV !== 'production') {
                                // We allow auto-mocks to proceed as if they're returning null.
                                if (initialState === undefined && this.getInitialState._isMockFunction) {
                                    // This is probably bad practice. Consider warning here and
                                    // deprecating this convenience.
                                    initialState = null;
                                }
                            }!(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent'): void 0;

                            this.state = initialState;
                        });
                        Constructor.prototype = new ReactClassComponent();
                        Constructor.prototype.constructor = Constructor;
                        Constructor.prototype.__reactAutoBindPairs = [];

                        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

                        mixSpecIntoComponent(Constructor, spec);

                        // Initialize the defaultProps property after all mixins have been merged.
                        if (Constructor.getDefaultProps) {
                            Constructor.defaultProps = Constructor.getDefaultProps();
                        }

                        if (process.env.NODE_ENV !== 'production') {
                            // This is a tag to indicate that the use of these method names is ok,
                            // since it's used with createClass. If it's not, then it's likely a
                            // mistake so we'll warn you to use the static property, property
                            // initializer or constructor respectively.
                            if (Constructor.getDefaultProps) {
                                Constructor.getDefaultProps.isReactClassApproved = {};
                            }
                            if (Constructor.prototype.getInitialState) {
                                Constructor.prototype.getInitialState.isReactClassApproved = {};
                            }
                        }

                        !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
                            process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
                        }

                        // Reduce time spent doing lookups by setting these on the prototype.
                        for (var methodName in ReactClassInterface) {
                            if (!Constructor.prototype[methodName]) {
                                Constructor.prototype[methodName] = null;
                            }
                        }

                        return Constructor;
                    },

                    injection: {
                        injectMixin: function(mixin) {
                            injectedMixins.push(mixin);
                        }
                    }

                };

                module.exports = ReactClass;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactComponent": 161,
            "./ReactElement": 165,
            "./ReactNoopUpdateQueue": 168,
            "./ReactPropTypeLocationNames": 169,
            "./reactProdInvariant": 178,
            "_process": 28,
            "fbjs/lib/emptyObject": 10,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        161: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactNoopUpdateQueue = _dereq_('./ReactNoopUpdateQueue');

                var canDefineProperty = _dereq_('./canDefineProperty');
                var emptyObject = _dereq_('fbjs/lib/emptyObject');
                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                function ReactComponent(props, context, updater) {
                    this.props = props;
                    this.context = context;
                    this.refs = emptyObject;
                    // We initialize the default updater but the real one gets injected by the
                    // renderer.
                    this.updater = updater || ReactNoopUpdateQueue;
                }

                ReactComponent.prototype.isReactComponent = {};

                ReactComponent.prototype.setState = function(partialState, callback) {
                    !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85'): void 0;
                    this.updater.enqueueSetState(this, partialState);
                    if (callback) {
                        this.updater.enqueueCallback(this, callback, 'setState');
                    }
                };

                ReactComponent.prototype.forceUpdate = function(callback) {
                    this.updater.enqueueForceUpdate(this);
                    if (callback) {
                        this.updater.enqueueCallback(this, callback, 'forceUpdate');
                    }
                };

                if (process.env.NODE_ENV !== 'production') {
                    var deprecatedAPIs = {
                        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
                        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
                    };
                    var defineDeprecationWarning = function(methodName, info) {
                        if (canDefineProperty) {
                            Object.defineProperty(ReactComponent.prototype, methodName, {
                                get: function() {
                                    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
                                    return undefined;
                                }
                            });
                        }
                    };
                    for (var fnName in deprecatedAPIs) {
                        if (deprecatedAPIs.hasOwnProperty(fnName)) {
                            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                        }
                    }
                }

                module.exports = ReactComponent;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactNoopUpdateQueue": 168,
            "./canDefineProperty": 174,
            "./reactProdInvariant": 178,
            "_process": 28,
            "fbjs/lib/emptyObject": 10,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24
        }],
        162: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactCurrentOwner = _dereq_('./ReactCurrentOwner');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                function isNative(fn) {
                    // Based on isNative() from Lodash
                    var funcToString = Function.prototype.toString;
                    var hasOwnProperty = Object.prototype.hasOwnProperty;
                    var reIsNative = RegExp('^' + funcToString
                        // Take an example native function source for comparison
                        .call(hasOwnProperty)
                        // Strip regex characters so we can use it for regex
                        .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                        // Remove hasOwnProperty from the template to make it generic
                        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
                    try {
                        var source = funcToString.call(fn);
                        return reIsNative.test(source);
                    } catch (err) {
                        return false;
                    }
                }

                var canUseCollections =
                    // Array.from
                    typeof Array.from === 'function' &&
                    // Map
                    typeof Map === 'function' && isNative(Map) &&
                    // Map.prototype.keys
                    Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
                    // Set
                    typeof Set === 'function' && isNative(Set) &&
                    // Set.prototype.keys
                    Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

                var setItem;
                var getItem;
                var removeItem;
                var getItemIDs;
                var addRoot;
                var removeRoot;
                var getRootIDs;

                if (canUseCollections) {
                    var itemMap = new Map();
                    var rootIDSet = new Set();

                    setItem = function(id, item) {
                        itemMap.set(id, item);
                    };
                    getItem = function(id) {
                        return itemMap.get(id);
                    };
                    removeItem = function(id) {
                        itemMap['delete'](id);
                    };
                    getItemIDs = function() {
                        return Array.from(itemMap.keys());
                    };

                    addRoot = function(id) {
                        rootIDSet.add(id);
                    };
                    removeRoot = function(id) {
                        rootIDSet['delete'](id);
                    };
                    getRootIDs = function() {
                        return Array.from(rootIDSet.keys());
                    };
                } else {
                    var itemByKey = {};
                    var rootByKey = {};

                    // Use non-numeric keys to prevent V8 performance issues:
                    // https://github.com/facebook/react/pull/7232
                    var getKeyFromID = function(id) {
                        return '.' + id;
                    };
                    var getIDFromKey = function(key) {
                        return parseInt(key.substr(1), 10);
                    };

                    setItem = function(id, item) {
                        var key = getKeyFromID(id);
                        itemByKey[key] = item;
                    };
                    getItem = function(id) {
                        var key = getKeyFromID(id);
                        return itemByKey[key];
                    };
                    removeItem = function(id) {
                        var key = getKeyFromID(id);
                        delete itemByKey[key];
                    };
                    getItemIDs = function() {
                        return Object.keys(itemByKey).map(getIDFromKey);
                    };

                    addRoot = function(id) {
                        var key = getKeyFromID(id);
                        rootByKey[key] = true;
                    };
                    removeRoot = function(id) {
                        var key = getKeyFromID(id);
                        delete rootByKey[key];
                    };
                    getRootIDs = function() {
                        return Object.keys(rootByKey).map(getIDFromKey);
                    };
                }

                var unmountedIDs = [];

                function purgeDeep(id) {
                    var item = getItem(id);
                    if (item) {
                        var childIDs = item.childIDs;

                        removeItem(id);
                        childIDs.forEach(purgeDeep);
                    }
                }

                function describeComponentFrame(name, source, ownerName) {
                    return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
                }

                function getDisplayName(element) {
                    if (element == null) {
                        return '#empty';
                    } else if (typeof element === 'string' || typeof element === 'number') {
                        return '#text';
                    } else if (typeof element.type === 'string') {
                        return element.type;
                    } else {
                        return element.type.displayName || element.type.name || 'Unknown';
                    }
                }

                function describeID(id) {
                    var name = ReactComponentTreeHook.getDisplayName(id);
                    var element = ReactComponentTreeHook.getElement(id);
                    var ownerID = ReactComponentTreeHook.getOwnerID(id);
                    var ownerName;
                    if (ownerID) {
                        ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
                    }
                    process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
                    return describeComponentFrame(name, element && element._source, ownerName);
                }

                var ReactComponentTreeHook = {
                    onSetChildren: function(id, nextChildIDs) {
                        var item = getItem(id);
                        !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
                        item.childIDs = nextChildIDs;

                        for (var i = 0; i < nextChildIDs.length; i++) {
                            var nextChildID = nextChildIDs[i];
                            var nextChild = getItem(nextChildID);
                            !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
                            !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141'): void 0;
                            !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
                            if (nextChild.parentID == null) {
                                nextChild.parentID = id;
                                // TODO: This shouldn't be necessary but mounting a new root during in
                                // componentWillMount currently causes not-yet-mounted components to
                                // be purged from our tree data so their parent id is missing.
                            }!(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id): void 0;
                        }
                    },
                    onBeforeMountComponent: function(id, element, parentID) {
                        var item = {
                            element: element,
                            parentID: parentID,
                            text: null,
                            childIDs: [],
                            isMounted: false,
                            updateCount: 0
                        };
                        setItem(id, item);
                    },
                    onBeforeUpdateComponent: function(id, element) {
                        var item = getItem(id);
                        if (!item || !item.isMounted) {
                            // We may end up here as a result of setState() in componentWillUnmount().
                            // In this case, ignore the element.
                            return;
                        }
                        item.element = element;
                    },
                    onMountComponent: function(id) {
                        var item = getItem(id);
                        !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
                        item.isMounted = true;
                        var isRoot = item.parentID === 0;
                        if (isRoot) {
                            addRoot(id);
                        }
                    },
                    onUpdateComponent: function(id) {
                        var item = getItem(id);
                        if (!item || !item.isMounted) {
                            // We may end up here as a result of setState() in componentWillUnmount().
                            // In this case, ignore the element.
                            return;
                        }
                        item.updateCount++;
                    },
                    onUnmountComponent: function(id) {
                        var item = getItem(id);
                        if (item) {
                            // We need to check if it exists.
                            // `item` might not exist if it is inside an error boundary, and a sibling
                            // error boundary child threw while mounting. Then this instance never
                            // got a chance to mount, but it still gets an unmounting event during
                            // the error boundary cleanup.
                            item.isMounted = false;
                            var isRoot = item.parentID === 0;
                            if (isRoot) {
                                removeRoot(id);
                            }
                        }
                        unmountedIDs.push(id);
                    },
                    purgeUnmountedComponents: function() {
                        if (ReactComponentTreeHook._preventPurging) {
                            // Should only be used for testing.
                            return;
                        }

                        for (var i = 0; i < unmountedIDs.length; i++) {
                            var id = unmountedIDs[i];
                            purgeDeep(id);
                        }
                        unmountedIDs.length = 0;
                    },
                    isMounted: function(id) {
                        var item = getItem(id);
                        return item ? item.isMounted : false;
                    },
                    getCurrentStackAddendum: function(topElement) {
                        var info = '';
                        if (topElement) {
                            var name = getDisplayName(topElement);
                            var owner = topElement._owner;
                            info += describeComponentFrame(name, topElement._source, owner && owner.getName());
                        }

                        var currentOwner = ReactCurrentOwner.current;
                        var id = currentOwner && currentOwner._debugID;

                        info += ReactComponentTreeHook.getStackAddendumByID(id);
                        return info;
                    },
                    getStackAddendumByID: function(id) {
                        var info = '';
                        while (id) {
                            info += describeID(id);
                            id = ReactComponentTreeHook.getParentID(id);
                        }
                        return info;
                    },
                    getChildIDs: function(id) {
                        var item = getItem(id);
                        return item ? item.childIDs : [];
                    },
                    getDisplayName: function(id) {
                        var element = ReactComponentTreeHook.getElement(id);
                        if (!element) {
                            return null;
                        }
                        return getDisplayName(element);
                    },
                    getElement: function(id) {
                        var item = getItem(id);
                        return item ? item.element : null;
                    },
                    getOwnerID: function(id) {
                        var element = ReactComponentTreeHook.getElement(id);
                        if (!element || !element._owner) {
                            return null;
                        }
                        return element._owner._debugID;
                    },
                    getParentID: function(id) {
                        var item = getItem(id);
                        return item ? item.parentID : null;
                    },
                    getSource: function(id) {
                        var item = getItem(id);
                        var element = item ? item.element : null;
                        var source = element != null ? element._source : null;
                        return source;
                    },
                    getText: function(id) {
                        var element = ReactComponentTreeHook.getElement(id);
                        if (typeof element === 'string') {
                            return element;
                        } else if (typeof element === 'number') {
                            return '' + element;
                        } else {
                            return null;
                        }
                    },
                    getUpdateCount: function(id) {
                        var item = getItem(id);
                        return item ? item.updateCount : 0;
                    },

                    getRootIDs: getRootIDs,
                    getRegisteredIDs: getItemIDs
                };

                module.exports = ReactComponentTreeHook;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactCurrentOwner": 163,
            "./reactProdInvariant": 178,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24
        }],
        163: [function(_dereq_, module, exports) {

            var ReactCurrentOwner = {


                current: null

            };

            module.exports = ReactCurrentOwner;
        }, {}],
        164: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactElement = _dereq_('./ReactElement');

                var createDOMFactory = ReactElement.createFactory;
                if (process.env.NODE_ENV !== 'production') {
                    var ReactElementValidator = _dereq_('./ReactElementValidator');
                    createDOMFactory = ReactElementValidator.createFactory;
                }

                var ReactDOMFactories = {
                    a: createDOMFactory('a'),
                    abbr: createDOMFactory('abbr'),
                    address: createDOMFactory('address'),
                    area: createDOMFactory('area'),
                    article: createDOMFactory('article'),
                    aside: createDOMFactory('aside'),
                    audio: createDOMFactory('audio'),
                    b: createDOMFactory('b'),
                    base: createDOMFactory('base'),
                    bdi: createDOMFactory('bdi'),
                    bdo: createDOMFactory('bdo'),
                    big: createDOMFactory('big'),
                    blockquote: createDOMFactory('blockquote'),
                    body: createDOMFactory('body'),
                    br: createDOMFactory('br'),
                    button: createDOMFactory('button'),
                    canvas: createDOMFactory('canvas'),
                    caption: createDOMFactory('caption'),
                    cite: createDOMFactory('cite'),
                    code: createDOMFactory('code'),
                    col: createDOMFactory('col'),
                    colgroup: createDOMFactory('colgroup'),
                    data: createDOMFactory('data'),
                    datalist: createDOMFactory('datalist'),
                    dd: createDOMFactory('dd'),
                    del: createDOMFactory('del'),
                    details: createDOMFactory('details'),
                    dfn: createDOMFactory('dfn'),
                    dialog: createDOMFactory('dialog'),
                    div: createDOMFactory('div'),
                    dl: createDOMFactory('dl'),
                    dt: createDOMFactory('dt'),
                    em: createDOMFactory('em'),
                    embed: createDOMFactory('embed'),
                    fieldset: createDOMFactory('fieldset'),
                    figcaption: createDOMFactory('figcaption'),
                    figure: createDOMFactory('figure'),
                    footer: createDOMFactory('footer'),
                    form: createDOMFactory('form'),
                    h1: createDOMFactory('h1'),
                    h2: createDOMFactory('h2'),
                    h3: createDOMFactory('h3'),
                    h4: createDOMFactory('h4'),
                    h5: createDOMFactory('h5'),
                    h6: createDOMFactory('h6'),
                    head: createDOMFactory('head'),
                    header: createDOMFactory('header'),
                    hgroup: createDOMFactory('hgroup'),
                    hr: createDOMFactory('hr'),
                    html: createDOMFactory('html'),
                    i: createDOMFactory('i'),
                    iframe: createDOMFactory('iframe'),
                    img: createDOMFactory('img'),
                    input: createDOMFactory('input'),
                    ins: createDOMFactory('ins'),
                    kbd: createDOMFactory('kbd'),
                    keygen: createDOMFactory('keygen'),
                    label: createDOMFactory('label'),
                    legend: createDOMFactory('legend'),
                    li: createDOMFactory('li'),
                    link: createDOMFactory('link'),
                    main: createDOMFactory('main'),
                    map: createDOMFactory('map'),
                    mark: createDOMFactory('mark'),
                    menu: createDOMFactory('menu'),
                    menuitem: createDOMFactory('menuitem'),
                    meta: createDOMFactory('meta'),
                    meter: createDOMFactory('meter'),
                    nav: createDOMFactory('nav'),
                    noscript: createDOMFactory('noscript'),
                    object: createDOMFactory('object'),
                    ol: createDOMFactory('ol'),
                    optgroup: createDOMFactory('optgroup'),
                    option: createDOMFactory('option'),
                    output: createDOMFactory('output'),
                    p: createDOMFactory('p'),
                    param: createDOMFactory('param'),
                    picture: createDOMFactory('picture'),
                    pre: createDOMFactory('pre'),
                    progress: createDOMFactory('progress'),
                    q: createDOMFactory('q'),
                    rp: createDOMFactory('rp'),
                    rt: createDOMFactory('rt'),
                    ruby: createDOMFactory('ruby'),
                    s: createDOMFactory('s'),
                    samp: createDOMFactory('samp'),
                    script: createDOMFactory('script'),
                    section: createDOMFactory('section'),
                    select: createDOMFactory('select'),
                    small: createDOMFactory('small'),
                    source: createDOMFactory('source'),
                    span: createDOMFactory('span'),
                    strong: createDOMFactory('strong'),
                    style: createDOMFactory('style'),
                    sub: createDOMFactory('sub'),
                    summary: createDOMFactory('summary'),
                    sup: createDOMFactory('sup'),
                    table: createDOMFactory('table'),
                    tbody: createDOMFactory('tbody'),
                    td: createDOMFactory('td'),
                    textarea: createDOMFactory('textarea'),
                    tfoot: createDOMFactory('tfoot'),
                    th: createDOMFactory('th'),
                    thead: createDOMFactory('thead'),
                    time: createDOMFactory('time'),
                    title: createDOMFactory('title'),
                    tr: createDOMFactory('tr'),
                    track: createDOMFactory('track'),
                    u: createDOMFactory('u'),
                    ul: createDOMFactory('ul'),
                    'var': createDOMFactory('var'),
                    video: createDOMFactory('video'),
                    wbr: createDOMFactory('wbr'),

                    // SVG
                    circle: createDOMFactory('circle'),
                    clipPath: createDOMFactory('clipPath'),
                    defs: createDOMFactory('defs'),
                    ellipse: createDOMFactory('ellipse'),
                    g: createDOMFactory('g'),
                    image: createDOMFactory('image'),
                    line: createDOMFactory('line'),
                    linearGradient: createDOMFactory('linearGradient'),
                    mask: createDOMFactory('mask'),
                    path: createDOMFactory('path'),
                    pattern: createDOMFactory('pattern'),
                    polygon: createDOMFactory('polygon'),
                    polyline: createDOMFactory('polyline'),
                    radialGradient: createDOMFactory('radialGradient'),
                    rect: createDOMFactory('rect'),
                    stop: createDOMFactory('stop'),
                    svg: createDOMFactory('svg'),
                    text: createDOMFactory('text'),
                    tspan: createDOMFactory('tspan')
                };

                module.exports = ReactDOMFactories;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactElement": 165,
            "./ReactElementValidator": 167,
            "_process": 28
        }],
        165: [function(_dereq_, module, exports) {
            (function(process) {

                var _assign = _dereq_('object-assign');

                var ReactCurrentOwner = _dereq_('./ReactCurrentOwner');

                var warning = _dereq_('fbjs/lib/warning');
                var canDefineProperty = _dereq_('./canDefineProperty');
                var hasOwnProperty = Object.prototype.hasOwnProperty;

                var REACT_ELEMENT_TYPE = _dereq_('./ReactElementSymbol');

                var RESERVED_PROPS = {
                    key: true,
                    ref: true,
                    __self: true,
                    __source: true
                };

                var specialPropKeyWarningShown, specialPropRefWarningShown;

                function hasValidRef(config) {
                    if (process.env.NODE_ENV !== 'production') {
                        if (hasOwnProperty.call(config, 'ref')) {
                            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                            if (getter && getter.isReactWarning) {
                                return false;
                            }
                        }
                    }
                    return config.ref !== undefined;
                }

                function hasValidKey(config) {
                    if (process.env.NODE_ENV !== 'production') {
                        if (hasOwnProperty.call(config, 'key')) {
                            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                            if (getter && getter.isReactWarning) {
                                return false;
                            }
                        }
                    }
                    return config.key !== undefined;
                }

                function defineKeyPropWarningGetter(props, displayName) {
                    var warnAboutAccessingKey = function() {
                        if (!specialPropKeyWarningShown) {
                            specialPropKeyWarningShown = true;
                            process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
                        }
                    };
                    warnAboutAccessingKey.isReactWarning = true;
                    Object.defineProperty(props, 'key', {
                        get: warnAboutAccessingKey,
                        configurable: true
                    });
                }

                function defineRefPropWarningGetter(props, displayName) {
                    var warnAboutAccessingRef = function() {
                        if (!specialPropRefWarningShown) {
                            specialPropRefWarningShown = true;
                            process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
                        }
                    };
                    warnAboutAccessingRef.isReactWarning = true;
                    Object.defineProperty(props, 'ref', {
                        get: warnAboutAccessingRef,
                        configurable: true
                    });
                }

                var ReactElement = function(type, key, ref, self, source, owner, props) {
                    var element = {
                        // This tag allow us to uniquely identify this as a React Element
                        $$typeof: REACT_ELEMENT_TYPE,

                        // Built-in properties that belong on the element
                        type: type,
                        key: key,
                        ref: ref,
                        props: props,

                        // Record the component responsible for creating this element.
                        _owner: owner
                    };

                    if (process.env.NODE_ENV !== 'production') {
                        // The validation flag is currently mutative. We put it on
                        // an external backing store so that we can freeze the whole object.
                        // This can be replaced with a WeakMap once they are implemented in
                        // commonly used development environments.
                        element._store = {};

                        // To make comparing ReactElements easier for testing purposes, we make
                        // the validation flag non-enumerable (where possible, which should
                        // include every environment we run tests in), so the test framework
                        // ignores it.
                        if (canDefineProperty) {
                            Object.defineProperty(element._store, 'validated', {
                                configurable: false,
                                enumerable: false,
                                writable: true,
                                value: false
                            });
                            // self and source are DEV only properties.
                            Object.defineProperty(element, '_self', {
                                configurable: false,
                                enumerable: false,
                                writable: false,
                                value: self
                            });
                            // Two elements created in two different places should be considered
                            // equal for testing purposes and therefore we hide it from enumeration.
                            Object.defineProperty(element, '_source', {
                                configurable: false,
                                enumerable: false,
                                writable: false,
                                value: source
                            });
                        } else {
                            element._store.validated = false;
                            element._self = self;
                            element._source = source;
                        }
                        if (Object.freeze) {
                            Object.freeze(element.props);
                            Object.freeze(element);
                        }
                    }

                    return element;
                };

                ReactElement.createElement = function(type, config, children) {
                    var propName;

                    // Reserved names are extracted
                    var props = {};

                    var key = null;
                    var ref = null;
                    var self = null;
                    var source = null;

                    if (config != null) {
                        if (hasValidRef(config)) {
                            ref = config.ref;
                        }
                        if (hasValidKey(config)) {
                            key = '' + config.key;
                        }

                        self = config.__self === undefined ? null : config.__self;
                        source = config.__source === undefined ? null : config.__source;
                        // Remaining properties are added to a new props object
                        for (propName in config) {
                            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                                props[propName] = config[propName];
                            }
                        }
                    }

                    // Children can be more than one argument, and those are transferred onto
                    // the newly allocated props object.
                    var childrenLength = arguments.length - 2;
                    if (childrenLength === 1) {
                        props.children = children;
                    } else if (childrenLength > 1) {
                        var childArray = Array(childrenLength);
                        for (var i = 0; i < childrenLength; i++) {
                            childArray[i] = arguments[i + 2];
                        }
                        if (process.env.NODE_ENV !== 'production') {
                            if (Object.freeze) {
                                Object.freeze(childArray);
                            }
                        }
                        props.children = childArray;
                    }

                    // Resolve default props
                    if (type && type.defaultProps) {
                        var defaultProps = type.defaultProps;
                        for (propName in defaultProps) {
                            if (props[propName] === undefined) {
                                props[propName] = defaultProps[propName];
                            }
                        }
                    }
                    if (process.env.NODE_ENV !== 'production') {
                        if (key || ref) {
                            if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
                                var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                                if (key) {
                                    defineKeyPropWarningGetter(props, displayName);
                                }
                                if (ref) {
                                    defineRefPropWarningGetter(props, displayName);
                                }
                            }
                        }
                    }
                    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
                };

                ReactElement.createFactory = function(type) {
                    var factory = ReactElement.createElement.bind(null, type);
                    // Expose the type on the factory and the prototype so that it can be
                    // easily accessed on elements. E.g. `<Foo />.type === Foo`.
                    // This should not be named `constructor` since this may not be the function
                    // that created the element, and it may not even be a constructor.
                    // Legacy hook TODO: Warn if this is accessed
                    factory.type = type;
                    return factory;
                };

                ReactElement.cloneAndReplaceKey = function(oldElement, newKey) {
                    var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

                    return newElement;
                };

                ReactElement.cloneElement = function(element, config, children) {
                    var propName;

                    // Original props are copied
                    var props = _assign({}, element.props);

                    // Reserved names are extracted
                    var key = element.key;
                    var ref = element.ref;
                    // Self is preserved since the owner is preserved.
                    var self = element._self;
                    // Source is preserved since cloneElement is unlikely to be targeted by a
                    // transpiler, and the original source is probably a better indicator of the
                    // true owner.
                    var source = element._source;

                    // Owner will be preserved, unless ref is overridden
                    var owner = element._owner;

                    if (config != null) {
                        if (hasValidRef(config)) {
                            // Silently steal the ref from the parent.
                            ref = config.ref;
                            owner = ReactCurrentOwner.current;
                        }
                        if (hasValidKey(config)) {
                            key = '' + config.key;
                        }

                        // Remaining properties override existing props
                        var defaultProps;
                        if (element.type && element.type.defaultProps) {
                            defaultProps = element.type.defaultProps;
                        }
                        for (propName in config) {
                            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                                if (config[propName] === undefined && defaultProps !== undefined) {
                                    // Resolve default props
                                    props[propName] = defaultProps[propName];
                                } else {
                                    props[propName] = config[propName];
                                }
                            }
                        }
                    }

                    // Children can be more than one argument, and those are transferred onto
                    // the newly allocated props object.
                    var childrenLength = arguments.length - 2;
                    if (childrenLength === 1) {
                        props.children = children;
                    } else if (childrenLength > 1) {
                        var childArray = Array(childrenLength);
                        for (var i = 0; i < childrenLength; i++) {
                            childArray[i] = arguments[i + 2];
                        }
                        props.children = childArray;
                    }

                    return ReactElement(element.type, key, ref, self, source, owner, props);
                };

                ReactElement.isValidElement = function(object) {
                    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
                };

                module.exports = ReactElement;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactCurrentOwner": 163,
            "./ReactElementSymbol": 166,
            "./canDefineProperty": 174,
            "_process": 28,
            "fbjs/lib/warning": 24,
            "object-assign": 27
        }],
        166: [function(_dereq_, module, exports) {
            arguments[4][80][0].apply(exports, arguments)
        }, {
            "dup": 80
        }],
        167: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactCurrentOwner = _dereq_('./ReactCurrentOwner');
                var ReactComponentTreeHook = _dereq_('./ReactComponentTreeHook');
                var ReactElement = _dereq_('./ReactElement');

                var checkReactTypeSpec = _dereq_('./checkReactTypeSpec');

                var canDefineProperty = _dereq_('./canDefineProperty');
                var getIteratorFn = _dereq_('./getIteratorFn');
                var warning = _dereq_('fbjs/lib/warning');

                function getDeclarationErrorAddendum() {
                    if (ReactCurrentOwner.current) {
                        var name = ReactCurrentOwner.current.getName();
                        if (name) {
                            return ' Check the render method of `' + name + '`.';
                        }
                    }
                    return '';
                }

                var ownerHasKeyUseWarning = {};

                function getCurrentComponentErrorInfo(parentType) {
                    var info = getDeclarationErrorAddendum();

                    if (!info) {
                        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                        if (parentName) {
                            info = ' Check the top-level render call using <' + parentName + '>.';
                        }
                    }
                    return info;
                }

                function validateExplicitKey(element, parentType) {
                    if (!element._store || element._store.validated || element.key != null) {
                        return;
                    }
                    element._store.validated = true;

                    var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

                    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
                    if (memoizer[currentComponentErrorInfo]) {
                        return;
                    }
                    memoizer[currentComponentErrorInfo] = true;

                    // Usually the current owner is the offender, but if it accepts children as a
                    // property, it may be the creator of the child that's responsible for
                    // assigning it a key.
                    var childOwner = '';
                    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                        // Give the component that originally created this child.
                        childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
                    }

                    process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
                }

                function validateChildKeys(node, parentType) {
                    if (typeof node !== 'object') {
                        return;
                    }
                    if (Array.isArray(node)) {
                        for (var i = 0; i < node.length; i++) {
                            var child = node[i];
                            if (ReactElement.isValidElement(child)) {
                                validateExplicitKey(child, parentType);
                            }
                        }
                    } else if (ReactElement.isValidElement(node)) {
                        // This element was passed in a valid location.
                        if (node._store) {
                            node._store.validated = true;
                        }
                    } else if (node) {
                        var iteratorFn = getIteratorFn(node);
                        // Entry iterators provide implicit keys.
                        if (iteratorFn) {
                            if (iteratorFn !== node.entries) {
                                var iterator = iteratorFn.call(node);
                                var step;
                                while (!(step = iterator.next()).done) {
                                    if (ReactElement.isValidElement(step.value)) {
                                        validateExplicitKey(step.value, parentType);
                                    }
                                }
                            }
                        }
                    }
                }

                function validatePropTypes(element) {
                    var componentClass = element.type;
                    if (typeof componentClass !== 'function') {
                        return;
                    }
                    var name = componentClass.displayName || componentClass.name;
                    if (componentClass.propTypes) {
                        checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
                    }
                    if (typeof componentClass.getDefaultProps === 'function') {
                        process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
                    }
                }

                var ReactElementValidator = {

                    createElement: function(type, props, children) {
                        var validType = typeof type === 'string' || typeof type === 'function';
                        // We warn in this case but don't throw. We expect the element creation to
                        // succeed and there will likely be errors in render.
                        if (!validType) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
                        }

                        var element = ReactElement.createElement.apply(this, arguments);

                        // The result can be nullish if a mock or a custom function is used.
                        // TODO: Drop this when these are no longer allowed as the type argument.
                        if (element == null) {
                            return element;
                        }

                        // Skip key warning if the type isn't valid since our key validation logic
                        // doesn't expect a non-string/function type and can throw confusing errors.
                        // We don't want exception behavior to differ between dev and prod.
                        // (Rendering will throw with a helpful message and as soon as the type is
                        // fixed, the key warnings will appear.)
                        if (validType) {
                            for (var i = 2; i < arguments.length; i++) {
                                validateChildKeys(arguments[i], type);
                            }
                        }

                        validatePropTypes(element);

                        return element;
                    },

                    createFactory: function(type) {
                        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
                        // Legacy hook TODO: Warn if this is accessed
                        validatedFactory.type = type;

                        if (process.env.NODE_ENV !== 'production') {
                            if (canDefineProperty) {
                                Object.defineProperty(validatedFactory, 'type', {
                                    enumerable: false,
                                    get: function() {
                                        process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
                                        Object.defineProperty(this, 'type', {
                                            value: type
                                        });
                                        return type;
                                    }
                                });
                            }
                        }

                        return validatedFactory;
                    },

                    cloneElement: function(element, props, children) {
                        var newElement = ReactElement.cloneElement.apply(this, arguments);
                        for (var i = 2; i < arguments.length; i++) {
                            validateChildKeys(arguments[i], newElement.type);
                        }
                        validatePropTypes(newElement);
                        return newElement;
                    }

                };

                module.exports = ReactElementValidator;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactComponentTreeHook": 162,
            "./ReactCurrentOwner": 163,
            "./ReactElement": 165,
            "./canDefineProperty": 174,
            "./checkReactTypeSpec": 175,
            "./getIteratorFn": 176,
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        168: [function(_dereq_, module, exports) {
            (function(process) {

                var warning = _dereq_('fbjs/lib/warning');

                function warnNoop(publicInstance, callerName) {
                    if (process.env.NODE_ENV !== 'production') {
                        var constructor = publicInstance.constructor;
                        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
                    }
                }

                var ReactNoopUpdateQueue = {


                    isMounted: function(publicInstance) {
                        return false;
                    },


                    enqueueCallback: function(publicInstance, callback) {},


                    enqueueForceUpdate: function(publicInstance) {
                        warnNoop(publicInstance, 'forceUpdate');
                    },


                    enqueueReplaceState: function(publicInstance, completeState) {
                        warnNoop(publicInstance, 'replaceState');
                    },


                    enqueueSetState: function(publicInstance, partialState) {
                        warnNoop(publicInstance, 'setState');
                    }
                };

                module.exports = ReactNoopUpdateQueue;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28,
            "fbjs/lib/warning": 24
        }],
        169: [function(_dereq_, module, exports) {
            arguments[4][98][0].apply(exports, arguments)
        }, {
            "_process": 28,
            "dup": 98
        }],
        170: [function(_dereq_, module, exports) {
            (function(process) {

                var ReactElement = _dereq_('./ReactElement');
                var ReactPropTypeLocationNames = _dereq_('./ReactPropTypeLocationNames');
                var ReactPropTypesSecret = _dereq_('./ReactPropTypesSecret');

                var emptyFunction = _dereq_('fbjs/lib/emptyFunction');
                var getIteratorFn = _dereq_('./getIteratorFn');
                var warning = _dereq_('fbjs/lib/warning');

                var ANONYMOUS = '<<anonymous>>';

                var ReactPropTypes = {
                    array: createPrimitiveTypeChecker('array'),
                    bool: createPrimitiveTypeChecker('boolean'),
                    func: createPrimitiveTypeChecker('function'),
                    number: createPrimitiveTypeChecker('number'),
                    object: createPrimitiveTypeChecker('object'),
                    string: createPrimitiveTypeChecker('string'),
                    symbol: createPrimitiveTypeChecker('symbol'),

                    any: createAnyTypeChecker(),
                    arrayOf: createArrayOfTypeChecker,
                    element: createElementTypeChecker(),
                    instanceOf: createInstanceTypeChecker,
                    node: createNodeChecker(),
                    objectOf: createObjectOfTypeChecker,
                    oneOf: createEnumTypeChecker,
                    oneOfType: createUnionTypeChecker,
                    shape: createShapeTypeChecker
                };

                function is(x, y) {
                    // SameValue algorithm
                    if (x === y) {
                        // Steps 1-5, 7-10
                        // Steps 6.b-6.e: +0 != -0
                        return x !== 0 || 1 / x === 1 / y;
                    } else {
                        // Step 6.a: NaN == NaN
                        return x !== x && y !== y;
                    }
                }

                function PropTypeError(message) {
                    this.message = message;
                    this.stack = '';
                }
                // Make `instanceof Error` still work for returned errors.
                PropTypeError.prototype = Error.prototype;

                function createChainableTypeChecker(validate) {
                    if (process.env.NODE_ENV !== 'production') {
                        var manualPropTypeCallCache = {};
                    }

                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                        componentName = componentName || ANONYMOUS;
                        propFullName = propFullName || propName;
                        if (process.env.NODE_ENV !== 'production') {
                            if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
                                var cacheKey = componentName + ':' + propName;
                                if (!manualPropTypeCallCache[cacheKey]) {
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
                                    manualPropTypeCallCache[cacheKey] = true;
                                }
                            }
                        }
                        if (props[propName] == null) {
                            var locationName = ReactPropTypeLocationNames[location];
                            if (isRequired) {
                                if (props[propName] === null) {
                                    return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                                }
                                return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                            }
                            return null;
                        } else {
                            return validate(props, propName, componentName, location, propFullName);
                        }
                    }

                    var chainedCheckType = checkType.bind(null, false);
                    chainedCheckType.isRequired = checkType.bind(null, true);

                    return chainedCheckType;
                }

                function createPrimitiveTypeChecker(expectedType) {
                    function validate(props, propName, componentName, location, propFullName, secret) {
                        var propValue = props[propName];
                        var propType = getPropType(propValue);
                        if (propType !== expectedType) {
                            var locationName = ReactPropTypeLocationNames[location];
                            // `propValue` being instance of, say, date/regexp, pass the 'object'
                            // check, but we can offer a more precise error message here rather than
                            // 'of type `object`'.
                            var preciseType = getPreciseType(propValue);

                            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }

                function createAnyTypeChecker() {
                    return createChainableTypeChecker(emptyFunction.thatReturns(null));
                }

                function createArrayOfTypeChecker(typeChecker) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if (typeof typeChecker !== 'function') {
                            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
                        }
                        var propValue = props[propName];
                        if (!Array.isArray(propValue)) {
                            var locationName = ReactPropTypeLocationNames[location];
                            var propType = getPropType(propValue);
                            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
                        }
                        for (var i = 0; i < propValue.length; i++) {
                            var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                            if (error instanceof Error) {
                                return error;
                            }
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }

                function createElementTypeChecker() {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName];
                        if (!ReactElement.isValidElement(propValue)) {
                            var locationName = ReactPropTypeLocationNames[location];
                            var propType = getPropType(propValue);
                            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }

                function createInstanceTypeChecker(expectedClass) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if (!(props[propName] instanceof expectedClass)) {
                            var locationName = ReactPropTypeLocationNames[location];
                            var expectedClassName = expectedClass.name || ANONYMOUS;
                            var actualClassName = getClassName(props[propName]);
                            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }

                function createEnumTypeChecker(expectedValues) {
                    if (!Array.isArray(expectedValues)) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
                        return emptyFunction.thatReturnsNull;
                    }

                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName];
                        for (var i = 0; i < expectedValues.length; i++) {
                            if (is(propValue, expectedValues[i])) {
                                return null;
                            }
                        }

                        var locationName = ReactPropTypeLocationNames[location];
                        var valuesString = JSON.stringify(expectedValues);
                        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
                    }
                    return createChainableTypeChecker(validate);
                }

                function createObjectOfTypeChecker(typeChecker) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if (typeof typeChecker !== 'function') {
                            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
                        }
                        var propValue = props[propName];
                        var propType = getPropType(propValue);
                        if (propType !== 'object') {
                            var locationName = ReactPropTypeLocationNames[location];
                            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
                        }
                        for (var key in propValue) {
                            if (propValue.hasOwnProperty(key)) {
                                var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                                if (error instanceof Error) {
                                    return error;
                                }
                            }
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }

                function createUnionTypeChecker(arrayOfTypeCheckers) {
                    if (!Array.isArray(arrayOfTypeCheckers)) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
                        return emptyFunction.thatReturnsNull;
                    }

                    function validate(props, propName, componentName, location, propFullName) {
                        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                            var checker = arrayOfTypeCheckers[i];
                            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
                                return null;
                            }
                        }

                        var locationName = ReactPropTypeLocationNames[location];
                        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
                    }
                    return createChainableTypeChecker(validate);
                }

                function createNodeChecker() {
                    function validate(props, propName, componentName, location, propFullName) {
                        if (!isNode(props[propName])) {
                            var locationName = ReactPropTypeLocationNames[location];
                            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }

                function createShapeTypeChecker(shapeTypes) {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName];
                        var propType = getPropType(propValue);
                        if (propType !== 'object') {
                            var locationName = ReactPropTypeLocationNames[location];
                            return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
                        }
                        for (var key in shapeTypes) {
                            var checker = shapeTypes[key];
                            if (!checker) {
                                continue;
                            }
                            var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                            if (error) {
                                return error;
                            }
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }

                function isNode(propValue) {
                    switch (typeof propValue) {
                        case 'number':
                        case 'string':
                        case 'undefined':
                            return true;
                        case 'boolean':
                            return !propValue;
                        case 'object':
                            if (Array.isArray(propValue)) {
                                return propValue.every(isNode);
                            }
                            if (propValue === null || ReactElement.isValidElement(propValue)) {
                                return true;
                            }

                            var iteratorFn = getIteratorFn(propValue);
                            if (iteratorFn) {
                                var iterator = iteratorFn.call(propValue);
                                var step;
                                if (iteratorFn !== propValue.entries) {
                                    while (!(step = iterator.next()).done) {
                                        if (!isNode(step.value)) {
                                            return false;
                                        }
                                    }
                                } else {
                                    // Iterator will provide entry [k,v] tuples rather than values.
                                    while (!(step = iterator.next()).done) {
                                        var entry = step.value;
                                        if (entry) {
                                            if (!isNode(entry[1])) {
                                                return false;
                                            }
                                        }
                                    }
                                }
                            } else {
                                return false;
                            }

                            return true;
                        default:
                            return false;
                    }
                }

                function isSymbol(propType, propValue) {
                    // Native Symbol.
                    if (propType === 'symbol') {
                        return true;
                    }

                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
                    if (propValue['@@toStringTag'] === 'Symbol') {
                        return true;
                    }

                    // Fallback for non-spec compliant Symbols which are polyfilled.
                    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
                        return true;
                    }

                    return false;
                }

                // Equivalent of `typeof` but with special handling for array and regexp.
                function getPropType(propValue) {
                    var propType = typeof propValue;
                    if (Array.isArray(propValue)) {
                        return 'array';
                    }
                    if (propValue instanceof RegExp) {
                        // Old webkits (at least until Android 4.0) return 'function' rather than
                        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
                        // passes PropTypes.object.
                        return 'object';
                    }
                    if (isSymbol(propType, propValue)) {
                        return 'symbol';
                    }
                    return propType;
                }

                // This handles more types than `getPropType`. Only used for error messages.
                // See `createPrimitiveTypeChecker`.
                function getPreciseType(propValue) {
                    var propType = getPropType(propValue);
                    if (propType === 'object') {
                        if (propValue instanceof Date) {
                            return 'date';
                        } else if (propValue instanceof RegExp) {
                            return 'regexp';
                        }
                    }
                    return propType;
                }

                // Returns class name of the object, if any.
                function getClassName(propValue) {
                    if (!propValue.constructor || !propValue.constructor.name) {
                        return ANONYMOUS;
                    }
                    return propValue.constructor.name;
                }

                module.exports = ReactPropTypes;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactElement": 165,
            "./ReactPropTypeLocationNames": 169,
            "./ReactPropTypesSecret": 171,
            "./getIteratorFn": 176,
            "_process": 28,
            "fbjs/lib/emptyFunction": 9,
            "fbjs/lib/warning": 24
        }],
        171: [function(_dereq_, module, exports) {
            arguments[4][99][0].apply(exports, arguments)
        }, {
            "dup": 99
        }],
        172: [function(_dereq_, module, exports) {

            var _assign = _dereq_('object-assign');

            var ReactComponent = _dereq_('./ReactComponent');
            var ReactNoopUpdateQueue = _dereq_('./ReactNoopUpdateQueue');

            var emptyObject = _dereq_('fbjs/lib/emptyObject');

            function ReactPureComponent(props, context, updater) {
                // Duplicated from ReactComponent.
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                // We initialize the default updater but the real one gets injected by the
                // renderer.
                this.updater = updater || ReactNoopUpdateQueue;
            }

            function ComponentDummy() {}
            ComponentDummy.prototype = ReactComponent.prototype;
            ReactPureComponent.prototype = new ComponentDummy();
            ReactPureComponent.prototype.constructor = ReactPureComponent;
            // Avoid an extra prototype jump for these methods.
            _assign(ReactPureComponent.prototype, ReactComponent.prototype);
            ReactPureComponent.prototype.isPureReactComponent = true;

            module.exports = ReactPureComponent;
        }, {
            "./ReactComponent": 161,
            "./ReactNoopUpdateQueue": 168,
            "fbjs/lib/emptyObject": 10,
            "object-assign": 27
        }],
        173: [function(_dereq_, module, exports) {
            arguments[4][107][0].apply(exports, arguments)
        }, {
            "dup": 107
        }],
        174: [function(_dereq_, module, exports) {
            (function(process) {

                var canDefineProperty = false;
                if (process.env.NODE_ENV !== 'production') {
                    try {
                        // $FlowFixMe https://github.com/facebook/flow/issues/285
                        Object.defineProperty({}, 'x', {
                            get: function() {}
                        });
                        canDefineProperty = true;
                    } catch (x) {
                        // IE will fail on defineProperty
                    }
                }

                module.exports = canDefineProperty;
            }).call(this, _dereq_('_process'))
        }, {
            "_process": 28
        }],
        175: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactPropTypeLocationNames = _dereq_('./ReactPropTypeLocationNames');
                var ReactPropTypesSecret = _dereq_('./ReactPropTypesSecret');

                var invariant = _dereq_('fbjs/lib/invariant');
                var warning = _dereq_('fbjs/lib/warning');

                var ReactComponentTreeHook;

                if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
                    // Temporary hack.
                    // Inline requires don't work well with Jest:
                    // https://github.com/facebook/react/issues/7240
                    // Remove the inline requires when we don't need them anymore:
                    // https://github.com/facebook/react/pull/7178
                    ReactComponentTreeHook = _dereq_('./ReactComponentTreeHook');
                }

                var loggedTypeFailures = {};

                function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
                    for (var typeSpecName in typeSpecs) {
                        if (typeSpecs.hasOwnProperty(typeSpecName)) {
                            var error;
                            // Prop type validation may throw. In case they do, we don't want to
                            // fail the render phase where it didn't fail before. So we log it.
                            // After these have been cleaned up, we'll let them throw.
                            try {
                                // This is intentionally an invariant that gets caught. It's the same
                                // behavior as without this statement except with a better message.
                                !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName): void 0;
                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                            } catch (ex) {
                                error = ex;
                            }
                            process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                                // Only monitor this failure once because there tends to be a lot of the
                                // same error.
                                loggedTypeFailures[error.message] = true;

                                var componentStackInfo = '';

                                if (process.env.NODE_ENV !== 'production') {
                                    if (!ReactComponentTreeHook) {
                                        ReactComponentTreeHook = _dereq_('./ReactComponentTreeHook');
                                    }
                                    if (debugID !== null) {
                                        componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
                                    } else if (element !== null) {
                                        componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
                                    }
                                }

                                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
                            }
                        }
                    }
                }

                module.exports = checkReactTypeSpec;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactComponentTreeHook": 162,
            "./ReactPropTypeLocationNames": 169,
            "./ReactPropTypesSecret": 171,
            "./reactProdInvariant": 178,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24
        }],
        176: [function(_dereq_, module, exports) {
            arguments[4][140][0].apply(exports, arguments)
        }, {
            "dup": 140
        }],
        177: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactElement = _dereq_('./ReactElement');

                var invariant = _dereq_('fbjs/lib/invariant');

                function onlyChild(children) {
                    !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
                    return children;
                }

                module.exports = onlyChild;
            }).call(this, _dereq_('_process'))
        }, {
            "./ReactElement": 165,
            "./reactProdInvariant": 178,
            "_process": 28,
            "fbjs/lib/invariant": 17
        }],
        178: [function(_dereq_, module, exports) {
            arguments[4][149][0].apply(exports, arguments)
        }, {
            "dup": 149
        }],
        179: [function(_dereq_, module, exports) {
            (function(process) {

                var _prodInvariant = _dereq_('./reactProdInvariant');

                var ReactCurrentOwner = _dereq_('./ReactCurrentOwner');
                var REACT_ELEMENT_TYPE = _dereq_('./ReactElementSymbol');

                var getIteratorFn = _dereq_('./getIteratorFn');
                var invariant = _dereq_('fbjs/lib/invariant');
                var KeyEscapeUtils = _dereq_('./KeyEscapeUtils');
                var warning = _dereq_('fbjs/lib/warning');

                var SEPARATOR = '.';
                var SUBSEPARATOR = ':';

                var didWarnAboutMaps = false;

                function getComponentKey(component, index) {
                    // Do some typechecking here since we call this blindly. We want to ensure
                    // that we don't block potential future ES APIs.
                    if (component && typeof component === 'object' && component.key != null) {
                        // Explicit key
                        return KeyEscapeUtils.escape(component.key);
                    }
                    // Implicit key determined by the index in the set
                    return index.toString(36);
                }

                function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
                    var type = typeof children;

                    if (type === 'undefined' || type === 'boolean') {
                        // All of the above are perceived as null.
                        children = null;
                    }

                    if (children === null || type === 'string' || type === 'number' ||
                        // The following is inlined from ReactElement. This means we can optimize
                        // some checks. React Fiber also inlines this logic for similar purposes.
                        type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
                        callback(traverseContext, children,
                            // If it's the only child, treat the name as if it was wrapped in an array
                            // so that it's consistent if the number of children grows.
                            nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
                        return 1;
                    }

                    var child;
                    var nextName;
                    var subtreeCount = 0; // Count of children found in the current subtree.
                    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

                    if (Array.isArray(children)) {
                        for (var i = 0; i < children.length; i++) {
                            child = children[i];
                            nextName = nextNamePrefix + getComponentKey(child, i);
                            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                        }
                    } else {
                        var iteratorFn = getIteratorFn(children);
                        if (iteratorFn) {
                            var iterator = iteratorFn.call(children);
                            var step;
                            if (iteratorFn !== children.entries) {
                                var ii = 0;
                                while (!(step = iterator.next()).done) {
                                    child = step.value;
                                    nextName = nextNamePrefix + getComponentKey(child, ii++);
                                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                                }
                            } else {
                                if (process.env.NODE_ENV !== 'production') {
                                    var mapsAsChildrenAddendum = '';
                                    if (ReactCurrentOwner.current) {
                                        var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                                        if (mapsAsChildrenOwnerName) {
                                            mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                                        }
                                    }
                                    process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
                                    didWarnAboutMaps = true;
                                }
                                // Iterator will provide entry [k,v] tuples rather than values.
                                while (!(step = iterator.next()).done) {
                                    var entry = step.value;
                                    if (entry) {
                                        child = entry[1];
                                        nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                                        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                                    }
                                }
                            }
                        } else if (type === 'object') {
                            var addendum = '';
                            if (process.env.NODE_ENV !== 'production') {
                                addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
                                if (children._isReactElement) {
                                    addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
                                }
                                if (ReactCurrentOwner.current) {
                                    var name = ReactCurrentOwner.current.getName();
                                    if (name) {
                                        addendum += ' Check the render method of `' + name + '`.';
                                    }
                                }
                            }
                            var childrenString = String(children);
                            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
                        }
                    }

                    return subtreeCount;
                }

                function traverseAllChildren(children, callback, traverseContext) {
                    if (children == null) {
                        return 0;
                    }

                    return traverseAllChildrenImpl(children, '', callback, traverseContext);
                }

                module.exports = traverseAllChildren;
            }).call(this, _dereq_('_process'))
        }, {
            "./KeyEscapeUtils": 156,
            "./ReactCurrentOwner": 163,
            "./ReactElementSymbol": 166,
            "./getIteratorFn": 176,
            "./reactProdInvariant": 178,
            "_process": 28,
            "fbjs/lib/invariant": 17,
            "fbjs/lib/warning": 24
        }],
        180: [function(_dereq_, module, exports) {

            var Aggregations = module.exports = {
                toAggregateFunc: function(func) {
                    if (func) {
                        if (typeof func === 'string' && Aggregations[func]) {
                            return Aggregations[func];
                        } else if (typeof func === 'function') {
                            return func;
                        } else {
                            return Aggregations.sum;
                        }
                    } else {
                        return Aggregations.sum;
                    }
                },
                count: function(datafield, intersection, datasource) {
                    return intersection === 'all' ? datasource.length : intersection.length;
                },
                sum: function(datafield, intersection, datasource) {
                    var sum = 0;
                    forEachIntersection(datafield, intersection, datasource, function(val) {
                        sum += val;
                    });

                    return sum;
                },
                min: function(datafield, intersection, datasource) {
                    var min = null;
                    forEachIntersection(datafield, intersection, datasource, function(val) {
                        if (min == null || val < min) {
                            min = val;
                        }
                    });
                    return min;
                },
                max: function(datafield, intersection, datasource) {
                    var max = null;
                    forEachIntersection(datafield, intersection, datasource, function(val) {
                        if (max == null || val > max) {
                            max = val;
                        }
                    });
                    return max;
                },
                avg: function(datafield, intersection, datasource) {
                    var avg = 0;
                    var len = (intersection === 'all' ? datasource : intersection).length;
                    if (len > 0) {
                        forEachIntersection(datafield, intersection, datasource, function(val) {
                            avg += val;
                        });
                        avg /= len;
                    }
                    return avg;
                },
                prod: function(datafield, intersection, datasource) {
                    var prod;
                    var len = (intersection === 'all' ? datasource : intersection).length;
                    if (len > 0) {
                        prod = 1;
                        forEachIntersection(datafield, intersection, datasource, function(val) {
                            prod *= val;
                        });
                    }
                    return prod;
                },
                stdev: function(datafield, intersection, datasource) {
                    return Math.sqrt(calcVariance(datafield, intersection, datasource, false));
                },
                stdevp: function(datafield, intersection, datasource) {
                    return Math.sqrt(calcVariance(datafield, intersection, datasource, true));
                },
                var: function(datafield, intersection, datasource) {
                    return calcVariance(datafield, intersection, datasource, false);
                },
                varp: function(datafield, intersection, datasource) {
                    return calcVariance(datafield, intersection, datasource, true);
                }
            };

            function calcVariance(datafield, intersection, datasource, population) {
                var variance = 0;
                var avg = 0;
                var len = (intersection === 'all' ? datasource : intersection).length;
                if (len > 0) {
                    if (population || len > 1) {
                        forEachIntersection(datafield, intersection, datasource, function(val) {
                            avg += val;
                        });
                        avg /= len;
                        forEachIntersection(datafield, intersection, datasource, function(val) {
                            variance += (val - avg) * (val - avg);
                        });
                        variance = variance / (population ? len : len - 1);
                    } else {
                        variance = NaN;
                    }
                }
                return variance;
            }

            function forEachIntersection(datafield, intersection, datasource, callback) {
                var all = intersection === 'all';
                intersection = all ? datasource : intersection;
                if (intersection.length > 0) {
                    for (var i = 0; i < intersection.length; i++) {
                        callback((all ? intersection[i] : datasource[intersection[i]])[datafield]);
                    }
                }
            }

        }, {}],
        181: [function(_dereq_, module, exports) {

            var utils = _dereq_('./orb.utils');
            var Dimension = _dereq_('./orb.dimension');

            var AxeType = {
                COLUMNS: 1,
                ROWS: 2,
                DATA: 3
            };

            module.exports = function(pgrid, type) {

                var self = this;
                var dimid = 0;

                if (pgrid != null && pgrid.config != null) {


                    this.pgrid = pgrid;


                    this.type = type;


                    this.fields = (function() {
                        switch (type) {
                            case AxeType.COLUMNS:
                                return self.pgrid.config.columnFields;
                            case AxeType.ROWS:
                                return self.pgrid.config.rowFields;
                            case AxeType.DATA:
                                return self.pgrid.config.dataFields;
                            default:
                                return [];
                        }
                    }());


                    this.dimensionsCount = null;


                    this.root = null;


                    this.dimensionsByDepth = null;

                    this.update = function() {
                        self.dimensionsCount = self.fields.length;
                        self.root = new Dimension(++dimid, null, null, null, self.dimensionsCount + 1, true);

                        self.dimensionsByDepth = {};
                        for (var depth = 1; depth <= self.dimensionsCount; depth++) {
                            self.dimensionsByDepth[depth] = [];
                        }

                        // fill data
                        fill();

                        // initial sort
                        for (var findex = 0; findex < self.fields.length; findex++) {
                            var ffield = self.fields[findex];
                            if (ffield.sort.order === 'asc' || ffield.sort.order === 'desc') {
                                self.sort(ffield, true);
                            }
                        }
                    };

                    this.sort = function(field, donottoggle) {
                        if (field != null) {
                            if (donottoggle !== true) {
                                if (field.sort.order !== 'asc') {
                                    field.sort.order = 'asc';
                                } else {
                                    field.sort.order = 'desc';
                                }
                            }

                            var depth = self.dimensionsCount - getfieldindex(field);
                            var parents = depth === self.dimensionsCount ? [self.root] : self.dimensionsByDepth[depth + 1];
                            for (var i = 0; i < parents.length; i++) {
                                parents[i].values.sort();
                                if (field.sort.order === 'desc') {
                                    parents[i].values.reverse();
                                }
                            }
                        }
                    };
                }

                function getfieldindex(field) {
                    for (var i = 0; i < self.fields.length; i++) {
                        if (self.fields[i].name === field.name) {
                            return i;
                        }
                    }
                    return -1;
                }


                function fill() {

                    if (self.pgrid.filteredDataSource != null && self.dimensionsCount > 0) {

                        var datasource = self.pgrid.filteredDataSource;
                        if (datasource != null && utils.isArray(datasource) && datasource.length > 0) {
                            for (var rowIndex = 0, dataLength = datasource.length; rowIndex < dataLength; rowIndex++) {
                                var row = datasource[rowIndex];
                                var dim = self.root;
                                for (var findex = 0; findex < self.dimensionsCount; findex++) {
                                    var depth = self.dimensionsCount - findex;
                                    var subfield = self.fields[findex];
                                    var subvalue = row[subfield.name];
                                    var subdimvals = dim.subdimvals;

                                    if (subdimvals[subvalue] !== undefined) {
                                        dim = subdimvals[subvalue];
                                    } else {
                                        dim.values.push(subvalue);
                                        dim = new Dimension(++dimid, dim, subvalue, subfield, depth, false, findex == self.dimensionsCount - 1);
                                        subdimvals[subvalue] = dim;
                                        dim.rowIndexes = [];
                                        self.dimensionsByDepth[depth].push(dim);
                                    }

                                    dim.rowIndexes.push(rowIndex);
                                }
                            }
                        }
                    }
                }
            };

            module.exports.Type = AxeType;

        }, {
            "./orb.dimension": 183,
            "./orb.utils": 195
        }],
        182: [function(_dereq_, module, exports) {

            var utils = _dereq_('./orb.utils');
            var axe = _dereq_('./orb.axe');
            var aggregation = _dereq_('./orb.aggregation');
            var filtering = _dereq_('./orb.filtering');
            var themeManager = _dereq_('./orb.themes');

            function getpropertyvalue(property, configs, defaultvalue) {
                for (var i = 0; i < configs.length; i++) {
                    if (configs[i][property] != null) {
                        return configs[i][property];
                    }
                }
                return defaultvalue;
            }

            function mergefieldconfigs() {

                var merged = {
                    configs: [],
                    sorts: [],
                    subtotals: [],
                    functions: []
                };

                for (var i = 0; i < arguments.length; i++) {
                    var nnconfig = arguments[i] || {};
                    merged.configs.push(nnconfig);
                    merged.sorts.push(nnconfig.sort || {});
                    merged.subtotals.push(nnconfig.subTotal || {});
                    merged.functions.push({
                        aggregateFuncName: nnconfig.aggregateFuncName,
                        aggregateFunc: i === 0 ? nnconfig.aggregateFunc : (nnconfig.aggregateFunc ? nnconfig.aggregateFunc() : null),
                        formatFunc: i === 0 ? nnconfig.formatFunc : (nnconfig.formatFunc ? nnconfig.formatFunc() : null),
                    });
                }

                return merged;
            }

            function createfield(rootconfig, axetype, fieldconfig, defaultfieldconfig) {

                var axeconfig;
                var fieldAxeconfig;

                if (defaultfieldconfig) {
                    switch (axetype) {
                        case axe.Type.ROWS:
                            axeconfig = rootconfig.rowSettings;
                            fieldAxeconfig = defaultfieldconfig.rowSettings;
                            break;
                        case axe.Type.COLUMNS:
                            axeconfig = rootconfig.columnSettings;
                            fieldAxeconfig = defaultfieldconfig.columnSettings;
                            break;
                        case axe.Type.DATA:
                            axeconfig = rootconfig.dataSettings;
                            fieldAxeconfig = defaultfieldconfig.dataSettings;
                            break;
                        default:
                            axeconfig = null;
                            fieldAxeconfig = null;
                            break;
                    }
                } else {
                    axeconfig = null;
                    fieldAxeconfig = null;
                }

                var merged = mergefieldconfigs(fieldconfig, fieldAxeconfig, axeconfig, defaultfieldconfig, rootconfig);

                return new Field({
                    name: getpropertyvalue('name', merged.configs, ''),

                    caption: getpropertyvalue('caption', merged.configs, ''),

                    sort: {
                        order: getpropertyvalue('order', merged.sorts, null),
                        customfunc: getpropertyvalue('customfunc', merged.sorts, null)
                    },
                    subTotal: {
                        visible: getpropertyvalue('visible', merged.subtotals, true),
                        collapsible: getpropertyvalue('collapsible', merged.subtotals, true),
                        collapsed: getpropertyvalue('collapsed', merged.subtotals, false) && getpropertyvalue('collapsible', merged.subtotals, true)
                    },

                    aggregateFuncName: getpropertyvalue('aggregateFuncName', merged.functions, 'sum'),
                    aggregateFunc: getpropertyvalue('aggregateFunc', merged.functions, aggregation.sum),
                    formatFunc: getpropertyvalue('formatFunc', merged.functions, null)
                }, false);
            }

            function GrandTotalConfig(options) {

                options = options || {};

                this.rowsvisible = options.rowsvisible !== undefined ? options.rowsvisible : true;
                this.columnsvisible = options.columnsvisible !== undefined ? options.columnsvisible : true;
            }

            function SubTotalConfig(options, setdefaults) {

                var defaults = {
                    visible: setdefaults === true ? true : undefined,
                    collapsible: setdefaults === true ? true : undefined,
                    collapsed: setdefaults === true ? false : undefined
                };
                options = options || {};

                this.visible = options.visible !== undefined ? options.visible : defaults.visible;
                this.collapsible = options.collapsible !== undefined ? options.collapsible : defaults.collapsible;
                this.collapsed = options.collapsed !== undefined ? options.collapsed : defaults.collapsed;
            }

            function SortConfig(options) {
                options = options || {};

                this.order = options.order;
                this.customfunc = options.customfunc;
            }

            var Field = module.exports.field = function(options, createSubOptions) {

                options = options || {};

                // field name
                this.name = options.name;

                // shared settings
                this.caption = options.caption || this.name;

                // rows & columns settings
                this.sort = new SortConfig(options.sort);
                this.subTotal = new SubTotalConfig(options.subTotal);

                // data settings
                var _aggregatefunc;
                var _formatfunc;

                function defaultFormatFunc(val) {
                    return val != null ? val.toString() : '';
                }

                this.aggregateFunc = function(func) {
                    if (func) {
                        _aggregatefunc = aggregation.toAggregateFunc(func);
                    } else {
                        return _aggregatefunc;
                    }
                };

                this.formatFunc = function(func) {
                    if (func) {
                        _formatfunc = func;
                    } else {
                        return _formatfunc;
                    }
                };

                this.aggregateFuncName = options.aggregateFuncName ||
                    (options.aggregateFunc ?
                        (utils.isString(options.aggregateFunc) ?
                            options.aggregateFunc :
                            'custom') :
                        null);

                this.aggregateFunc(options.aggregateFunc);
                this.formatFunc(options.formatFunc || defaultFormatFunc);

                if (createSubOptions !== false) {
                    (this.rowSettings = new Field(options.rowSettings, false)).name = this.name;
                    (this.columnSettings = new Field(options.columnSettings, false)).name = this.name;
                    (this.dataSettings = new Field(options.dataSettings, false)).name = this.name;
                }
            };

            module.exports.config = function(config) {

                var self = this;

                this.dataSource = config.dataSource || [];
                this.canMoveFields = config.canMoveFields !== undefined ? !!config.canMoveFields : true;
                this.dataHeadersLocation = config.dataHeadersLocation === 'columns' ? 'columns' : 'rows';
                this.grandTotal = new GrandTotalConfig(config.grandTotal);
                this.subTotal = new SubTotalConfig(config.subTotal, true);
                this.width = config.width;
                this.height = config.height;
                this.toolbar = config.toolbar;
                this.buttonClass = config.buttonClass;
                this.theme = themeManager;

                themeManager.current(config.theme);
                themeManager.buttonClass(config.buttonClass);

                this.rowSettings = new Field(config.rowSettings, false);
                this.columnSettings = new Field(config.columnSettings, false);
                this.dataSettings = new Field(config.dataSettings, false);

                // datasource field names
                this.dataSourceFieldNames = [];
                // datasource field captions
                this.dataSourceFieldCaptions = [];

                this.captionToName = function(caption) {
                    var fcaptionIndex = self.dataSourceFieldCaptions.indexOf(caption);
                    return fcaptionIndex >= 0 ? self.dataSourceFieldNames[fcaptionIndex] : caption;
                };

                this.nameToCaption = function(name) {
                    var fnameIndex = self.dataSourceFieldNames.indexOf(name);
                    return fnameIndex >= 0 ? self.dataSourceFieldCaptions[fnameIndex] : name;
                };

                this.setTheme = function(newTheme) {
                    return self.theme.current() !== self.theme.current(newTheme);
                };

                this.allFields = (config.fields || []).map(function(fieldconfig) {
                    var f = new Field(fieldconfig);
                    // map fields names to captions
                    self.dataSourceFieldNames.push(f.name);
                    self.dataSourceFieldCaptions.push(f.caption);
                    return f;
                });

                function ensureFieldConfig(obj) {
                    if (typeof obj === 'string') {
                        return {
                            name: self.captionToName(obj)
                        };
                    }
                    return obj;
                }

                this.rowFields = (config.rows || []).map(function(fieldconfig) {
                    fieldconfig = ensureFieldConfig(fieldconfig);
                    return createfield(self, axe.Type.ROWS, fieldconfig, getfield(self.allFields, fieldconfig.name));
                });

                this.columnFields = (config.columns || []).map(function(fieldconfig) {
                    fieldconfig = ensureFieldConfig(fieldconfig);
                    return createfield(self, axe.Type.COLUMNS, fieldconfig, getfield(self.allFields, fieldconfig.name));
                });

                this.dataFields = (config.data || []).map(function(fieldconfig) {
                    fieldconfig = ensureFieldConfig(fieldconfig);
                    return createfield(self, axe.Type.DATA, fieldconfig, getfield(self.allFields, fieldconfig.name));
                });

                this.dataFieldsCount = this.dataFields ? (this.dataFields.length || 1) : 1;

                var runtimeVisibility = {
                    subtotals: {
                        rows: self.rowSettings.subTotal.visible !== undefined ? self.rowSettings.subTotal.visible : true,
                        columns: self.columnSettings.subTotal.visible !== undefined ? self.columnSettings.subTotal.visible : true
                    }
                };

                function getfield(axefields, fieldname) {
                    var fieldindex = getfieldindex(axefields, fieldname);
                    if (fieldindex > -1) {
                        return axefields[fieldindex];
                    }
                    return null;
                }

                function getfieldindex(axefields, fieldname) {
                    for (var fi = 0; fi < axefields.length; fi++) {
                        if (axefields[fi].name === fieldname) {
                            return fi;
                        }
                    }
                    return -1;
                }

                this.getField = function(fieldname) {
                    return getfield(self.allFields, fieldname);
                };

                this.getRowField = function(fieldname) {
                    return getfield(self.rowFields, fieldname);
                };

                this.getColumnField = function(fieldname) {
                    return getfield(self.columnFields, fieldname);
                };

                this.getDataField = function(fieldname) {
                    return getfield(self.dataFields, fieldname);
                };

                this.availablefields = function() {
                    return self.allFields.filter(function(field) {
                        var notequalfield = function(otherfield) {
                            return field.name !== otherfield.name;
                        };

                        return self.dataFields.every(notequalfield) &&
                            self.rowFields.every(notequalfield) &&
                            self.columnFields.every(notequalfield);
                    });
                };

                this.getDataSourceFieldCaptions = function() {
                    var row0;
                    if (self.dataSource && (row0 = self.dataSource[0])) {
                        var fieldNames = utils.ownProperties(row0);
                        var headers = [];
                        for (var i = 0; i < fieldNames.length; i++) {
                            headers.push(self.nameToCaption(fieldNames[i]));
                        }
                        return headers;
                    }
                    return null;
                };

                this.getPreFilters = function() {
                    var prefilters = {};
                    if (config.preFilters) {
                        utils.ownProperties(config.preFilters).forEach(function(filteredField) {
                            var prefilterConfig = config.preFilters[filteredField];
                            if (utils.isArray(prefilterConfig)) {
                                prefilters[self.captionToName(filteredField)] = new filtering.expressionFilter(null, null, prefilterConfig, false);
                            } else {
                                var opname = utils.ownProperties(prefilterConfig)[0];
                                if (opname) {
                                    prefilters[self.captionToName(filteredField)] = new filtering.expressionFilter(opname, prefilterConfig[opname]);
                                }
                            }
                        });
                    }

                    return prefilters;
                };

                this.moveField = function(fieldname, oldaxetype, newaxetype, position) {

                    var oldaxe, oldposition;
                    var newaxe;
                    var fieldConfig;
                    var defaultFieldConfig = getfield(self.allFields, fieldname);

                    if (defaultFieldConfig) {

                        switch (oldaxetype) {
                            case axe.Type.ROWS:
                                oldaxe = self.rowFields;
                                break;
                            case axe.Type.COLUMNS:
                                oldaxe = self.columnFields;
                                break;
                            case axe.Type.DATA:
                                oldaxe = self.dataFields;
                                break;
                            default:
                                break;
                        }

                        switch (newaxetype) {
                            case axe.Type.ROWS:
                                newaxe = self.rowFields;
                                fieldConfig = self.getRowField(fieldname);
                                break;
                            case axe.Type.COLUMNS:
                                newaxe = self.columnFields;
                                fieldConfig = self.getColumnField(fieldname);
                                break;
                            case axe.Type.DATA:
                                newaxe = self.dataFields;
                                fieldConfig = self.getDataField(fieldname);
                                break;
                            default:
                                break;
                        }

                        if (oldaxe || newaxe) {

                            var newAxeSubtotalsState = self.areSubtotalsVisible(newaxetype);

                            if (oldaxe) {
                                oldposition = getfieldindex(oldaxe, fieldname);
                                if (oldaxetype === newaxetype) {
                                    if (oldposition == oldaxe.length - 1 &&
                                        position == null ||
                                        oldposition === position - 1) {
                                        return false;
                                    }
                                }
                                oldaxe.splice(oldposition, 1);
                            }

                            var field = createfield(
                                self,
                                newaxetype,
                                fieldConfig,
                                defaultFieldConfig);

                            if (!newAxeSubtotalsState && field.subTotal.visible !== false) {
                                field.subTotal.visible = null;
                            }

                            if (newaxe) {
                                if (position != null) {
                                    newaxe.splice(position, 0, field);
                                } else {
                                    newaxe.push(field);
                                }
                            }

                            // update data fields count
                            self.dataFieldsCount = self.dataFields ? (self.dataFields.length || 1) : 1;

                            return true;
                        }
                    }
                };

                this.toggleSubtotals = function(axetype) {

                    var i;
                    var axeFields;
                    var newState = !self.areSubtotalsVisible(axetype);

                    if (axetype === axe.Type.ROWS) {
                        runtimeVisibility.subtotals.rows = newState;
                        axeFields = self.rowFields;
                    } else if (axetype === axe.Type.COLUMNS) {
                        runtimeVisibility.subtotals.columns = newState;
                        axeFields = self.columnFields;
                    } else {
                        return false;
                    }

                    newState = newState === false ? null : true;
                    for (i = 0; i < axeFields.length; i++) {
                        if (axeFields[i].subTotal.visible !== false) {
                            axeFields[i].subTotal.visible = newState;
                        }
                    }
                    return true;
                };

                this.areSubtotalsVisible = function(axetype) {
                    if (axetype === axe.Type.ROWS) {
                        return runtimeVisibility.subtotals.rows;
                    } else if (axetype === axe.Type.COLUMNS) {
                        return runtimeVisibility.subtotals.columns;
                    } else {
                        return null;
                    }
                };

                this.toggleGrandtotal = function(axetype) {
                    var newState = !self.isGrandtotalVisible(axetype);

                    if (axetype === axe.Type.ROWS) {
                        self.grandTotal.rowsvisible = newState;
                    } else if (axetype === axe.Type.COLUMNS) {
                        self.grandTotal.columnsvisible = newState;
                    } else {
                        return false;
                    }
                    return true;
                };

                this.isGrandtotalVisible = function(axetype) {
                    if (axetype === axe.Type.ROWS) {
                        return self.grandTotal.rowsvisible;
                    } else if (axetype === axe.Type.COLUMNS) {
                        return self.grandTotal.columnsvisible;
                    } else {
                        return false;
                    }
                };
            };
        }, {
            "./orb.aggregation": 180,
            "./orb.axe": 181,
            "./orb.filtering": 185,
            "./orb.themes": 189,
            "./orb.utils": 195
        }],
        183: [function(_dereq_, module, exports) {

            module.exports = function(id, parent, value, field, depth, isRoot, isLeaf) {

                var self = this;

                this.id = id;

                this.parent = parent;

                this.value = value;

                this.isRoot = isRoot;

                this.isLeaf = isLeaf;

                this.field = field;

                this.depth = depth;

                this.values = [];

                this.subdimvals = {};

                this.rowIndexes = null;

                this.getRowIndexes = function(result) {
                    if (self.rowIndexes == null) {
                        self.rowIndexes = [];
                        for (var i = 0; i < self.values.length; i++) {
                            self.subdimvals[self.values[i]].getRowIndexes(self.rowIndexes);
                        }
                    }
                    if (result != null) {
                        for (var j = 0; j < self.rowIndexes.length; j++) {
                            result.push(self.rowIndexes[j]);
                        }
                        return result;
                    } else {
                        return self.rowIndexes;
                    }
                };
            };

        }, {}],
        184: [function(_dereq_, module, exports) {






            var utils = _dereq_('./orb.utils');
            var uiheaders = _dereq_('./orb.ui.header');
            var themeManager = _dereq_('./orb.themes');

            var uriHeader = 'data:application/vnd.ms-excel;base64,';
            var docHeader = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' +
                '<head>' +
                '<meta http-equiv=Content-Type content="text/html; charset=UTF-8">' +
                '<!--[if gte mso 9]><xml>' +
                ' <x:ExcelWorkbook>' +
                '  <x:ExcelWorksheets>' +
                '   <x:ExcelWorksheet>' +
                '    <x:Name>###sheetname###</x:Name>' +
                '    <x:WorksheetOptions>' +
                '     <x:ProtectContents>False</x:ProtectContents>' +
                '     <x:ProtectObjects>False</x:ProtectObjects>' +
                '     <x:ProtectScenarios>False</x:ProtectScenarios>' +
                '    </x:WorksheetOptions>' +
                '   </x:ExcelWorksheet>' +
                '  </x:ExcelWorksheets>' +
                '  <x:ProtectStructure>False</x:ProtectStructure>' +
                '  <x:ProtectWindows>False</x:ProtectWindows>' +
                ' </x:ExcelWorkbook>' +
                '</xml><![endif]-->' +
                '</head>' +
                '<body>';
            var docFooter = '</body></html>';

            module.exports = function(pgridwidget) {

                var config = pgridwidget.pgrid.config;

                var currTheme = themeManager.current();
                currTheme = currTheme === 'bootstrap' ? 'white' : currTheme;
                var override = currTheme === 'white';

                var buttonTextColor = override ? 'black' : 'white';
                var themeColor = themeManager.themes[currTheme];
                var themeFadeout = themeManager.utils.fadeoutColor(themeColor, 0.1);

                var buttonStyle = 'style="font-weight: bold; color: ' + buttonTextColor + '; background-color: ' + themeColor + ';" bgcolor="' + themeColor + '"';
                var headerStyle = 'style="background-color: ' + themeFadeout + ';" bgcolor="' + themeFadeout + '"';

                function createButtonCell(caption) {
                    return '<td ' + buttonStyle + '><font color="' + buttonTextColor + '">' + caption + '</font></td>';
                }

                function createButtons(buttons, cellsCountBefore, cellsCountAfter, prefix) {
                    var i;
                    var str = prefix || '<tr>';
                    for (i = 0; i < cellsCountBefore; i++) {
                        str += '<td></td>';
                    }

                    str += buttons.reduce(function(tr, field) {
                        return (tr += createButtonCell(field.caption));
                    }, '');

                    for (i = 0; i < cellsCountAfter; i++) {
                        str += '<td></td>';
                    }
                    return str + '</tr>';
                }

                var cellsHorizontalCount = Math.max(config.dataFields.length + 1, pgridwidget.layout.pivotTable.width);

                var dataFields = createButtons(config.dataFields,
                    0,
                    cellsHorizontalCount - config.dataFields.length,
                    '<tr><td><font color="#ccc">Data</font></td>'
                );

                var sep = '<tr><td style="height: 22px;" colspan="' + cellsHorizontalCount + '"></td></tr>';

                var columnFields = createButtons(config.columnFields,
                    pgridwidget.layout.rowHeaders.width,
                    cellsHorizontalCount - (pgridwidget.layout.rowHeaders.width + config.columnFields.length)
                );

                var columnHeaders = (function() {
                    var str = '';
                    var j;
                    for (var i = 0; i < pgridwidget.columns.headers.length; i++) {
                        var currRow = pgridwidget.columns.headers[i];
                        var rowStr = '<tr>';
                        if (i < pgridwidget.columns.headers.length - 1) {
                            for (j = 0; j < pgridwidget.layout.rowHeaders.width; j++) {
                                rowStr += '<td></td>';
                            }
                        } else {
                            rowStr += config.rowFields.reduce(function(tr, field) {
                                return (tr += createButtonCell(field.caption));
                            }, '');
                        }

                        rowStr += currRow.reduce(function(tr, header) {
                            var value = header.type === uiheaders.HeaderType.DATA_HEADER ? header.value.caption : header.value;
                            return (tr += '<td ' + headerStyle + ' colspan="' + header.hspan(true) + '" rowspan="' + header.vspan(true) + '">' + value + '</td>');
                        }, '');
                        str += rowStr + '</tr>';
                    }
                    return str;
                }());

                var rowHeadersAndDataCells = (function() {
                    var str = '';
                    var j;
                    for (var i = 0; i < pgridwidget.rows.headers.length; i++) {
                        var currRow = pgridwidget.rows.headers[i];
                        var rowStr = '<tr>';
                        rowStr += currRow.reduce(function(tr, header) {
                            return (tr += '<td ' + headerStyle + ' colspan="' + header.hspan(true) + '" rowspan="' + header.vspan(true) + '">' + header.value + '</td>');
                        }, '');
                        var dataRow = pgridwidget.dataRows[i];
                        rowStr += dataRow.reduce(function(tr, dataCell, index) {
                            var formatFunc = config.dataFields[index = index % config.dataFields.length].formatFunc;
                            var value = dataCell.value == null ? '' : formatFunc ? formatFunc()(dataCell.value) : dataCell.value;
                            return (tr += '<td>' + value + '</td>');
                        }, '');
                        str += rowStr + '</tr>';
                    }
                    return str;
                }());

                function toBase64(str) {
                    return utils.btoa(unescape(encodeURIComponent(str)));
                }

                return uriHeader +
                    toBase64(docHeader +
                        '<table>' + dataFields + sep + columnFields + columnHeaders + rowHeadersAndDataCells + '</table>' +
                        docFooter);
            };
        }, {
            "./orb.themes": 189,
            "./orb.ui.header": 192,
            "./orb.utils": 195
        }],
        185: [function(_dereq_, module, exports) {

            var utils = _dereq_('./orb.utils');

            var filtering = module.exports = {
                ALL: '#All#',
                NONE: '#None#',
                BLANK: '#Blank#"'
            };

            filtering.expressionFilter = function(operator, term, staticValue, excludeStatic) {
                var self = this;

                this.operator = ops.get(operator);
                this.regexpMode = false;
                this.term = term || null;
                if (this.term && this.operator && this.operator.regexpSupported) {
                    if (utils.isRegExp(this.term)) {
                        this.regexpMode = true;
                        if (!this.term.ignoreCase) {
                            this.term = new RegExp(this.term.source, 'i');
                        }
                    }
                }

                this.staticValue = staticValue;
                this.excludeStatic = excludeStatic;

                this.test = function(value) {
                    if (utils.isArray(self.staticValue)) {
                        var found = self.staticValue.indexOf(value) >= 0;
                        return (self.excludeStatic && !found) || (!self.excludeStatic && found);
                    } else if (self.term) {
                        return self.operator.func(value, self.term);
                    } else if (self.staticValue === true || self.staticValue === filtering.ALL) {
                        return true;
                    } else if (self.staticValue === false || self.staticValue === filtering.NONE) {
                        return false;
                    } else {
                        return true;
                    }
                };

                this.isAlwaysTrue = function() {
                    return !(self.term || utils.isArray(self.staticValue) || self.staticValue === filtering.NONE || self.staticValue === false);
                };
            };

            var ops = filtering.Operators = {
                get: function(opname) {
                    switch (opname) {
                        case ops.MATCH.name:
                            return ops.MATCH;
                        case ops.NOTMATCH.name:
                            return ops.NOTMATCH;
                        case ops.EQ.name:
                            return ops.EQ;
                        case ops.NEQ.name:
                            return ops.NEQ;
                        case ops.GT.name:
                            return ops.GT;
                        case ops.GTE.name:
                            return ops.GTE;
                        case ops.LT.name:
                            return ops.LT;
                        case ops.LTE.name:
                            return ops.LTE;
                        default:
                            return ops.NONE;
                    }
                },
                NONE: null,
                MATCH: {
                    name: 'Matches',
                    func: function(value, term) {
                        if (value) {
                            return value.toString().search(utils.isRegExp(term) ? term : new RegExp(term, 'i')) >= 0;
                        } else {
                            return !(!!term);
                        }
                    },
                    regexpSupported: true
                },
                NOTMATCH: {
                    name: 'Does Not Match',
                    func: function(value, term) {
                        if (value) {
                            return value.toString().search(utils.isRegExp(term) ? term : new RegExp(term, 'i')) < 0;
                        } else {
                            return !!term;
                        }
                    },
                    regexpSupported: true
                },
                EQ: {
                    name: '=',
                    func: function(value, term) {
                        return value == term;
                    },
                    regexpSupported: false
                },
                NEQ: {
                    name: '<>',
                    func: function(value, term) {
                        return value != term;
                    },
                    regexpSupported: false
                },
                GT: {
                    name: '>',
                    func: function(value, term) {
                        return value > term;
                    },
                    regexpSupported: false
                },
                GTE: {
                    name: '>=',
                    func: function(value, term) {
                        return value >= term;
                    },
                    regexpSupported: false
                },
                LT: {
                    name: '<',
                    func: function(value, term) {
                        return value < term;
                    },
                    regexpSupported: false
                },
                LTE: {
                    name: '<=',
                    func: function(value, term) {
                        return value <= term;
                    },
                    regexpSupported: false
                }
            };

        }, {
            "./orb.utils": 195
        }],
        186: [function(_dereq_, module, exports) {

            var axe = _dereq_('./orb.axe');
            var configuration = _dereq_('./orb.config').config;
            var filtering = _dereq_('./orb.filtering');
            var query = _dereq_('./orb.query');
            var utils = _dereq_('./orb.utils');

            module.exports = function(config) {

                var defaultfield = {
                    name: '#undefined#'
                };

                var self = this;
                var _iCache;


                this.config = new configuration(config);
                this.filters = self.config.getPreFilters();
                this.filteredDataSource = self.config.dataSource;

                this.rows = new axe(self, axe.Type.ROWS);
                this.columns = new axe(self, axe.Type.COLUMNS);
                this.dataMatrix = {};

                function refresh(refreshFilters) {
                    if (refreshFilters !== false) {
                        refreshFilteredDataSource();
                    }
                    self.rows.update();
                    self.columns.update();
                    computeValues();
                }

                function refreshFilteredDataSource() {
                    var filterFields = utils.ownProperties(self.filters);
                    if (filterFields.length > 0) {
                        self.filteredDataSource = [];

                        for (var i = 0; i < self.config.dataSource.length; i++) {
                            var row = self.config.dataSource[i];
                            var exclude = false;
                            for (var fi = 0; fi < filterFields.length; fi++) {
                                var fieldname = filterFields[fi];
                                var fieldFilter = self.filters[fieldname];

                                if (fieldFilter && !fieldFilter.test(row[fieldname])) {
                                    exclude = true;
                                    break;
                                }
                            }
                            if (!exclude) {
                                self.filteredDataSource.push(row);
                            }
                        }
                    } else {
                        self.filteredDataSource = self.config.dataSource;
                    }
                }

                this.moveField = function(fieldname, oldaxetype, newaxetype, position) {
                    if (self.config.moveField(fieldname, oldaxetype, newaxetype, position)) {
                        refresh(false);
                        return true;
                    }
                    return false;
                };

                this.applyFilter = function(fieldname, operator, term, staticValue, excludeStatic) {
                    self.filters[fieldname] = new filtering.expressionFilter(operator, term, staticValue, excludeStatic);
                    refresh();
                };

                this.refreshData = function(data) {
                    self.config.dataSource = data;
                    refresh();
                };

                this.getFieldValues = function(field, filterFunc) {
                    var values1 = [];
                    var values = [];
                    var containsBlank = false;
                    for (var i = 0; i < self.config.dataSource.length; i++) {
                        var row = self.config.dataSource[i];
                        var val = row[field];
                        if (filterFunc !== undefined) {
                            if (filterFunc === true || (typeof filterFunc === 'function' && filterFunc(val))) {
                                values1.push(val);
                            }
                        } else {
                            if (val) {
                                values1.push(val);
                            } else {
                                containsBlank = true;
                            }
                        }
                    }
                    if (values1.length > 1) {
                        if (utils.isNumber(values1[0]) || utils.isDate(values1[0])) {
                            values1.sort(function(a, b) {
                                return a ? (b ? a - b : 1) : (b ? -1 : 0);
                            });
                        } else {
                            values1.sort();
                        }

                        for (var vi = 0; vi < values1.length; vi++) {
                            if (vi === 0 || values1[vi] !== values[values.length - 1]) {
                                values.push(values1[vi]);
                            }
                        }
                    } else {
                        values = values1;
                    }
                    values.containsBlank = containsBlank;
                    return values;
                };

                this.getFieldFilter = function(field) {
                    return self.filters[field];
                };

                this.isFieldFiltered = function(field) {
                    var filter = self.getFieldFilter(field);
                    return filter != null && !filter.isAlwaysTrue();
                };

                this.getData = function(field, rowdim, coldim, aggregateFunc) {
                    var value;
                    if (rowdim && coldim) {

                        var datafieldName = field || (self.config.dataFields[0] || defaultfield).name;
                        var datafield = self.config.getDataField(datafieldName);

                        if (!datafield || (aggregateFunc && datafield.aggregateFunc != aggregateFunc)) {
                            value = self.calcAggregation(
                                rowdim.isRoot ? null : rowdim.getRowIndexes().slice(0),
                                coldim.isRoot ? null : coldim.getRowIndexes().slice(0), [datafieldName],
                                aggregateFunc)[datafieldName];
                        } else {
                            if (self.dataMatrix[rowdim.id] && self.dataMatrix[rowdim.id][coldim.id]) {
                                value = self.dataMatrix[rowdim.id][coldim.id][datafieldName];
                            } else {
                                value = null;
                            }
                        }
                    }

                    return value === undefined ? null : value;
                };

                this.calcAggregation = function(rowIndexes, colIndexes, fieldNames, aggregateFunc) {
                    return computeValue(rowIndexes, colIndexes, rowIndexes, fieldNames, aggregateFunc);
                };

                this.query = query(self);

                refresh();

                function computeValue(rowIndexes, colIndexes, origRowIndexes, fieldNames, aggregateFunc) {

                    var res = {};

                    if (self.config.dataFieldsCount > 0) {

                        var intersection;

                        if (rowIndexes == null) {
                            intersection = colIndexes;
                        } else if (colIndexes == null) {
                            intersection = rowIndexes;
                        } else {
                            intersection = [];
                            for (var ri = 0; ri < rowIndexes.length; ri++) {
                                var rowindex = rowIndexes[ri];
                                if (rowindex >= 0) {
                                    var colrowindex = colIndexes.indexOf(rowindex);
                                    if (colrowindex >= 0) {
                                        rowIndexes[ri] = 0 - (rowindex + 2);
                                        intersection.push(rowindex);
                                    }
                                }
                            }
                        }

                        var emptyIntersection = intersection && intersection.length === 0;
                        var datasource = self.filteredDataSource;
                        var datafield;
                        var datafields = [];

                        if (fieldNames) {
                            for (var fieldnameIndex = 0; fieldnameIndex < fieldNames.length; fieldnameIndex++) {
                                datafield = self.config.getDataField(fieldNames[fieldnameIndex]);
                                if (!aggregateFunc) {
                                    if (!datafield) {
                                        datafield = self.config.getField(fieldNames[fieldnameIndex]);
                                        if (datafield) {
                                            aggregateFunc = datafield.dataSettings ? datafield.dataSettings.aggregateFunc() : datafield.aggregateFunc();
                                        }
                                    } else {
                                        aggregateFunc = datafield.aggregateFunc();
                                    }
                                }

                                if (datafield && aggregateFunc) {
                                    datafields.push({
                                        field: datafield,
                                        aggregateFunc: aggregateFunc
                                    });
                                }
                            }
                        } else {
                            for (var datafieldIndex = 0; datafieldIndex < self.config.dataFieldsCount; datafieldIndex++) {
                                datafield = self.config.dataFields[datafieldIndex] || defaultfield;
                                if (aggregateFunc || datafield.aggregateFunc) {
                                    datafields.push({
                                        field: datafield,
                                        aggregateFunc: aggregateFunc || datafield.aggregateFunc()
                                    });
                                }
                            }
                        }

                        for (var dfi = 0; dfi < datafields.length; dfi++) {
                            datafield = datafields[dfi];
                            // no data
                            if (emptyIntersection) {
                                res[datafield.field.name] = null;
                            } else {
                                res[datafield.field.name] = datafield.aggregateFunc(datafield.field.name, intersection || 'all', self.filteredDataSource, origRowIndexes || rowIndexes, colIndexes);
                            }
                        }
                    }

                    return res;
                }

                function computeRowValues(rowDim) {

                    if (rowDim) {
                        var data = {};
                        var rid = 'r' + rowDim.id;

                        // set cached row indexes for current row dimension
                        if (_iCache[rid] === undefined) {
                            _iCache[rid] = rowDim.isRoot ? null : (_iCache[rowDim.parent.id] || rowDim.getRowIndexes());
                        }

                        // calc grand-total cell
                        data[self.columns.root.id] = computeValue(rowDim.isRoot ? null : _iCache[rid].slice(0), null);

                        if (self.columns.dimensionsCount > 0) {
                            var p = 0;
                            var parents = [self.columns.root];

                            while (p < parents.length) {
                                var parent = parents[p];
                                var rowindexes = rowDim.isRoot ?
                                    null :
                                    (parent.isRoot ?
                                        _iCache[rid].slice(0) :
                                        _iCache['c' + parent.id].slice(0));

                                for (var i = 0; i < parent.values.length; i++) {
                                    var subdim = parent.subdimvals[parent.values[i]];
                                    var cid = 'c' + subdim.id;

                                    // set cached row indexes for this column leaf dimension
                                    if (_iCache[cid] === undefined) {
                                        _iCache[cid] = _iCache[cid] || subdim.getRowIndexes().slice(0);
                                    }

                                    data[subdim.id] = computeValue(rowindexes, _iCache[cid], rowDim.isRoot ? null : rowDim.getRowIndexes());

                                    if (!subdim.isLeaf) {
                                        parents.push(subdim);
                                        if (rowindexes) {
                                            _iCache[cid] = [];
                                            for (var ur = 0; ur < rowindexes.length; ur++) {
                                                var vr = rowindexes[ur];
                                                if (vr != -1 && vr < 0) {
                                                    _iCache[cid].push(0 - (vr + 2));
                                                    rowindexes[ur] = -1;
                                                }
                                            }
                                        }
                                    }
                                }
                                _iCache['c' + parent.id] = undefined;
                                p++;
                            }
                        }

                        return data;
                    }
                }

                function computeValues() {
                    self.dataMatrix = {};
                    _iCache = {};

                    // calc grand total row
                    self.dataMatrix[self.rows.root.id] = computeRowValues(self.rows.root);

                    if (self.rows.dimensionsCount > 0) {
                        var parents = [self.rows.root];
                        var p = 0;
                        var parent;
                        while (p < parents.length) {
                            parent = parents[p];
                            // calc children rows
                            for (var i = 0; i < parent.values.length; i++) {
                                var subdim = parent.subdimvals[parent.values[i]];
                                // calc child row
                                self.dataMatrix[subdim.id] = computeRowValues(subdim);
                                // if row is not a leaf, add it to parents array to process its children
                                if (!subdim.isLeaf) {
                                    parents.push(subdim);
                                }
                            }
                            // next parent
                            p++;
                        }
                    }
                }
            };

        }, {
            "./orb.axe": 181,
            "./orb.config": 182,
            "./orb.filtering": 185,
            "./orb.query": 187,
            "./orb.utils": 195
        }],
        187: [function(_dereq_, module, exports) {

            var utils = _dereq_('./orb.utils');
            var axe = _dereq_('./orb.axe');
            var aggregation = _dereq_('./orb.aggregation');

            var queryBase = function(source, query, filters) {

                var self = this;

                this.source = source;
                this.query = query;
                this.filters = filters;

                this.extractResult = function(aggs, options, outerArgs) {
                    if (outerArgs.multi === true) {
                        var res = {};
                        for (var ai = 0; ai < options.multiFieldNames.length; ai++) {
                            res[options.multiFieldNames[ai]] = aggs[self.getCaptionName(options.multiFieldNames[ai])];
                        }
                        return res;
                    } else {
                        return aggs[outerArgs.datafieldname];
                    }
                };

                this.measureFunc = function(datafieldname, multi, aggregateFunc, fieldsConfig) {

                    var outerArgs = {
                        datafieldname: self.getCaptionName(datafieldname),
                        multi: multi,
                        aggregateFunc: aggregateFunc
                    };

                    return function(options) {
                        options = self.cleanOptions(options, arguments, outerArgs);
                        var aggs = self.compute(options, fieldsConfig, multi);
                        return self.extractResult(aggs, options, outerArgs);
                    };
                };

                this.setDefaultAggFunctions = function(param) {

                    // if there is a registered field with a name or caption 'val', use 'val_'
                    var valname = self.query.val ? 'val_' : 'val';
                    self.query[valname] = self.measureFunc(undefined, true, undefined, param);


                    var aggFunctions = utils.ownProperties(aggregation);
                    for (var funcIndex = 0; funcIndex < aggFunctions.length; funcIndex++) {
                        var funcName = aggFunctions[funcIndex];
                        if (funcName !== 'toAggregateFunc') {
                            self.query[funcName] = self.measureFunc(
                                undefined,
                                true,
                                aggregation[funcName],
                                param
                            );
                        }
                    }
                };

            };

            var pgridQuery = function(pgrid) {

                queryBase.call(this, pgrid, {}, {});

                var self = this;

                this.getCaptionName = function(caption) {
                    return self.source.config.captionToName(caption);
                };

                this.cleanOptions = function(options, innerArgs, outerArgs) {
                    var opts = {
                        fieldNames: []
                    };

                    if (outerArgs.multi === true) {
                        if (options && typeof options === 'object') {
                            opts.aggregateFunc = options.aggregateFunc;
                            opts.multiFieldNames = options.fields;
                        } else {
                            opts.aggregateFunc = outerArgs.aggregateFunc;
                            opts.multiFieldNames = innerArgs;
                        }

                        for (var ai = 0; ai < opts.multiFieldNames.length; ai++) {
                            opts.fieldNames.push(self.getCaptionName(opts.multiFieldNames[ai]));
                        }
                    } else {
                        opts.aggregateFunc = options;
                        opts.fieldNames.push(outerArgs.datafieldname);
                    }

                    if (opts.aggregateFunc) {
                        opts.aggregateFunc = aggregation.toAggregateFunc(opts.aggregateFunc);
                    }

                    return opts;
                };

                this.setup = function(parameters) {
                    var rowFields = self.source.config.rowFields;
                    var colFields = self.source.config.columnFields;
                    var datafields = self.source.config.dataFields;
                    var fIndex;

                    // row fields setup
                    for (fIndex = 0; fIndex < rowFields.length; fIndex++) {
                        self.slice(rowFields[fIndex], axe.Type.ROWS, rowFields.length - fIndex);
                    }

                    // column fields setup
                    for (fIndex = 0; fIndex < colFields.length; fIndex++) {
                        self.slice(colFields[fIndex], axe.Type.COLUMNS, colFields.length - fIndex);
                    }

                    // data fields setup
                    for (fIndex = 0; fIndex < datafields.length; fIndex++) {
                        var df = datafields[fIndex];
                        var dfname = df.name;
                        var dfcaption = df.caption || dfname;

                        self.query[dfname] = self.query[dfcaption] = self.measureFunc(dfname);
                    }

                    if (parameters) {
                        for (var param in parameters) {
                            if (parameters.hasOwnProperty(param)) {
                                self.query[param](parameters[param]);
                            }
                        }
                    }

                    self.setDefaultAggFunctions();

                    return self.query;
                };

                this.slice = function(field, axetype, depth) {
                    self.query[field.name] = self.query[field.caption || field.name] = function(val) {
                        var f = {
                            name: field.name,
                            val: val,
                            depth: depth
                        };
                        (self.filters[axetype] = self.filters[axetype] || []).push(f);
                        return self.query;
                    };
                };

                function filterDimensions(upperDims, filter) {
                    return function(dim) {
                        return dim.value === filter.val &&
                            (!upperDims || upperDims.some(
                                function(upperDim) {
                                    var parent = dim.parent;
                                    if (parent) {
                                        while (parent.depth < upperDim.depth) {
                                            parent = parent.parent;
                                        }
                                    }
                                    return parent === upperDim;
                                }));
                    };
                }

                this.applyFilters = function(axetype) {
                    if (self.filters[axetype]) {
                        var sortedFilters = self.filters[axetype].sort(function(f1, f2) {
                            return f2.depth - f1.depth;
                        });

                        var currAxe = self.source[axetype === axe.Type.ROWS ? 'rows' : 'columns'];
                        var filterIndex = 0;
                        var filtered = null;
                        while (filterIndex < sortedFilters.length) {
                            var filter = sortedFilters[filterIndex];
                            filtered = currAxe.dimensionsByDepth[filter.depth]
                                .filter(filterDimensions(filtered, filter));
                            filterIndex++;
                        }
                        return filtered;
                    }
                    return null;
                };

                this.compute = function(options) {
                    var rowdims = self.applyFilters(axe.Type.ROWS) || [self.source.rows.root];
                    var coldims = self.applyFilters(axe.Type.COLUMNS) || [self.source.columns.root];

                    var aggs;

                    if (rowdims.length === 1 && coldims.length === 1) {
                        aggs = {};
                        for (var ai = 0; ai < options.fieldNames.length; ai++) {
                            aggs[options.fieldNames[ai]] = self.source.getData(options.fieldNames[ai], rowdims[0], coldims[0], options.aggregateFunc);
                        }
                    } else {
                        var rowIndexes = [];
                        var colIndexes = [];

                        for (var rdi = 0; rdi < rowdims.length; rdi++) {
                            rowIndexes = rowIndexes.concat(rowdims[rdi].getRowIndexes());
                        }
                        for (var cdi = 0; cdi < coldims.length; cdi++) {
                            colIndexes = colIndexes.concat(coldims[cdi].getRowIndexes());
                        }

                        aggs = self.source.calcAggregation(rowIndexes, colIndexes, options.fieldNames, options.aggregateFunc);
                    }

                    return aggs;
                };
            };

            var arrayQuery = function(array) {

                queryBase.call(this, array, {}, []);

                var self = this;
                var captionToName = {};

                this.setCaptionName = function(caption, name) {
                    captionToName[caption || name] = name;
                };

                this.getCaptionName = function(caption) {
                    return captionToName[caption] || caption;
                };

                this.cleanOptions = function(options, innerArgs, outerArgs) {
                    var opts = {
                        fieldNames: []
                    };

                    if (outerArgs.multi === true) {
                        if (options && typeof options === 'object') {
                            opts.aggregateFunc = options.aggregateFunc;
                            opts.multiFieldNames = options.fields;
                        } else {
                            opts.aggregateFunc = outerArgs.aggregateFunc;
                            opts.multiFieldNames = innerArgs;
                        }

                        for (var ai = 0; ai < opts.multiFieldNames.length; ai++) {
                            opts.fieldNames.push(self.getCaptionName(opts.multiFieldNames[ai]));
                        }
                    } else {
                        opts.aggregateFunc = options || outerArgs.aggregateFunc;
                        opts.fieldNames.push(outerArgs.datafieldname);
                    }

                    return opts;
                };

                this.setup = function(fieldsConfig) {

                    self.query.slice = function(field, val) {
                        var f = {
                            name: field,
                            val: val
                        };
                        self.filters.push(f);
                        return self.query;
                    };

                    if (fieldsConfig) {

                        var fieldNames = utils.ownProperties(fieldsConfig);

                        for (var fi = 0; fi < fieldNames.length; fi++) {
                            var fname = fieldNames[fi];
                            var f = fieldsConfig[fname];
                            var fcaption = f.caption || f.name;
                            f.name = fname;

                            self.setCaptionName(fcaption, fname);

                            if (f.toAggregate) {
                                self.query[fname] = self.query[fcaption] = self.measureFunc(fname, false, f.aggregateFunc);
                            } else {
                                self.slice(f);
                            }
                        }
                    }

                    self.setDefaultAggFunctions(fieldsConfig);

                    return self.query;
                };

                this.slice = function(field) {
                    self.query[field.name] = self.query[field.caption || field.name] = function(val) {
                        return self.query.slice(field.name, val);
                    };
                };

                this.applyFilters = function() {
                    var rowIndexes = [];

                    for (var i = 0; i < self.source.length; i++) {
                        var row = self.source[i];
                        var include = true;
                        for (var j = 0; j < self.filters.length; j++) {
                            var filter = self.filters[j];
                            if (row[filter.name] !== filter.val) {
                                include = false;
                                break;
                            }
                        }
                        if (include) {
                            rowIndexes.push(i);
                        }
                    }

                    return rowIndexes;
                };

                this.compute = function(options, fieldsConfig, multi) {
                    var rowIndexes = self.applyFilters();

                    var aggs = {};

                    for (var ai = 0; ai < options.fieldNames.length; ai++) {
                        var datafield = options.fieldNames[ai];
                        var aggFunc = aggregation.toAggregateFunc(
                            multi === true ?
                            options.aggregateFunc || (fieldsConfig && fieldsConfig[datafield] ?
                                fieldsConfig[datafield].aggregateFunc :
                                undefined) :
                            options.aggregateFunc);

                        aggs[datafield] = aggFunc(datafield, rowIndexes || 'all', self.source, rowIndexes, null);
                    }

                    return aggs;
                };
            };

            module.exports = function(source, fieldsConfig) {
                if (utils.isArray(source)) {
                    return new arrayQuery(source).setup(fieldsConfig);
                } else {
                    // assume it's a pgrid
                    return function(parameters) {
                        return new pgridQuery(source).setup(parameters);
                    };
                }
            };

        }, {
            "./orb.aggregation": 180,
            "./orb.axe": 181,
            "./orb.utils": 195
        }],
        188: [function(_dereq_, module, exports) {



            module.exports = function() {
                var states = {};

                this.set = function(key, state) {
                    states[key] = state;
                };

                this.get = function(key) {
                    return states[key];
                };
            };
        }, {}],
        189: [function(_dereq_, module, exports) {

            module.exports = (function() {

                var currentTheme = 'blue';
                var themeManager = {};
                var buttonClass = 'fld-btn';

                function isBootstrap() {
                    return currentTheme === 'bootstrap';
                }

                themeManager.themes = {
                    red: '#C72C48',
                    blue: '#5bc0de',
                    darkBlue: '#2185D0',
                    green: '#3fb618',
                    orange: '#df691a',
                    flower: '#A74AC7',
                    gray: '#808080',
                    black: '#000000',
                    white: '#FFFFFF'
                };

                themeManager.current = function(newTheme) {
                    if (newTheme) {
                        currentTheme = themeManager.validateTheme(newTheme);
                    }

                    return currentTheme;
                };

                themeManager.buttonClass = function(newButtonClass) {
                    if (newButtonClass) {
                        buttonClass = newButtonClass
                    }
                }

                themeManager.validateTheme = function(themeName) {
                    themeName = (themeName || '').toString().trim();
                    if (!themeManager.themes[themeName] && themeName !== 'bootstrap') {
                        return 'blue';
                    } else {
                        return themeName;
                    }
                };

                themeManager.getPivotClasses = function() {
                    return {
                        container: 'orb-container orb-' + currentTheme,
                        table: 'orb' + (isBootstrap() ? ' table' : '')
                    };
                };

                themeManager.getButtonClasses = function() {
                    return {
                        pivotButton: buttonClass + (isBootstrap() ? ' btn btn-default btn-xs' : ''),
                        orbButton: 'orb-btn' + (isBootstrap() ? ' btn btn-default btn-xs' : ''),
                        scrollBar: isBootstrap() ? ' btn btn-default btn-xs' : ''
                    };
                };

                themeManager.getFilterClasses = function() {
                    return {
                        container: 'orb-' + currentTheme + ' orb fltr-cntnr'
                    };
                };

                themeManager.getGridClasses = function() {
                    return {
                        table: isBootstrap() ? 'table table-condensed' : 'orb-table'
                    };
                };

                themeManager.getDialogClasses = function(visible) {
                    var classes = {
                        overlay: 'orb-overlay orb-overlay-' + (visible ? 'visible' : 'hidden') + ' orb-' + currentTheme,
                        dialog: 'orb-dialog',
                        content: '',
                        header: 'orb-dialog-header',
                        title: '',
                        body: 'orb-dialog-body'
                    };

                    if (isBootstrap()) {
                        classes.overlay += ' modal';
                        classes.dialog += ' modal-dialog';
                        classes.content = 'modal-content';
                        classes.header += ' modal-header';
                        classes.title = 'modal-title';
                        classes.body += ' modal-body';
                    }
                    return classes;
                };

                var utils = themeManager.utils = {
                    hexToRgb: function(hex) {
                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
                    },
                    rgbaToHex: function(rgba) {
                        var matches = rgba.match(/rgba\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+(?:\.\d+)?)\s*\)/);
                        if (matches) {
                            var alpah = parseFloat(matches[4]);
                            return '#' +
                                utils.applyAlphaAndToHex(matches[1], alpah) +
                                utils.applyAlphaAndToHex(matches[2], alpah) +
                                utils.applyAlphaAndToHex(matches[3], alpah);
                        }
                        return null;
                    },
                    applyAlphaAndToHex: function(value, alpha) {
                        return (Math.floor(alpha * parseInt(value) + (1 - alpha) * 255) + 256).toString(16).substr(1, 2);
                    },
                    fadeoutColor: function(color, alpha) {
                        color = utils.hexToRgb(color);
                        return '#' +
                            utils.applyAlphaAndToHex(color.r, alpha) +
                            utils.applyAlphaAndToHex(color.g, alpha) +
                            utils.applyAlphaAndToHex(color.b, alpha);
                    }
                };

                return themeManager;
            }());

        }, {}],
        190: [function(_dereq_, module, exports) {

            var axe = _dereq_('./orb.axe');
            var uiheaders = _dereq_('./orb.ui.header');

            module.exports = function(axeModel) {

                var self = this;


                this.axe = axeModel;


                this.headers = [];

                this.dataFieldsCount = function() {
                    return (self.axe.pgrid.config.dataHeadersLocation === 'columns' && self.axe.type === axe.Type.COLUMNS) ||
                        (self.axe.pgrid.config.dataHeadersLocation === 'rows' && self.axe.type === axe.Type.ROWS) ?
                        self.axe.pgrid.config.dataFieldsCount :
                        1;
                };

                this.isMultiDataFields = function() {
                    return self.dataFieldsCount() > 1;
                };

                this.toggleFieldExpansion = function(field, newState) {
                    var toToggle = [];
                    var allExpanded = true;
                    var hIndex;

                    for (var i = 0; i < this.headers.length; i++) {
                        for (hIndex = 0; hIndex < this.headers[i].length; hIndex++) {
                            var header = this.headers[i][hIndex];
                            if (header.type === uiheaders.HeaderType.SUB_TOTAL && (field == null || header.dim.field.name == field.name)) {
                                toToggle.push(header);
                                allExpanded = allExpanded && header.expanded;
                            }
                        }
                    }

                    if (newState !== undefined) {
                        allExpanded = !newState;
                    }

                    if (toToggle.length > 0) {
                        for (hIndex = 0; hIndex < toToggle.length; hIndex++) {
                            if (allExpanded) {
                                toToggle[hIndex].collapse();
                            } else {
                                toToggle[hIndex].expand();
                            }
                        }
                        return true;
                    }

                    return false;
                };
            };

        }, {
            "./orb.axe": 181,
            "./orb.ui.header": 192
        }],
        191: [function(_dereq_, module, exports) {

            var axe = _dereq_('./orb.axe');
            var axeUi = _dereq_('./orb.ui.axe');
            var uiheaders = _dereq_('./orb.ui.header');

            module.exports = function(columnsAxe) {

                var self = this;

                axeUi.call(self, columnsAxe);

                this.leafsHeaders = null;

                this.build = function() {
                    self.headers = [];

                    if (self.axe != null) {
                        // Fill columns layout infos
                        if (self.axe.root.values.length > 0 || self.axe.pgrid.config.grandTotal.columnsvisible) {
                            for (var depth = self.axe.root.depth; depth > 1; depth--) {
                                self.headers.push([]);
                                getUiInfo(depth, self.headers);
                            }

                            if (self.axe.pgrid.config.grandTotal.columnsvisible) {
                                // add grandtotal header
                                (self.headers[0] = self.headers[0] || []).push(new uiheaders.header(axe.Type.COLUMNS, uiheaders.HeaderType.GRAND_TOTAL, self.axe.root, null, self.dataFieldsCount()));
                            }
                        }

                        if (self.headers.length === 0) {
                            self.headers.push([new uiheaders.header(axe.Type.COLUMNS, uiheaders.HeaderType.INNER, self.axe.root, null, self.dataFieldsCount())]);
                        }

                        // generate leafs headers
                        generateLeafsHeaders();
                    }
                };

                function generateLeafsHeaders() {

                    var leafsHeaders = [];

                    function pushsubtotal(pheader) {
                        if (pheader && pheader.dim.field.subTotal.visible) {
                            leafsHeaders.push(pheader.subtotalHeader);
                        }
                    }

                    if (self.headers.length > 0) {
                        // last headers row
                        var infos = self.headers[self.headers.length - 1];
                        var header = infos[0];

                        if (header) {
                            var currparent,
                                prevpar = header.parent;

                            for (var i = 0; i < infos.length; i++) {
                                header = infos[i];
                                currparent = header.parent;
                                // if current header parent is different than previous header parent,
                                // add previous parent
                                if (currparent != prevpar) {
                                    pushsubtotal(prevpar);
                                    if (currparent != null) {
                                        // walk up parent hierarchy and add grand parents if different 
                                        // than current header grand parents
                                        var grandpar = currparent.parent;
                                        var prevgrandpar = prevpar ? prevpar.parent : null;
                                        while (grandpar != prevgrandpar && prevgrandpar != null) {
                                            pushsubtotal(prevgrandpar);
                                            grandpar = grandpar ? grandpar.parent : null;
                                            prevgrandpar = prevgrandpar ? prevgrandpar.parent : null;
                                        }
                                    }
                                    // update previous parent variable
                                    prevpar = currparent;
                                }
                                // push current header
                                leafsHeaders.push(infos[i]);

                                // if it's the last header, add all of its parents up to the top
                                if (i === infos.length - 1) {
                                    while (prevpar != null) {
                                        pushsubtotal(prevpar);
                                        prevpar = prevpar.parent;
                                    }
                                }
                            }
                            // grandtotal is visible for columns and if there is more than one dimension in this axe
                            if (self.axe.pgrid.config.grandTotal.columnsvisible && self.axe.dimensionsCount > 1) {
                                // push also grand total header
                                leafsHeaders.push(self.headers[0][self.headers[0].length - 1]);
                            }
                        }
                    }

                    // add data headers if more than 1 data field and they willbe the leaf headers
                    if (self.isMultiDataFields()) {
                        self.leafsHeaders = [];
                        for (var leafIndex = 0; leafIndex < leafsHeaders.length; leafIndex++) {
                            for (var datafieldindex = 0; datafieldindex < self.dataFieldsCount(); datafieldindex++) {
                                self.leafsHeaders.push(new uiheaders.dataHeader(self.axe.pgrid.config.dataFields[datafieldindex], leafsHeaders[leafIndex]));
                            }
                        }
                        self.headers.push(self.leafsHeaders);
                    } else {
                        self.leafsHeaders = leafsHeaders;
                    }
                }

                this.build();


                function getUiInfo(depth, headers) {

                    var infos = headers[headers.length - 1];
                    var parents = self.axe.root.depth === depth ? [null] :
                        headers[self.axe.root.depth - depth - 1].filter(function(p) {
                            return p.type !== uiheaders.HeaderType.SUB_TOTAL;
                        });

                    for (var pi = 0; pi < parents.length; pi++) {

                        var parent = parents[pi];
                        var parentDim = parent == null ? self.axe.root : parent.dim;

                        for (var di = 0; di < parentDim.values.length; di++) {

                            var subvalue = parentDim.values[di];
                            var subdim = parentDim.subdimvals[subvalue];

                            var subtotalHeader;
                            if (!subdim.isLeaf && subdim.field.subTotal.visible) {
                                subtotalHeader = new uiheaders.header(axe.Type.COLUMNS, uiheaders.HeaderType.SUB_TOTAL, subdim, parent, self.dataFieldsCount());
                            } else {
                                subtotalHeader = null;
                            }

                            var header = new uiheaders.header(axe.Type.COLUMNS, null, subdim, parent, self.dataFieldsCount(), subtotalHeader);
                            infos.push(header);

                            if (!subdim.isLeaf && subdim.field.subTotal.visible) {
                                infos.push(subtotalHeader);
                            }
                        }
                    }
                }
            };

        }, {
            "./orb.axe": 181,
            "./orb.ui.axe": 190,
            "./orb.ui.header": 192
        }],
        192: [function(_dereq_, module, exports) {

            var axe = _dereq_('./orb.axe');
            var state = new(_dereq_('./orb.state'))();

            var HeaderType = module.exports.HeaderType = {
                EMPTY: 1,
                DATA_HEADER: 2,
                DATA_VALUE: 3,
                FIELD_BUTTON: 4,
                INNER: 5,
                WRAPPER: 6,
                SUB_TOTAL: 7,
                GRAND_TOTAL: 8,
                getHeaderClass: function(headerType, axetype) {
                    var cssclass = axetype === axe.Type.ROWS ? 'header-row' : (axetype === axe.Type.COLUMNS ? 'header-col' : '');
                    switch (headerType) {
                        case HeaderType.EMPTY:
                        case HeaderType.FIELD_BUTTON:
                            cssclass = 'empty';
                            break;
                        case HeaderType.INNER:
                            cssclass = 'header ' + cssclass;
                            break;
                        case HeaderType.WRAPPER:
                            cssclass = 'header ' + cssclass;
                            break;
                        case HeaderType.SUB_TOTAL:
                            cssclass = 'header header-st ' + cssclass;
                            break;
                        case HeaderType.GRAND_TOTAL:
                            cssclass = 'header header-gt ' + cssclass;
                            break;
                    }

                    return cssclass;
                },
                getCellClass: function(rowHeaderType, colHeaderType) {
                    var cssclass = '';
                    switch (rowHeaderType) {
                        case HeaderType.GRAND_TOTAL:
                            cssclass = 'cell-gt';
                            break;
                        case HeaderType.SUB_TOTAL:
                            if (colHeaderType === HeaderType.GRAND_TOTAL) {
                                cssclass = 'cell-gt';
                            } else {
                                cssclass = 'cell-st';
                            }
                            break;
                        default:
                            if (colHeaderType === HeaderType.GRAND_TOTAL) {
                                cssclass = 'cell-gt';
                            } else if (colHeaderType === HeaderType.SUB_TOTAL) {
                                cssclass = 'cell-st';
                            } else {
                                cssclass = '';
                            }
                    }
                    return cssclass;
                }
            };

            function CellBase(options) {

                this.axetype = options.axetype;

                this.type = options.type;

                this.template = options.template;

                this.value = options.value;

                this.expanded = true;

                this.cssclass = options.cssclass;

                this.hspan = options.hspan || function() {
                    return 1;
                };

                this.vspan = options.vspan || function() {
                    return 1;
                };

                this.visible = options.isvisible || function() {
                    return true;
                };

                this.key = this.axetype + this.type + this.value;
                this.getState = function() {
                    return state.get(this.key);
                };
                this.setState = function(newState) {
                    state.set(this.key, newState);
                };
            }

            module.exports.header = function(axetype, headerType, dim, parent, datafieldscount, subtotalHeader) {

                var self = this;

                var hspan;
                var vspan;
                var value;

                var isRowsAxe = axetype === axe.Type.ROWS;
                headerType = headerType || (dim.depth === 1 ? HeaderType.INNER : HeaderType.WRAPPER);

                switch (headerType) {
                    case HeaderType.GRAND_TOTAL:
                        value = 'Grand Total';
                        hspan = isRowsAxe ? dim.depth - 1 || 1 : datafieldscount;
                        vspan = isRowsAxe ? datafieldscount : dim.depth - 1 || 1;
                        break;
                    case HeaderType.SUB_TOTAL:
                        value = dim.value;
                        hspan = isRowsAxe ? dim.depth : datafieldscount;
                        vspan = isRowsAxe ? datafieldscount : dim.depth;
                        break;
                    default:
                        value = dim.value;
                        hspan = isRowsAxe ? 1 : null;
                        vspan = isRowsAxe ? null : 1;
                        break;
                }

                CellBase.call(this, {
                    axetype: axetype,
                    type: headerType,
                    template: isRowsAxe ? 'cell-template-row-header' : 'cell-template-column-header',
                    value: value,
                    cssclass: HeaderType.getHeaderClass(headerType, axetype),
                    hspan: hspan != null ? function() {
                        return hspan;
                    } : calcSpan,
                    vspan: vspan != null ? function() {
                        return vspan;
                    } : calcSpan,
                    isvisible: isParentExpanded
                });

                this.subtotalHeader = subtotalHeader;
                this.parent = parent;
                this.subheaders = [];
                this.dim = dim;
                this.expanded = this.getState() ? this.getState().expanded : (headerType !== HeaderType.SUB_TOTAL || !dim.field.subTotal.collapsed);

                this.expand = function() {
                    self.expanded = true;
                    this.setState({
                        expanded: self.expanded
                    });
                };
                this.collapse = function() {
                    self.expanded = false;
                    this.setState({
                        expanded: self.expanded
                    });
                };

                if (parent != null) {
                    parent.subheaders.push(this);
                }

                function isParentExpanded() {
                    if (self.type === HeaderType.SUB_TOTAL) {
                        var hparent = self.parent;
                        while (hparent != null) {
                            if (hparent.subtotalHeader && !hparent.subtotalHeader.expanded) {
                                return false;
                            }
                            hparent = hparent.parent;
                        }
                        return true;
                    } else {

                        var isexpanded = self.dim.isRoot || self.dim.isLeaf || !self.dim.field.subTotal.visible || self.subtotalHeader.expanded;
                        if (!isexpanded) {
                            return false;
                        }

                        var par = self.parent;
                        while (par != null && (!par.dim.field.subTotal.visible || (par.subtotalHeader != null && par.subtotalHeader.expanded))) {
                            par = par.parent;
                        }
                        return par == null || par.subtotalHeader == null ? isexpanded : par.subtotalHeader.expanded;
                    }
                }

                function calcSpan(ignoreVisibility) {
                    var tspan = 0;
                    var subSpan;
                    var addone = false;

                    if (isRowsAxe || ignoreVisibility || self.visible()) {
                        if (!self.dim.isLeaf) {
                            // subdimvals 'own' properties are the set of values for this dimension
                            if (self.subheaders.length > 0) {
                                for (var i = 0; i < self.subheaders.length; i++) {
                                    var subheader = self.subheaders[i];
                                    // if its not an array
                                    if (!subheader.dim.isLeaf) {
                                        subSpan = isRowsAxe ? subheader.vspan() : subheader.hspan();
                                        tspan += subSpan;
                                        if (i === 0 && (subSpan === 0)) {
                                            addone = true;
                                        }
                                    } else {
                                        tspan += datafieldscount;
                                    }
                                }
                            } else {
                                tspan += datafieldscount;
                            }
                        } else {
                            return datafieldscount;
                        }
                        return tspan + (addone ? 1 : 0);
                    }
                    return tspan;
                }
            };

            module.exports.dataHeader = function(datafield, parent) {

                CellBase.call(this, {
                    axetype: null,
                    type: HeaderType.DATA_HEADER,
                    template: 'cell-template-dataheader',
                    value: datafield,
                    cssclass: HeaderType.getHeaderClass(parent.type, parent.axetype),
                    isvisible: parent.visible
                });

                this.parent = parent;
            };

            module.exports.dataCell = function(pgrid, isvisible, rowinfo, colinfo) {

                this.rowDimension = rowinfo.type === HeaderType.DATA_HEADER ? rowinfo.parent.dim : rowinfo.dim;
                this.columnDimension = colinfo.type === HeaderType.DATA_HEADER ? colinfo.parent.dim : colinfo.dim;
                this.rowType = rowinfo.type === HeaderType.DATA_HEADER ? rowinfo.parent.type : rowinfo.type;
                this.colType = colinfo.type === HeaderType.DATA_HEADER ? colinfo.parent.type : colinfo.type;

                this.datafield = pgrid.config.dataFieldsCount > 1 ?
                    (pgrid.config.dataHeadersLocation === 'rows' ?
                        rowinfo.value :
                        colinfo.value) :
                    pgrid.config.dataFields[0];

                CellBase.call(this, {
                    axetype: null,
                    type: HeaderType.DATA_VALUE,
                    template: 'cell-template-datavalue',
                    value: pgrid.getData(this.datafield ? this.datafield.name : null, this.rowDimension, this.columnDimension),
                    cssclass: 'cell ' + HeaderType.getCellClass(this.rowType, this.colType),
                    isvisible: isvisible
                });
            };

            module.exports.buttonCell = function(field) {

                CellBase.call(this, {
                    axetype: null,
                    type: HeaderType.FIELD_BUTTON,
                    template: 'cell-template-fieldbutton',
                    value: field,
                    cssclass: HeaderType.getHeaderClass(HeaderType.FIELD_BUTTON)
                });
            };

            module.exports.emptyCell = function(hspan, vspan) {

                CellBase.call(this, {
                    axetype: null,
                    type: HeaderType.EMPTY,
                    template: 'cell-template-empty',
                    value: null,
                    cssclass: HeaderType.getHeaderClass(HeaderType.EMPTY),
                    hspan: function() {
                        return hspan;
                    },
                    vspan: function() {
                        return vspan;
                    },
                });
            };

        }, {
            "./orb.axe": 181,
            "./orb.state": 188
        }],
        193: [function(_dereq_, module, exports) {

            const _ = _dereq_('lodash');
            const axe = _dereq_('./orb.axe');
            const pgrid = _dereq_('./orb.pgrid');
            const uiheaders = _dereq_('./orb.ui.header');
            const uirows = _dereq_('./orb.ui.rows');
            const uicols = _dereq_('./orb.ui.cols');
            const React = _dereq_('react');
            const ReactDom = _dereq_('react-dom');
            const OrbReactComps = _dereq_('./react/orb.react.compiled');

            module.exports = function(config) {

                var self = this;
                var renderElement;
                var pivotComponent;
                var dialog = OrbReactComps.Dialog.create();


                this.pgrid = new pgrid(config);


                this.rows = null;

                this.columns = null;


                this.dataRows = [];

                this.filters = {};

                this.layout = {
                    rowHeaders: {

                        width: null,

                        height: null
                    },
                    columnHeaders: {

                        width: null,

                        height: null,
                    },
                    pivotTable: {

                        width: null,

                        height: null
                    }
                };

                this.sort = function(axetype, field) {
                    if (axetype === axe.Type.ROWS) {
                        self.pgrid.rows.sort(field);
                    } else if (axetype === axe.Type.COLUMNS) {
                        self.pgrid.columns.sort(field);
                    } else {
                        return;
                    }

                    buildUi();
                };

                this.refreshData = function(data) {
                    self.pgrid.refreshData(data);
                    buildUi();
                    pivotComponent.setProps({});
                };

                this.getFilters = function() {
                    return self.filters;
                }

                this.getRows = function() {
                    return self.rows;
                }

                this.getColumns = function() {
                    return self.columns;
                }

                this.getDataRows = function() {
                    return self.pgrid.config.dataFields;
                }

                this.applyFilter = function(fieldname, operator, term, staticValue, excludeStatic) {
                    var fieldIndex = _.findIndex(config.fields, function(f) {
                        return f.name == fieldname
                    })

                    self.filters[config.fields[fieldIndex].name] = staticValue

                    self.pgrid.applyFilter(fieldname, operator, term, staticValue, excludeStatic);
                    buildUi();
                };

                this.moveField = function(field, oldAxeType, newAxeType, position) {
                    if (self.pgrid.moveField(field, oldAxeType, newAxeType, position)) {
                        buildUi();
                        return true;
                    }
                    return false;
                };

                this.toggleFieldExpansion = function(axetype, field, newState) {
                    if (axetype === axe.Type.ROWS) {
                        return self.rows.toggleFieldExpansion(field, newState);
                    } else if (axetype === axe.Type.COLUMNS) {
                        return self.columns.toggleFieldExpansion(field, newState);
                    }
                    return false;
                };

                this.toggleSubtotals = function(axetype) {
                    if (self.pgrid.config.toggleSubtotals(axetype)) {
                        buildUi();
                        return true;
                    }
                    return false;
                };

                this.areSubtotalsVisible = function(axetype) {
                    return self.pgrid.config.areSubtotalsVisible(axetype);
                };

                this.toggleGrandtotal = function(axetype) {
                    if (self.pgrid.config.toggleGrandtotal(axetype)) {
                        buildUi();
                        return true;
                    }
                    return false;
                };

                this.isGrandtotalVisible = function(axetype) {
                    return self.pgrid.config.isGrandtotalVisible(axetype);
                };

                this.changeTheme = function(newTheme) {
                    pivotComponent.changeTheme(newTheme);
                };

                this.render = function(element) {
                    renderElement = element;
                    if (renderElement) {
                        var pivotTableFactory = React.createFactory(OrbReactComps.PivotTable);
                        var pivottable = pivotTableFactory({
                            pgridwidget: self
                        });

                        pivotComponent = ReactDom.render(pivottable, element);
                    }
                };

                this.drilldown = function(dataCell, pivotId) {
                    if (dataCell) {
                        var colIndexes = dataCell.columnDimension.getRowIndexes();
                        var data = dataCell.rowDimension.getRowIndexes().filter(function(index) {
                            return colIndexes.indexOf(index) >= 0;
                        }).map(function(index) {
                            return self.pgrid.filteredDataSource[index];
                        });

                        var title;
                        if (dataCell.rowType === uiheaders.HeaderType.GRAND_TOTAL && dataCell.colType === uiheaders.HeaderType.GRAND_TOTAL) {
                            title = 'Total';
                        } else {
                            if (dataCell.rowType === uiheaders.HeaderType.GRAND_TOTAL) {
                                title = dataCell.columnDimension.value + '/Total ';
                            } else if (dataCell.colType === uiheaders.HeaderType.GRAND_TOTAL) {
                                title = dataCell.rowDimension.value + '/Total ';
                            } else {
                                title = dataCell.rowDimension.value + '/' + dataCell.columnDimension.value;
                            }
                        }

                        var pivotStyle = window.getComputedStyle(pivotComponent.refs.pivotContainer, null);

                        dialog.show({
                            title: title,
                            comp: {
                                type: OrbReactComps.Grid,
                                props: {
                                    headers: self.pgrid.config.getDataSourceFieldCaptions(),
                                    data: data,
                                    theme: self.pgrid.config.theme
                                }
                            },
                            theme: self.pgrid.config.theme,
                            style: {
                                fontFamily: pivotStyle.getPropertyValue('font-family'),
                                fontSize: pivotStyle.getPropertyValue('font-size')
                            }
                        });
                    }
                };

                buildUi();

                function buildUi() {

                    // build row and column headers
                    self.rows = new uirows(self.pgrid.rows);
                    self.columns = new uicols(self.pgrid.columns);

                    var rowsHeaders = self.rows.headers;
                    var columnsLeafHeaders = self.columns.leafsHeaders;

                    // set control layout infos
                    self.layout = {
                        rowHeaders: {
                            width: (self.pgrid.rows.fields.length || 1) +
                                (self.pgrid.config.dataHeadersLocation === 'rows' && self.pgrid.config.dataFieldsCount > 1 ? 1 : 0),
                            height: rowsHeaders.length
                        },
                        columnHeaders: {
                            width: self.columns.leafsHeaders.length,
                            height: (self.pgrid.columns.fields.length || 1) +
                                (self.pgrid.config.dataHeadersLocation === 'columns' && self.pgrid.config.dataFieldsCount > 1 ? 1 : 0)
                        }
                    };

                    self.layout.pivotTable = {
                        width: self.layout.rowHeaders.width + self.layout.columnHeaders.width,
                        height: self.layout.rowHeaders.height + self.layout.columnHeaders.height
                    };

                    var dataRows = [];
                    var arr;

                    function createVisibleFunc(rowvisible, colvisible) {
                        return function() {
                            return rowvisible() && colvisible();
                        };
                    }
                    if (rowsHeaders.length > 0) {
                        for (var ri = 0; ri < rowsHeaders.length; ri++) {
                            var rowHeadersRow = rowsHeaders[ri];
                            var rowLeafHeader = rowHeadersRow[rowHeadersRow.length - 1];

                            arr = [];
                            for (var colHeaderIndex = 0; colHeaderIndex < columnsLeafHeaders.length; colHeaderIndex++) {
                                var columnLeafHeader = columnsLeafHeaders[colHeaderIndex];
                                var isvisible = createVisibleFunc(rowLeafHeader.visible, columnLeafHeader.visible);
                                arr[colHeaderIndex] = new uiheaders.dataCell(self.pgrid, isvisible, rowLeafHeader, columnLeafHeader);
                            }
                            dataRows.push(arr);
                        }
                    }
                    self.dataRows = dataRows;
                }
            };

        }, {
            "./orb.axe": 181,
            "./orb.pgrid": 186,
            "./orb.ui.cols": 191,
            "./orb.ui.header": 192,
            "./orb.ui.rows": 194,
            "./react/orb.react.compiled": 196,
            "lodash": 26,
            "react": undefined,
            "react-dom": 29
        }],
        194: [function(_dereq_, module, exports) {

            var axe = _dereq_('./orb.axe');
            var axeUi = _dereq_('./orb.ui.axe');
            var uiheaders = _dereq_('./orb.ui.header');

            module.exports = function(rowsAxe) {

                var self = this;

                axeUi.call(self, rowsAxe);

                this.build = function() {
                    var headers = [];
                    var grandtotalHeader;

                    if (self.axe != null) {
                        if (self.axe.root.values.length > 0 || self.axe.pgrid.config.grandTotal.rowsvisible) {
                            headers.push([]);

                            // Fill Rows layout infos
                            getUiInfo(headers, self.axe.root);

                            if (self.axe.pgrid.config.grandTotal.rowsvisible) {
                                var lastrow = headers[headers.length - 1];
                                grandtotalHeader = new uiheaders.header(axe.Type.ROWS, uiheaders.HeaderType.GRAND_TOTAL, self.axe.root, null, self.dataFieldsCount());
                                if (lastrow.length === 0) {
                                    lastrow.push(grandtotalHeader);
                                } else {
                                    headers.push([grandtotalHeader]);
                                }
                            }
                        }

                        if (headers.length === 0) {
                            headers.push([grandtotalHeader = new uiheaders.header(axe.Type.ROWS, uiheaders.HeaderType.INNER, self.axe.root, null, self.dataFieldsCount())]);
                        }

                        if (grandtotalHeader) {
                            // add grand-total data headers if more than 1 data field and they will be the leaf headers
                            addDataHeaders(headers, grandtotalHeader);
                        }
                    }
                    self.headers = headers;
                };

                this.build();

                function addDataHeaders(infos, parent) {
                    if (self.isMultiDataFields()) {
                        var lastInfosArray = infos[infos.length - 1];
                        for (var datafieldindex = 0; datafieldindex < self.dataFieldsCount(); datafieldindex++) {
                            lastInfosArray.push(new uiheaders.dataHeader(self.axe.pgrid.config.dataFields[datafieldindex], parent));
                            if (datafieldindex < self.dataFieldsCount() - 1) {
                                infos.push((lastInfosArray = []));
                            }
                        }
                    }
                }


                function getUiInfo(infos, dimension) {
                    if (dimension.values.length > 0) {

                        var infosMaxIndex = infos.length - 1;
                        var lastInfosArray = infos[infosMaxIndex];
                        var parent = lastInfosArray.length > 0 ? lastInfosArray[lastInfosArray.length - 1] : null;

                        for (var valIndex = 0; valIndex < dimension.values.length; valIndex++) {
                            var subvalue = dimension.values[valIndex];
                            var subdim = dimension.subdimvals[subvalue];

                            var subTotalHeader;
                            if (!subdim.isLeaf && subdim.field.subTotal.visible) {
                                subTotalHeader = new uiheaders.header(axe.Type.ROWS, uiheaders.HeaderType.SUB_TOTAL, subdim, parent, self.dataFieldsCount());
                            } else {
                                subTotalHeader = null;
                            }

                            var newHeader = new uiheaders.header(axe.Type.ROWS, null, subdim, parent, self.dataFieldsCount(), subTotalHeader);

                            if (valIndex > 0) {
                                infos.push((lastInfosArray = []));
                            }

                            lastInfosArray.push(newHeader);

                            if (!subdim.isLeaf) {
                                getUiInfo(infos, subdim);
                                if (subdim.field.subTotal.visible) {
                                    infos.push([subTotalHeader]);

                                    // add sub-total data headers if more than 1 data field and they will be the leaf headers
                                    addDataHeaders(infos, subTotalHeader);
                                }
                            } else {
                                // add data headers if more than 1 data field and they will be the leaf headers
                                addDataHeaders(infos, newHeader);
                            }
                        }
                    }
                }
            };

        }, {
            "./orb.axe": 181,
            "./orb.ui.axe": 190,
            "./orb.ui.header": 192
        }],
        195: [function(_dereq_, module, exports) {
            (function(global) {

                module.exports = {

                    ns: function(identifier, parent) {
                        var parts = identifier.split('.');
                        var i = 0;
                        parent = parent || window;
                        while (i < parts.length) {
                            parent[parts[i]] = parent[parts[i]] || {};
                            parent = parent[parts[i]];
                            i++;
                        }
                        return parent;
                    },

                    ownProperties: function(obj) {
                        var arr = [];
                        for (var prop in obj) {
                            if (obj.hasOwnProperty(prop)) {
                                arr.push(prop);
                            }
                        }
                        return arr;
                    },

                    isArray: function(obj) {
                        return Object.prototype.toString.apply(obj) === '[object Array]';
                    },

                    isNumber: function(obj) {
                        return Object.prototype.toString.apply(obj) === '[object Number]';
                    },

                    isDate: function(obj) {
                        return Object.prototype.toString.apply(obj) === '[object Date]';
                    },

                    isString: function(obj) {
                        return Object.prototype.toString.apply(obj) === '[object String]';
                    },

                    isRegExp: function(obj) {
                        return Object.prototype.toString.apply(obj) === '[object RegExp]';
                    },

                    escapeRegex: function(re) {
                        return re.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    },

                    findInArray: function(array, predicate) {
                        if (this.isArray(array) && predicate) {
                            for (var i = 0; i < array.length; i++) {
                                var item = array[i];
                                if (predicate(item)) {
                                    return item;
                                }
                            }
                        }
                        return undefined;
                    },

                    jsonStringify: function(obj, censorKeywords) {
                        function censor(key, value) {
                            return censorKeywords && censorKeywords.indexOf(key) > -1 ? undefined : value;
                        }
                        return JSON.stringify(obj, censor, 2);
                    }
                };

                // from: https://github.com/davidchambers/Base64.js

                (function(object) {
                    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

                    function InvalidCharacterError(message) {
                        this.message = message;
                    }
                    InvalidCharacterError.prototype = new Error();
                    InvalidCharacterError.prototype.name = 'InvalidCharacterError';
                    // encoder
                    // [https://gist.github.com/999166] by [https://github.com/nignag]
                    object.btoa = global && global.btoa ? function(str) {
                            return global.btoa(str);
                        } :
                        function(input) {
                            var str = String(input);
                            for (
                                // initialize result and counter
                                var block, charCode, idx = 0, map = chars, output = '';
                                // if the next str index does not exist:
                                // change the mapping table to "="
                                // check if d has no fractional digits
                                str.charAt(idx | 0) || (map = '=', idx % 1);
                                // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
                                output += map.charAt(63 & block >> 8 - idx % 1 * 8)
                            ) {
                                charCode = str.charCodeAt(idx += 3 / 4);
                                if (charCode > 0xFF) {
                                    throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
                                }
                                block = block << 8 | charCode;
                            }
                            return output;
                        };

                    // decoder
                    // [https://gist.github.com/1020396] by [https://github.com/atk]
                    object.atob = global && global.atob ? function(str) {
                            return global.atob(str);
                        } :
                        function(input) {
                            var str = String(input).replace(/=+$/, '');
                            if (str.length % 4 == 1) {
                                throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
                            }
                            for (
                                // initialize result and counters
                                var bc = 0, bs, buffer, idx = 0, output = '';
                                // get next character
                                (buffer = str.charAt(idx++));
                                // character found in table? initialize bit storage and add its ascii value;
                                ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
                                    // and if not first of each 4 characters,
                                    // convert the first 8 bits to one ascii character
                                    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
                            ) {
                                // try to find character in table (0-63, not found => -1)
                                buffer = chars.indexOf(buffer);
                            }
                            return output;
                        };
                }(module.exports));

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}],
        196: [function(_dereq_, module, exports) {

            var $ = _dereq_('jquery')
            var React = _dereq_('react')
            var ReactDom = _dereq_('react-dom');
            var utils = _dereq_('../orb.utils');
            var axe = _dereq_('../orb.axe');
            var uiheaders = _dereq_('../orb.ui.header');
            var filtering = _dereq_('../orb.filtering');
            var reactUtils = _dereq_('./orb.react.utils');

            var extraCol = 0;
            var comps = module.exports;

            var pivotId = 1;
            var themeChangeCallbacks = {};

            module.exports.PivotTable = React.createClass({
                displayName: "PivotTable",
                id: pivotId++,
                pgrid: null,
                pgridwidget: null,
                getInitialState: function() {
                    comps.DragManager.init(this);

                    themeChangeCallbacks[this.id] = [];
                    this.registerThemeChanged(this.updateClasses);

                    this.pgridwidget = this.props.pgridwidget;
                    this.pgrid = this.pgridwidget.pgrid;
                    return {};
                },
                sort: function(axetype, field) {
                    this.pgridwidget.sort(axetype, field);
                    this.forceUpdate();
                },
                moveButton: function(button, newAxeType, position) {
                    if (this.pgridwidget.moveField(button.props.field.name, button.props.axetype, newAxeType, position)) {
                        this.forceUpdate();
                    }
                },
                toggleFieldExpansion: function(axetype, field, newState) {
                    if (this.pgridwidget.toggleFieldExpansion(axetype, field, newState)) {
                        this.forceUpdate();
                    }
                },
                toggleSubtotals: function(axetype) {
                    if (this.pgridwidget.toggleSubtotals(axetype)) {
                        this.forceUpdate();
                    }
                },
                toggleGrandtotal: function(axetype) {
                    if (this.pgridwidget.toggleGrandtotal(axetype)) {
                        this.forceUpdate();
                    }
                },
                expandRow: function(cell) {
                    cell.expand();
                    this.forceUpdate();
                },
                collapseRow: function(cell) {
                    cell.subtotalHeader.collapse();
                    this.forceUpdate();
                },
                applyFilter: function(fieldname, operator, term, staticValue, excludeStatic) {
                    this.pgridwidget.applyFilter(fieldname, operator, term, staticValue, excludeStatic);
                    this.forceUpdate();
                },
                registerThemeChanged: function(compCallback) {
                    if (compCallback) {
                        themeChangeCallbacks[this.id].push(compCallback);
                    }
                },
                unregisterThemeChanged: function(compCallback) {
                    var i;
                    if (compCallback && (i = themeChangeCallbacks[this.id].indexOf(compCallback)) >= 0) {
                        themeChangeCallbacks[this.id].splice(i, 1);
                    }
                },
                changeTheme: function(newTheme) {
                    if (this.pgridwidget.pgrid.config.setTheme(newTheme)) {
                        // notify self/sub-components of the theme change
                        for (var i = 0; i < themeChangeCallbacks[this.id].length; i++) {
                            themeChangeCallbacks[this.id][i]();
                        }
                    }
                },
                updateClasses: function() {
                    var thisnode = this;
                    var classes = this.pgridwidget.pgrid.config.theme.getPivotClasses();
                    thisnode.className = classes.container;
                    thisnode.children[1].className = classes.table;
                },
                componentDidUpdate: function() {
                    this.synchronizeCompsWidths();
                },
                componentDidMount: function() {
                    var dataCellsContainerNode = ReactDom.findDOMNode(this.refs.dataCellsContainer);
                    var dataCellsTableNode = ReactDom.findDOMNode(this.refs.dataCellsTable);
                    var colHeadersContainerNode = ReactDom.findDOMNode(this.refs.colHeadersContainer);
                    var rowHeadersContainerNode = ReactDom.findDOMNode(this.refs.rowHeadersContainer);

                    this.refs.horizontalScrollBar.setScrollClient(dataCellsContainerNode, function(scrollPercent) {
                        var scrollAmount = Math.ceil(
                            scrollPercent * (
                                reactUtils.getSize(dataCellsTableNode).width -
                                reactUtils.getSize(dataCellsContainerNode).width
                            )
                        );
                        colHeadersContainerNode.scrollLeft = scrollAmount;
                        dataCellsContainerNode.scrollLeft = scrollAmount;
                    });

                    this.refs.verticalScrollBar.setScrollClient(dataCellsContainerNode, function(scrollPercent) {
                        var scrollAmount = Math.ceil(
                            scrollPercent * (
                                reactUtils.getSize(dataCellsTableNode).height -
                                reactUtils.getSize(dataCellsContainerNode).height
                            )
                        );
                        rowHeadersContainerNode.scrollTop = scrollAmount;
                        dataCellsContainerNode.scrollTop = scrollAmount;
                    });

                    this.synchronizeCompsWidths();
                },
                onWheel: function(e) {
                    var elem;
                    var scrollbar;
                    var amount;

                    if (e.currentTarget == (elem = this.refs.colHeadersContainer)) {
                        scrollbar = this.refs.horizontalScrollBar;
                        amount = e.deltaX || e.deltaY;
                    } else if ((e.currentTarget == (elem = this.refs.rowHeadersContainer)) ||
                        (e.currentTarget == (elem = this.refs.dataCellsContainer))) {
                        scrollbar = this.refs.verticalScrollBar;
                        amount = e.deltaY;
                    }

                    if (scrollbar && scrollbar.scroll(amount, e.deltaMode)) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                },
                synchronizeCompsWidths: function() {
                    var self = this;

                    var pivotWrapperTable = ReactDom.findDOMNode(self.refs.pivotWrapperTable);

                    var nodes = (function() {
                        var nds = {};
                        ['pivotContainer', 'dataCellsContainer', 'dataCellsTable', 'upperbuttonsRow', 'columnbuttonsRow',

                            'colHeadersContainer', 'rowHeadersContainer', 'rowButtonsContainer',
                            'toolbar', 'horizontalScrollBar', 'verticalScrollBar'
                        ].forEach(function(refname) {
                            if (self.refs[refname]) {
                                nds[refname] = {
                                    node: ReactDom.findDOMNode(self.refs[refname])
                                };

                                nds[refname].size = reactUtils.getSize(nds[refname].node);
                            }
                        });
                        return nds;
                    }());

                    // colHeadersTable
                    nodes.colHeadersTable = {
                        node: nodes.colHeadersContainer.node.children[0]
                    };
                    nodes.colHeadersTable.size = reactUtils.getSize(nodes.colHeadersTable.node);

                    // rowHeadersTable
                    nodes.rowHeadersTable = {
                        node: nodes.rowHeadersContainer.node.children[0]
                    };
                    nodes.rowHeadersTable.size = reactUtils.getSize(nodes.rowHeadersTable.node);

                    // get row buttons container width
                    //nodes.rowButtonsContainer.node.style.width = '';
                    var rowButtonsContainerWidth = reactUtils.getSize(nodes.rowButtonsContainer.node.children[0]).width;

                    // get array of dataCellsTable column widths
                    getAllColumnsWidth(nodes.dataCellsTable);
                    // get array of colHeadersTable column widths
                    getAllColumnsWidth(nodes.colHeadersTable);
                    // get array of rowHeadersTable column widths
                    getAllColumnsWidth(nodes.rowHeadersTable);

                    // get the array of max widths between dataCellsTable and colHeadersTable
                    var dataCellsTableMaxWidthArray = [];
                    var dataCellsTableMaxWidth = 0;

                    for (var i = 0; i < nodes.dataCellsTable.widthArray.length; i++) {
                        var mxwidth = Math.max(nodes.dataCellsTable.widthArray[i] + 16, nodes.colHeadersTable.widthArray[i] + 16);
                        dataCellsTableMaxWidthArray.push(mxwidth);
                        dataCellsTableMaxWidth += mxwidth;
                    }

                    var rowHeadersTableWidth = Math.max(nodes.rowHeadersTable.size.width, rowButtonsContainerWidth, 67);
                    var rowDiff = rowHeadersTableWidth - nodes.rowHeadersTable.size.width;
                    if (rowDiff > 0) {
                        nodes.rowHeadersTable.size.width += rowDiff;
                        nodes.rowHeadersTable.widthArray[nodes.rowHeadersTable.widthArray.length - 1] += rowDiff;
                    }

                    // Set dataCellsTable cells widths according to the computed dataCellsTableMaxWidthArray
                    reactUtils.updateTableColGroup(nodes.dataCellsTable.node, dataCellsTableMaxWidthArray);

                    // Set colHeadersTable cells widths according to the computed dataCellsTableMaxWidthArray
                    reactUtils.updateTableColGroup(nodes.colHeadersTable.node, dataCellsTableMaxWidthArray);

                    // Set rowHeadersTable cells widths
                    reactUtils.updateTableColGroup(nodes.rowHeadersTable.node, nodes.rowHeadersTable.widthArray);

                    nodes.dataCellsTable.node.style.width = dataCellsTableMaxWidth + 'px';
                    nodes.colHeadersTable.node.style.width = dataCellsTableMaxWidth + 'px';
                    nodes.rowHeadersTable.node.style.width = rowHeadersTableWidth + 'px';

                    var dataCellsContainerWidth = Math.min(
                        dataCellsTableMaxWidth + 1,
                        nodes.pivotContainer.size.width - rowHeadersTableWidth - nodes.verticalScrollBar.size.width);

                    // Adjust data cells container width
                    nodes.dataCellsContainer.node.style.width = dataCellsContainerWidth + 'px';
                    nodes.colHeadersContainer.node.style.width = dataCellsContainerWidth + 'px';

                    var pivotContainerHeight = this.pgridwidget.pgrid.config.height;

                    if (pivotContainerHeight) {
                        // Adjust data cells container height
                        var dataCellsTableHeight = Math.ceil(Math.min(
                            pivotContainerHeight -
                            (nodes.toolbar ? nodes.toolbar.size.height + 17 : 0) -
                            nodes.upperbuttonsRow.size.height -
                            nodes.columnbuttonsRow.size.height -
                            nodes.colHeadersTable.size.height -
                            nodes.horizontalScrollBar.size.height,
                            nodes.dataCellsTable.size.height));

                        nodes.dataCellsContainer.node.style.height = dataCellsTableHeight + 'px';
                        nodes.rowHeadersContainer.node.style.height = dataCellsTableHeight + 'px';
                    }

                    reactUtils.updateTableColGroup(
                        pivotWrapperTable, [
                            rowHeadersTableWidth,
                            dataCellsContainerWidth,
                            nodes.verticalScrollBar.size.width,
                            Math.max(
                                nodes.pivotContainer.size.width - (
                                    rowHeadersTableWidth +
                                    dataCellsContainerWidth +
                                    nodes.verticalScrollBar.size.width),
                                0)
                        ]);

                    this.refs.horizontalScrollBar.refresh();
                    this.refs.verticalScrollBar.refresh();
                },
                render: function() {

                    var self = this;

                    var config = this.pgridwidget.pgrid.config;
                    var Toolbar = comps.Toolbar;
                    var PivotTableUpperButtons = comps.PivotTableUpperButtons;
                    var PivotTableColumnButtons = comps.PivotTableColumnButtons;
                    var PivotTableRowButtons = comps.PivotTableRowButtons;
                    var PivotTableRowHeaders = comps.PivotTableRowHeaders;
                    var PivotTableColumnHeaders = comps.PivotTableColumnHeaders;
                    var PivotTableDataCells = comps.PivotTableDataCells;
                    var HorizontalScrollBar = comps.HorizontalScrollBar;
                    var VerticalScrollBar = comps.VerticalScrollBar;

                    var classes = config.theme.getPivotClasses();

                    var tblStyle = {};
                    if (config.width) {
                        tblStyle.width = config.width;
                    }
                    if (config.height) {
                        tblStyle.height = config.height;
                    }

                    return (
                        React.createElement("div", {
                                className: classes.container,
                                style: tblStyle,
                                ref: "pivotContainer"
                            },
                            config.toolbar && config.toolbar.visible ? React.createElement("div", {
                                    ref: "toolbar",
                                    className: ""
                                },
                                React.createElement(Toolbar, {
                                    pivotTableComp: self
                                })
                            ) : null,
                            React.createElement("table", {
                                    id: 'tbl-' + self.id,
                                    ref: "pivotWrapperTable",
                                    className: classes.table,
                                    style: {
                                        tableLayout: 'fixed'
                                    }
                                },
                                React.createElement("colgroup", null,
                                    React.createElement("col", {
                                        ref: "column1"
                                    }),
                                    React.createElement("col", {
                                        ref: "column2"
                                    }),
                                    React.createElement("col", {
                                        ref: "column3"
                                    }),
                                    React.createElement("col", {
                                        ref: "column4"
                                    })
                                ),
                                React.createElement("tbody", null,
                                    React.createElement("tr", {
                                            ref: "upperbuttonsRow"
                                        },
                                        React.createElement("td", {
                                                colSpan: "4"
                                            },
                                            React.createElement(PivotTableUpperButtons, {
                                                pivotTableComp: self
                                            })
                                        )
                                    ),
                                    React.createElement("tr", {
                                            ref: "columnbuttonsRow"
                                        },
                                        React.createElement("td", null),
                                        React.createElement("td", null,
                                            React.createElement(PivotTableColumnButtons, {
                                                pivotTableComp: self
                                            })
                                        ),
                                        React.createElement("td", {
                                            colSpan: "2"
                                        })
                                    ),
                                    React.createElement("tr", null,
                                        React.createElement("td", {
                                                style: {
                                                    position: 'relative'
                                                }
                                            },
                                            React.createElement(PivotTableRowButtons, {
                                                pivotTableComp: self,
                                                ref: "rowButtonsContainer"
                                            })
                                        ),
                                        React.createElement("td", null,
                                            React.createElement(PivotTableColumnHeaders, {
                                                pivotTableComp: self,
                                                ref: "colHeadersContainer"
                                            })
                                        ),
                                        React.createElement("td", {
                                            colSpan: "2"
                                        })
                                    ),
                                    React.createElement("tr", null,
                                        React.createElement("td", null,
                                            React.createElement(PivotTableRowHeaders, {
                                                pivotTableComp: self,
                                                ref: "rowHeadersContainer"
                                            })
                                        ),
                                        React.createElement("td", null,
                                            React.createElement("div", {
                                                    className: "inner-table-container data-cntr",
                                                    ref: "dataCellsContainer",
                                                    onWheel: this.onWheel
                                                },
                                                React.createElement(PivotTableDataCells, {
                                                    ref: "dataCellsTable",
                                                    pivotTableComp: self
                                                })
                                            )
                                        ),
                                        React.createElement("td", null,
                                            React.createElement(VerticalScrollBar, {
                                                pivotTableComp: self,
                                                ref: "verticalScrollBar"
                                            })
                                        ),
                                        React.createElement("td", null)
                                    ),
                                    React.createElement("tr", null,
                                        React.createElement("td", null),
                                        React.createElement("td", null,
                                            React.createElement(HorizontalScrollBar, {
                                                pivotTableComp: self,
                                                ref: "horizontalScrollBar"
                                            })
                                        ),
                                        React.createElement("td", {
                                            colSpan: "2"
                                        })
                                    )
                                )
                            ),
                            React.createElement("div", {
                                className: "orb-overlay orb-overlay-hidden",
                                id: 'drilldialog' + self.id
                            })
                        )
                    );
                }
            });

            function getAllColumnsWidth(tblObject) {
                if (tblObject && tblObject.node) {

                    var tbl = tblObject.node;
                    var widthArray = [];

                    for (var rowIndex = 0; rowIndex < tbl.rows.length; rowIndex++) {
                        // current row
                        var currRow = tbl.rows[rowIndex];
                        // reset widthArray index
                        var arrayIndex = 0;
                        var currWidth = null;

                        // get the width of each cell within current row
                        for (var cellIndex = 0; cellIndex < currRow.cells.length; cellIndex++) {
                            // current cell
                            var currCell = currRow.cells[cellIndex];

                            if (currCell.__orb._visible) {
                                // cell width
                                //var cellwidth = Math.ceil(reactUtils.getSize(currCell.children[0]).width/currCell.colSpan);
                                var cellwidth = Math.ceil((currCell.__orb._textWidth / currCell.__orb._colSpan) + currCell.__orb._paddingLeft + currCell.__orb._paddingRight + currCell.__orb._borderLeftWidth + currCell.__orb._borderRightWidth);
                                // whether current cell spans vertically to the last row
                                var rowsSpan = currCell.__orb._rowSpan > 1 && currCell.__orb._rowSpan >= tbl.rows.length - rowIndex;

                                // if current cell spans over more than one column, add its width (its) 'colSpan' number of times
                                for (var cspan = 0; cspan < currCell.__orb._colSpan; cspan++) {
                                    // If cell span over more than 1 row: insert its width into widthArray at arrayIndex
                                    // Else: either expand widthArray if necessary or replace the width if its smaller than current cell width

                                    currWidth = widthArray[arrayIndex];
                                    // skip inhibited widths (width that belongs to an upper cell than spans vertically to current row)
                                    while (currWidth && currWidth.inhibit > 0) {
                                        currWidth.inhibit--;
                                        arrayIndex++;
                                        currWidth = widthArray[arrayIndex];
                                    }

                                    if (widthArray.length - 1 < arrayIndex) {
                                        widthArray.push({
                                            width: cellwidth
                                        });
                                    } else if (cellwidth > widthArray[arrayIndex].width) {
                                        widthArray[arrayIndex].width = cellwidth;
                                    }

                                    widthArray[arrayIndex].inhibit = currCell.__orb._rowSpan - 1;

                                    // increment widthArray index
                                    arrayIndex++;
                                }
                            }
                        }

                        // decrement inhibited state of all widths unsed in widthArray (not reached by current row cells)
                        currWidth = widthArray[arrayIndex];
                        while (currWidth) {
                            if (currWidth.inhibit > 0) {
                                currWidth.inhibit--;
                            }
                            arrayIndex++;
                            currWidth = widthArray[arrayIndex];
                        }
                    }

                    // set widthArray to the tblObject
                    tblObject.size.width = 0;
                    tblObject.widthArray = widthArray.map(function(item, index) {
                        tblObject.size.width += item.width;
                        return item.width;
                    });
                }
            }

            function setTableWidths(tblObject, newWidthArray) {
                if (tblObject && tblObject.node) {

                    // reset table width
                    (tblObject.size = (tblObject.size || {})).width = 0;

                    var tbl = tblObject.node;

                    // for each row, set its cells width
                    for (var rowIndex = 0; rowIndex < tbl.rows.length; rowIndex++) {

                        // current row
                        var currRow = tbl.rows[rowIndex];
                        // index in newWidthArray
                        var arrayIndex = 0;
                        var currWidth = null;

                        // set width of each cell
                        for (var cellIndex = 0; cellIndex < currRow.cells.length; cellIndex++) {

                            // current cell
                            var currCell = currRow.cells[cellIndex];
                            if (currCell.__orb._visible) {
                                // cell width
                                var newCellWidth = 0;
                                // whether current cell spans vertically more than 1 row
                                var rowsSpan = currCell.__orb._rowSpan > 1 && rowIndex < tbl.rows.length - 1;

                                // current cell width is the sum of (its) "colspan" items in newWidthArray starting at 'arrayIndex'
                                // 'arrayIndex' should be incremented by an amount equal to current cell 'colspan' but should also skip 'inhibited' cells
                                for (var cspan = 0; cspan < currCell.__orb._colSpan; cspan++) {
                                    currWidth = newWidthArray[arrayIndex];
                                    // skip inhibited widths (width that belongs to an upper cell than spans vertically to current row)
                                    while (currWidth && currWidth.inhibit > 0) {
                                        currWidth.inhibit--;
                                        arrayIndex++;
                                        currWidth = newWidthArray[arrayIndex];
                                    }

                                    if (currWidth) {
                                        // add width of cells participating in the span
                                        newCellWidth += currWidth.width;
                                        // if current cell spans vertically more than 1 row, mark its width as inhibited for all cells participating in this span
                                        if (rowsSpan) {
                                            currWidth.inhibit = currCell.__orb._rowSpan - 1;
                                        }

                                        // advance newWidthArray index
                                        arrayIndex++;
                                    }
                                }

                                currCell.children[0].style.width = newCellWidth + 'px';

                                // set table width (only in first iteration)
                                if (rowIndex === 0) {
                                    var outerCellWidth = 0;
                                    if (currCell.__orb) {
                                        outerCellWidth = currCell.__orb._colSpan * (Math.ceil(currCell.__orb._paddingLeft + currCell.__orb._paddingRight + currCell.__orb._borderLeftWidth + currCell.__orb._borderRightWidth));
                                    }
                                    tblObject.size.width += newCellWidth + outerCellWidth;
                                }
                            }
                        }

                        // decrement inhibited state of all widths unsed in newWidthArray (not reached by current row cells)
                        currWidth = newWidthArray[arrayIndex];
                        while (currWidth) {
                            if (currWidth.inhibit > 0) {
                                currWidth.inhibit--;
                            }
                            arrayIndex++;
                            currWidth = newWidthArray[arrayIndex];
                        }
                    }
                }
            }

            function clearTableWidths(tbl) {
                if (tbl) {
                    for (var rowIndex = 0; rowIndex < tbl.rows.length; rowIndex++) {
                        var row = tbl.rows[rowIndex];
                        for (var cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {
                            row.cells[cellIndex].children[0].style.width = '';
                        }
                    }
                    tbl.style.width = '';
                }
            }

            module.exports.PivotRow = React.createClass({
                displayName: "PivotRow",
                render: function() {
                    var self = this;
                    var PivotCell = comps.PivotCell;

                    var lastCellIndex = this.props.row.length - 1;
                    var cell0 = this.props.row[0];
                    var leftmostCellFound = false;
                    var layoutInfos = self.props.layoutInfos;
                    var cells;

                    var rowstyle = {};

                    var istopmost = false;

                    cells = this.props.row.map(function(cell, index) {

                        var isleftmost = false;

                        // If current cells are column/data headers and left most cell is not found yet
                        // and last row left most cell does not span vertically over the current one and current one is visible 
                        // then mark IT as the left most cell
                        if (cell.visible() && layoutInfos) {
                            if (cell.dim) {
                                if ((cell.dim.isRoot && layoutInfos.topMostCells[cell.dim.depth - 1] === undefined) || (!cell.dim.isRoot && layoutInfos.topMostCells[cell.dim.depth] === undefined && (cell.dim.parent.isRoot || layoutInfos.topMostCells[cell.dim.depth + 1] === cell.dim.parent))) {
                                    istopmost = true;
                                    layoutInfos.topMostCells[cell.dim.depth] = cell.dim;
                                }
                            } else if (!layoutInfos.topMostCells['0']) {
                                istopmost = layoutInfos.topMostCells['0'] = true;
                            }

                            if (!leftmostCellFound && (self.props.axetype === axe.Type.DATA || self.props.axetype === axe.Type.COLUMNS) &&
                                layoutInfos.lastLeftMostCellVSpan === 0) {

                                isleftmost = leftmostCellFound = true;
                                layoutInfos.lastLeftMostCellVSpan = cell.vspan() - 1;
                            }
                        }

                        return React.createElement(PivotCell, {
                            key: index,
                            cell: cell,
                            leftmost: isleftmost,
                            topmost: istopmost,
                            pivotTableComp: self.props.pivotTableComp
                        });
                    });

                    // decrement lastLeftMostCellVSpan
                    if (layoutInfos && layoutInfos.lastLeftMostCellVSpan > 0 && !leftmostCellFound) {
                        layoutInfos.lastLeftMostCellVSpan--;
                    }

                    return (
                        React.createElement("tr", {
                                style: rowstyle
                            },
                            cells
                        )
                    );
                }
            });

            var _paddingLeft = null;
            var _borderLeft = null;

            module.exports.PivotCell = React.createClass({
                displayName: "PivotCell",
                expand: function() {
                    this.props.pivotTableComp.expandRow(this.props.cell);
                },
                collapse: function() {
                    this.props.pivotTableComp.collapseRow(this.props.cell);
                },
                updateCellInfos: function() {
                    var node = this.refs.cell;
                    var cell = this.props.cell;
                    node.__orb = node.__orb || {};

                    if (!cell.visible()) {

                        node.__orb._visible = false;

                    } else {
                        var cellContentNode = this.refs.cellContent;

                        var text = node.textContent;
                        var propList = [];
                        var retPaddingLeft = _paddingLeft == null;
                        var retBorderLeft = !this.props.leftmost && _borderLeft == null;

                        if (retPaddingLeft) {
                            propList.push('padding-left');
                        }

                        if (retBorderLeft) {
                            propList.push('border-left-width');
                        }

                        if (propList.length > 0) {
                            var nodeStyle = reactUtils.getStyle(cellContentNode, propList, true);

                            if (retPaddingLeft) {
                                _paddingLeft = parseFloat(nodeStyle[0]);
                            }

                            if (retBorderLeft) {
                                _borderLeft = parseFloat(nodeStyle[retPaddingLeft ? 1 : 0]);
                            }
                        }

                        reactUtils.removeClass(cellContentNode, 'cell-hidden');

                        node.__orb._visible = true;
                        node.__orb._textWidth = reactUtils.getSize(cellContentNode).width;
                        node.__orb._colSpan = this.props.cell.hspan(true) || 1;
                        node.__orb._rowSpan = this.props.cell.vspan(true) || 1;
                        node.__orb._paddingLeft = _paddingLeft;
                        node.__orb._paddingRight = _paddingLeft;
                        node.__orb._borderLeftWidth = this.props.leftmost ? 0 : _borderLeft;
                        node.__orb._borderRightWidth = 0;
                    }
                },
                componentDidMount: function() {
                    this.updateCellInfos();
                },
                componentDidUpdate: function() {
                    this.updateCellInfos();
                },
                shouldComponentUpdate: function(nextProps, nextState) {
                    if (nextProps.cell && nextProps.cell == this.props.cell && !this._latestVisibleState && !nextProps.cell.visible()) {
                        return false;
                    }
                    return true;
                },
                _latestVisibleState: false,
                render: function() {
                    var self = this;
                    var cell = this.props.cell;
                    var divcontent = [];
                    var value;
                    var cellClick;
                    var headerPushed = false;

                    this._latestVisibleState = cell.visible();

                    switch (cell.template) {
                        case 'cell-template-row-header':
                        case 'cell-template-column-header':
                            var isWrapper = cell.type === uiheaders.HeaderType.WRAPPER && cell.dim.field.subTotal.visible && cell.dim.field.subTotal.collapsible;
                            var isSubtotal = cell.type === uiheaders.HeaderType.SUB_TOTAL && !cell.expanded;
                            if (isWrapper || isSubtotal) {
                                headerPushed = true;

                                divcontent.push(React.createElement("table", {
                                        key: "header-value",
                                        ref: "cellContent"
                                    },
                                    React.createElement("tbody", null,
                                        React.createElement("tr", null, React.createElement("td", {
                                                className: "orb-tgl-btn"
                                            }, React.createElement("div", {
                                                className: 'orb-tgl-btn-' + (isWrapper ? 'down' : 'right'),
                                                onClick: (isWrapper ? this.collapse : this.expand)
                                            })),
                                            React.createElement("td", {
                                                className: "hdr-val"
                                            }, React.createElement("div", {
                                                dangerouslySetInnerHTML: {
                                                    __html: cell.value || '&#160;'
                                                }
                                            })))
                                    )));
                            } else {
                                value = (cell.value || '&#160;') + (cell.type === uiheaders.HeaderType.SUB_TOTAL ? ' Total' : '');
                            }
                            break;
                        case 'cell-template-dataheader':
                            value = cell.value.caption;
                            break;
                        case 'cell-template-datavalue':
                            value = (cell.datafield && cell.datafield.formatFunc) ? cell.datafield.formatFunc()(cell.value) : cell.value;
                            cellClick = function() {
                                self.props.pivotTableComp.pgridwidget.drilldown(cell, self.props.pivotTableComp.id);
                            };
                            break;
                        default:
                            break;
                    }

                    if (!headerPushed) {
                        var headerClassName;
                        switch (cell.template) {
                            case 'cell-template-datavalue':
                                headerClassName = 'cell-data';
                                break;
                            default:
                                if (cell.template != 'cell-template-dataheader' && cell.type !== uiheaders.HeaderType.GRAND_TOTAL) {
                                    headerClassName = 'hdr-val';
                                }
                        }
                        divcontent.push(React.createElement("div", {
                            key: "cell-value",
                            ref: "cellContent",
                            className: headerClassName
                        }, React.createElement("div", {
                            dangerouslySetInnerHTML: {
                                __html: value || '&#160;'
                            }
                        })));
                    }

                    return React.createElement("td", {
                            className: getClassname(this.props),
                            onDoubleClick: cellClick,
                            colSpan: cell.hspan(),
                            rowSpan: cell.vspan(),
                            ref: "cell"
                        },
                        React.createElement("div", null,
                            divcontent
                        )
                    );
                }
            });

            function getClassname(compProps) {
                var cell = compProps.cell;
                var classname = cell.cssclass;
                var isEmpty = cell.template === 'cell-template-empty';

                if (!cell.visible()) {
                    classname += ' cell-hidden';
                }

                if (cell.type === uiheaders.HeaderType.SUB_TOTAL && cell.expanded) {
                    classname += ' header-st-exp';
                }

                if (cell.type === uiheaders.HeaderType.GRAND_TOTAL) {
                    if (cell.dim.depth === 1) {
                        classname += ' header-nofields';
                    } else if (cell.dim.depth > 2) {
                        classname += ' header-gt-exp';
                    }
                }

                if (compProps.leftmost) {
                    classname += ' ' + (cell.template === 'cell-template-datavalue' ? 'cell' : 'header') + '-leftmost';
                }

                if (compProps.topmost) {
                    classname += ' cell-topmost';
                }

                return classname;
            }

            var dragManager = module.exports.DragManager = (function() {

                var _pivotComp = null;

                var _currDragElement = null;
                var _currDropTarget = null;
                var _currDropIndicator = null;

                var _dragNode = null;
                var _dropTargets = [];
                var _dropIndicators = [];

                function doElementsOverlap(elem1Rect, elem2Rect) {
                    return !(elem1Rect.right < elem2Rect.left ||
                        elem1Rect.left > elem2Rect.right ||
                        elem1Rect.bottom < elem2Rect.top ||
                        elem1Rect.top > elem2Rect.bottom);
                }

                function setCurrDropTarget(dropTarget, callback) {
                    if (_currDropTarget) {
                        signalDragEnd(_currDropTarget, function() {
                            _currDropTarget = dropTarget;
                            signalDragOver(dropTarget, callback);
                        });
                    } else {
                        _currDropTarget = dropTarget;
                        signalDragOver(dropTarget, callback);
                    }
                }

                function setCurrDropIndicator(dropIndicator) {
                    if (_currDropIndicator) {
                        signalDragEnd(_currDropIndicator, function() {
                            _currDropIndicator = dropIndicator;
                            signalDragOver(dropIndicator);
                        });
                    } else {
                        _currDropIndicator = dropIndicator;
                        signalDragOver(dropIndicator);
                    }
                }

                function signalDragOver(target, callback) {
                    if (target && target.onDragOver) {
                        target.onDragOver(callback);
                    } else if (callback) {
                        callback();
                    }
                }

                function signalDragEnd(target, callback) {
                    //console.log('signalDragEnd()', target)
                    if (target && target.onDragEnd && (!target.position || (target.position != 0))) {
                        console.log('with signalDragEnd()', target)
                        target.onDragEnd(callback);
                    } else if (callback) {
                        console.log('without signalDragEnd()', target)
                        callback();
                    }
                }

                function getDropTarget() {
                    return reactUtils.forEach(_dropTargets, function(target) {
                        if (target.component.state.isover) {
                            return target;
                        }
                    }, true);
                }

                function getDropIndicator() {
                    return reactUtils.forEach(_dropIndicators, function(indicator) {
                        if (indicator.component.state.isover) {
                            return indicator;
                        }
                    }, true);
                }

                var _initialized = false;

                return {
                    init: function(pivotComp) {
                        _initialized = true;
                        _pivotComp = pivotComp;
                    },
                    setDragElement: function(elem) {

                        var prevDragElement = _currDragElement;
                        _currDragElement = elem;
                        if (_currDragElement != prevDragElement) {
                            if (elem == null) {

                                if (_currDropTarget) {
                                    var position = _currDropIndicator != null ? _currDropIndicator.position : null;
                                    _pivotComp.moveButton(prevDragElement, _currDropTarget.axetype, position);
                                }

                                _dragNode = null;
                                setCurrDropTarget(null);
                                setCurrDropIndicator(null);

                            } else {
                                _dragNode = _currDragElement;
                            }
                        }
                    },
                    registerTarget: function(target, axetype, dragOverHandler, dargEndHandler) {
                        _dropTargets.push({
                            component: target,
                            axetype: axetype,
                            onDragOver: dragOverHandler,
                            onDragEnd: dargEndHandler
                        });
                    },
                    unregisterTarget: function(target) {
                        var tindex;
                        for (var i = 0; i < _dropTargets.length; i++) {
                            if (_dropTargets[i].component == target) {
                                tindex = i;
                                break;
                            }
                        }
                        if (tindex != null) {
                            _dropTargets.splice(tindex, 1);
                        }
                    },
                    registerIndicator: function(indicator, axetype, position, dragOverHandler, dargEndHandler) {
                        _dropIndicators.push({
                            component: indicator,
                            axetype: axetype,
                            position: position,
                            onDragOver: dragOverHandler,
                            onDragEnd: dargEndHandler
                        });
                    },
                    unregisterIndicator: function(indicator) {
                        var iindex;
                        for (var i = 0; i < _dropIndicators.length; i++) {
                            if (_dropIndicators[i].component == indicator) {
                                iindex = i;
                                break;
                            }
                        }
                        if (iindex != null) {
                            _dropIndicators.splice(iindex, 1);
                        }
                    },
                    elementMoved: function() {
                        if (_currDragElement != null) {
                            var dragNodeRect = _dragNode.refs.filterButton.getBoundingClientRect();
                            var foundTarget;

                            reactUtils.forEach(_dropTargets, function(target) {
                                if (!foundTarget) {
                                    var tnodeRect = target.component.getBoundingClientRect();
                                    var isOverlap = doElementsOverlap(dragNodeRect, tnodeRect);
                                    if (isOverlap) {
                                        foundTarget = target;
                                        return;
                                    }
                                }
                            }, true);

                            if (foundTarget) {
                                setCurrDropTarget(foundTarget, function() {
                                    var foundIndicator = null;

                                    reactUtils.forEach(_dropIndicators, function(indicator, index) {
                                        if (!foundIndicator) {

                                            var elementOwnIndicator = indicator.component.props.axetype === _currDragElement.props.axetype &&
                                                indicator.component.props.position === _currDragElement.props.position;

                                            var targetIndicator = indicator.component.props.axetype === foundTarget.axetype;
                                            if (targetIndicator && !elementOwnIndicator) {
                                                var tnodeRect = indicator.component.refs.indicator.getBoundingClientRect();
                                                var isOverlap = doElementsOverlap(dragNodeRect, tnodeRect);
                                                if (isOverlap) {
                                                    foundIndicator = indicator;
                                                    return;
                                                }
                                            }
                                        }
                                    });

                                    if (!foundIndicator) {
                                        var axeIndicators = _dropIndicators.filter(function(indicator) {
                                            return indicator.component.props.axetype === foundTarget.axetype;
                                        });
                                        if (axeIndicators.length > 0) {
                                            foundIndicator = axeIndicators[axeIndicators.length - 1];
                                        }
                                    }

                                    //console.log('elementMoved() foundIndicator', foundIndicator)
                                    setCurrDropIndicator(foundIndicator);
                                });
                            }
                        }
                    }
                };
            }());

            module.exports.DropIndicator = React.createClass({
                displayName: 'DropIndicator',
                getInitialState: function() {
                    dragManager.registerIndicator(this, this.props.axetype, this.props.position, this.onDragOver, this.onDragEnd);
                    return {
                        isover: false
                    };
                },
                componentWillUnmount: function() {
                    dragManager.unregisterIndicator(this);
                },
                onDragOver: function(callback) {
                    if (this.isMounted()) {
                        this.setState({
                            isover: true
                        }, callback);
                    } else if (callback) {
                        callback();
                    }
                },
                onDragEnd: function(callback) {
                    if (this.isMounted()) {
                        this.setState({
                            isover: false
                        }, callback);
                    } else if (callback) {
                        callback();
                    }
                },
                render: function() {
                    var classname = 'drp-indic';

                    if (this.props.isFirst) {
                        classname += ' drp-indic-first';
                    }

                    if (this.props.isLast) {
                        classname += ' drp-indic-last';
                    }

                    var style = {};
                    if (this.state.isover) {
                        classname += ' drp-indic-over';
                    }

                    return React.createElement("div", {
                        ref: "indicator",
                        style: style,
                        className: classname
                    });
                }
            });

            var dtid = 0;

            module.exports.DropTarget = React.createClass({
                displayName: "DropTarget",
                getInitialState: function() {
                    this.dtid = ++dtid;
                    return {
                        isover: false
                    };
                },
                componentDidMount: function() {
                    dragManager.registerTarget(this.refs.drpTrgt, this.props.axetype, this.onDragOver, this.onDragEnd);
                },
                componentWillUnmount: function() {
                    dragManager.unregisterTarget(this.refs.drpTrgt);
                },
                onDragOver: function(callback) {
                    if (this.isMounted()) {
                        this.setState({
                            isover: true
                        }, callback);
                    } else if (callback) {
                        callback();
                    }
                },
                onDragEnd: function(callback) {
                    if (this.isMounted()) {
                        this.setState({
                            isover: false
                        }, callback);
                    } else if (callback) {
                        callback();
                    }
                },
                render: function() {
                    var self = this;
                    var DropIndicator = module.exports.DropIndicator;

                    var buttons = this.props.buttons.map(function(button, index) {
                        if (index < self.props.buttons.length - 1) {
                            return [
                                React.createElement("td", null, React.createElement(DropIndicator, {
                                    isFirst: index === 0,
                                    position: index,
                                    axetype: self.props.axetype
                                })),
                                React.createElement("td", null, button)
                            ];
                        } else {
                            return [
                                React.createElement("td", null, React.createElement(DropIndicator, {
                                    isFirst: index === 0,
                                    position: index,
                                    axetype: self.props.axetype
                                })),
                                React.createElement("td", null, button),
                                React.createElement("td", null, React.createElement(DropIndicator, {
                                    isLast: true,
                                    position: null,
                                    axetype: self.props.axetype
                                }))
                            ];
                        }
                    });

                    var style = self.props.axetype === axe.Type.ROWS ? {
                        position: 'absolute',
                        left: 0,
                        bottom: 0
                    } : null;

                    return React.createElement("div", {
                            ref: "drpTrgt",
                            className: 'drp-trgt' + (this.state.isover ? ' drp-trgt-over' : '') + (buttons.length === 0 ? ' drp-trgt-empty' : ''),
                            style: style
                        },
                        React.createElement("table", null,
                            React.createElement("tbody", null,
                                React.createElement("tr", null,
                                    buttons
                                )
                            )
                        )
                    );
                }
            });

            var pbid = 0;

            module.exports.PivotButton = React.createClass({
                displayName: 'PivotButton',
                getInitialState: function() {
                    this.pbid = ++pbid;

                    // initial state, all zero.
                    return {
                        pos: {
                            x: 0,
                            y: 0
                        },
                        startpos: {
                            x: 0,
                            y: 0
                        },
                        mousedown: false,
                        dragging: false
                    };
                },
                onFilterMouseDown: function(e) {
                    // left mouse button only
                    console.log('onFilterMouseDown()', e, e.button)
                    if (e.button !== 0) return;

                    var filterButton = this.refs.filterButton;
                    var filterButtonPos = reactUtils.getOffset(this.refs.filterButton);
                    var filterContainer = document.createElement('div');

                    var filterPanelFactory = React.createFactory(comps.FilterPanel);
                    var filterPanel = filterPanelFactory({
                        field: this.props.field.name,
                        pivotTableComp: this.props.pivotTableComp
                    });

                    filterContainer.className = this.props.pivotTableComp.pgrid.config.theme.getFilterClasses().container;
                    filterContainer.style.top = filterButtonPos.y + 'px';
                    filterContainer.style.left = filterButtonPos.x + 'px';
                    document.body.appendChild(filterContainer);

                    ReactDom.render(filterPanel, filterContainer);

                    // prevent event bubbling (to prevent text selection while dragging for example)
                    e.stopPropagation();
                    e.preventDefault();
                },
                componentDidUpdate: function() {
                    if (this.props.pivotTableComp.pgrid.config.canMoveFields) {
                        if (!this.state.mousedown) {
                            // mouse not down, don't care about mouse up/move events.
                            dragManager.setDragElement(null);
                            document.removeEventListener('mousemove', this.onMouseMove);
                        } else if (this.state.mousedown) {
                            // mouse down, interested by mouse up/move events.
                            dragManager.setDragElement(this);
                            document.addEventListener('mousemove', this.onMouseMove);
                        }
                    }
                },
                componentDidMount: function() {
                    this.props.pivotTableComp.registerThemeChanged(this.updateClasses);
                },
                componentWillUnmount: function() {
                    this.props.pivotTableComp.unregisterThemeChanged(this.updateClasses);
                    document.removeEventListener('mousemove', this.onMouseMove);
                },
                onMouseDown: function(e) {
                    // drag/sort with left mouse button
                    if (e.button !== 0) return;

                    if (e.ctrlKey) {
                        this.props.pivotTableComp.toggleFieldExpansion(this.props.axetype, this.props.field);
                    } else {

                        var thispos = reactUtils.getOffset(this.refs.filterButton);

                        var modalContentPos = $('#modal-content > div:first').position()

                        if (!modalContentPos) {
                            modalContentPos = {
                                left: 0,
                                top: 0
                            }
                        }

                        // inform mousedown, save start pos
                        this.setState({
                            mousedown: true,
                            mouseoffset: {
                                x: thispos.x - e.pageX - modalContentPos.left,
                                y: thispos.y - e.pageY - modalContentPos.top
                            },
                            startpos: {
                                x: e.pageX,
                                y: e.pageY
                            }
                        });
                    }

                    // prevent event bubbling (to prevent text selection while dragging for example)
                    e.stopPropagation();
                    e.preventDefault();
                },
                onMouseUp: function(e) {
                    console.log('onMouseUp()', e.button)
                    var isdragged = this.state.dragging;

                    this.setState({
                        mousedown: false,
                        dragging: false,
                        size: null,
                        pos: {
                            x: 0,
                            y: 0
                        }
                    });

                    if (!e.ctrlKey && !isdragged) {
                        // if button was not dragged, proceed as a click
                        this.props.pivotTableComp.sort(this.props.axetype, this.props.field);
                    }
                },
                onMouseMove: function(e) {
                    // if the mouse is not down while moving, return (no drag)
                    if (!this.props.pivotTableComp.pgrid.config.canMoveFields || !this.state.mousedown) return;

                    var size = null;
                    if (!this.state.dragging) {
                        size = reactUtils.getSize(this.refs.filterButton);
                    } else {
                        size = this.state.size;
                    }

                    var newpos = {
                        x: e.pageX + this.state.mouseoffset.x,
                        y: e.pageY + this.state.mouseoffset.y
                    };

                    this.setState({
                        dragging: true,
                        size: size,
                        pos: newpos
                    });

                    dragManager.elementMoved();

                    e.stopPropagation();
                    e.preventDefault();
                },
                updateClasses: function() {
                    this.className = this.props.pivotTableComp.pgrid.config.theme.getButtonClasses().pivotButton;
                },
                render: function() {
                    var self = this;
                    var divstyle = {
                        left: self.state.pos.x + 'px',
                        top: self.state.pos.y + 'px',
                        position: self.state.dragging ? 'fixed' : '',
                        zIndex: 101
                    };

                    var buttonTextStyle = {
                        display: 'inline-flex'
                    }

                    if (self.state.size) {
                        divstyle.width = self.state.size.width + 'px';
                    }

                    var sortDirectionClass = self.props.field.sort.order === 'asc' ?
                        'sort ascending ' :
                        //' \u2191' :
                        (self.props.field.sort.order === 'desc' ?
                            'sort descending ' :
                            //' \u2193' :
                            '');
                    var filterClass = (self.state.dragging ? '' : 'fltr-btn') + (this.props.pivotTableComp.pgrid.isFieldFiltered(this.props.field.name) ? ' fltr-btn-active' : '');
                    var fieldAggFunc = '';
                    if (self.props.axetype === axe.Type.DATA) {
                        fieldAggFunc = React.createElement("small", null, ' (' + self.props.field.aggregateFuncName + ')');
                    }

                    return React.createElement("div", {
                            ref: "filterButton",
                            key: self.props.field.name,
                            className: this.props.pivotTableComp.pgrid.config.theme.getButtonClasses().pivotButton,
                            onMouseDown: this.onMouseDown,
                            onMouseUp: this.onMouseUp,
                            style: divstyle
                        },
                        React.createElement("i", {
                            className: filterClass + " filter icon",
                            onMouseDown: this.state.dragging ? null : this.onFilterMouseDown
                        }),
                        React.createElement("div", {
                            style: buttonTextStyle
                        }, this.props.field.caption, fieldAggFunc, " ", React.createElement("i", {
                            className: sortDirectionClass + 'icon'
                        }))

                    );
                }
            });

            module.exports.PivotTableUpperButtons = React.createClass({
                displayName: "PivotTableUpperButtons",
                render: function() {
                    var self = this;
                    var PivotButton = comps.PivotButton;
                    var DropTarget = comps.DropTarget;

                    var config = this.props.pivotTableComp.pgridwidget.pgrid.config;

                    var fieldsDropTarget;
                    if (config.canMoveFields) {
                        var fieldsButtons = config.availablefields().map(function(field, index) {
                            return React.createElement(PivotButton, {
                                key: field.name,
                                field: field,
                                axetype: null,
                                position: index,
                                pivotTableComp: self.props.pivotTableComp
                            });
                        });
                        fieldsDropTarget = React.createElement("tr", null,
                            React.createElement("td", {
                                    className: "av-flds"
                                },
                                React.createElement(DropTarget, {
                                    buttons: fieldsButtons,
                                    axetype: null
                                })
                            )
                        );
                    } else {
                        fieldsDropTarget = null;
                    }

                    var dataButtons = config.dataFields.map(function(field, index) {
                        return React.createElement(PivotButton, {
                            key: field.name,
                            field: field,
                            axetype: axe.Type.DATA,
                            position: index,
                            pivotTableComp: self.props.pivotTableComp
                        });
                    });

                    var dataDropTarget = React.createElement("tr", null,
                        React.createElement("td", {
                                className: "empty"
                            },
                            React.createElement(DropTarget, {
                                buttons: dataButtons,
                                axetype: axe.Type.DATA
                            })
                        )
                    );

                    return React.createElement("table", {
                            className: "inner-table upper-buttons"
                        },
                        React.createElement("tbody", null,
                            React.createElement("tr", null,
                                React.createElement("td", {
                                        className: "flds-grp-cap"
                                    },
                                    React.createElement("div", null, "Fields")
                                )
                            ),
                            fieldsDropTarget,
                            React.createElement("tr", null,
                                React.createElement("td", {
                                        className: "flds-grp-cap"
                                    },
                                    React.createElement("div", null, "Data")
                                )
                            ),
                            dataDropTarget
                        )
                    );
                }
            });

            module.exports.PivotTableColumnButtons = React.createClass({
                displayName: "PivotTableColumnButtons",
                render: function() {
                    var self = this;
                    var PivotButton = comps.PivotButton;
                    var DropTarget = comps.DropTarget;

                    var config = this.props.pivotTableComp.pgridwidget.pgrid.config;

                    var columnButtons = config.columnFields.map(function(field, index) {
                        return React.createElement(PivotButton, {
                            key: field.name,
                            field: field,
                            axetype: axe.Type.COLUMNS,
                            position: index,
                            pivotTableComp: self.props.pivotTableComp
                        });
                    });

                    return React.createElement(DropTarget, {
                        buttons: columnButtons,
                        axetype: axe.Type.COLUMNS
                    });
                }
            });

            module.exports.PivotTableRowButtons = React.createClass({
                displayName: "PivotTableRowButtons",
                render: function() {
                    var self = this;
                    var PivotButton = comps.PivotButton;
                    var DropTarget = comps.DropTarget;

                    var config = this.props.pivotTableComp.pgridwidget.pgrid.config;

                    var rowButtons = config.rowFields.map(function(field, index) {
                        return React.createElement(PivotButton, {
                            key: field.name,
                            field: field,
                            axetype: axe.Type.ROWS,
                            position: index,
                            pivotTableComp: self.props.pivotTableComp
                        });
                    });

                    return React.createElement(DropTarget, {
                        buttons: rowButtons,
                        axetype: axe.Type.ROWS
                    });
                }
            });

            module.exports.PivotTableColumnHeaders = React.createClass({
                displayName: "PivotTableColumnHeaders",
                render: function() {
                    var self = this;
                    var PivotRow = comps.PivotRow;
                    var pgridwidget = this.props.pivotTableComp.pgridwidget;
                    var cntrClass = pgridwidget.columns.headers.length === 0 ? '' : ' columns-cntr';

                    var layoutInfos = {
                        lastLeftMostCellVSpan: 0,
                        topMostCells: {}
                    };

                    var columnHeaders = pgridwidget.columns.headers.map(function(headerRow, index) {
                        return React.createElement(PivotRow, {
                            key: index,
                            row: headerRow,
                            axetype: axe.Type.COLUMNS,
                            pivotTableComp: self.props.pivotTableComp,
                            layoutInfos: layoutInfos
                        });
                    });

                    return React.createElement("div", {
                            className: 'inner-table-container' + cntrClass,
                            ref: "colHeadersContainer",
                            onWheel: this.props.pivotTableComp.onWheel
                        },
                        React.createElement("table", {
                                className: "inner-table"
                            },
                            React.createElement("colgroup", null),
                            React.createElement("tbody", null,
                                columnHeaders
                            )
                        )
                    );
                }
            });

            module.exports.PivotTableRowHeaders = React.createClass({
                displayName: "PivotTableRowHeaders",
                setColGroup: function(widths) {
                    var node = this.refs.rowHeadersContainer;
                    var colGroupNode = this.refs.colgroup;
                    node.style.tableLayout = 'auto';

                    colGroupNode.innerHTML = '';
                    for (var i = 0; i < widths.length; i++) {
                        var col = document.createElement('col');
                        col.style.width = (widths[i] + 8) + 'px';
                        colGroupNode.appendChild(col);
                    }
                    node.style.tableLayout = 'fixed';
                },
                render: function() {
                    var self = this;
                    var PivotRow = comps.PivotRow;
                    var pgridwidget = this.props.pivotTableComp.pgridwidget;
                    var cntrClass = pgridwidget.rows.headers.length === 0 ? '' : ' rows-cntr';

                    var layoutInfos = {
                        lastLeftMostCellVSpan: 0,
                        topMostCells: {}
                    };

                    var rowHeaders = pgridwidget.rows.headers.map(function(headerRow, index) {
                        return React.createElement(PivotRow, {
                            key: index,
                            row: headerRow,
                            axetype: axe.Type.ROWS,
                            layoutInfos: layoutInfos,
                            pivotTableComp: self.props.pivotTableComp
                        });
                    });

                    return React.createElement("div", {
                            className: 'inner-table-container' + cntrClass,
                            ref: "rowHeadersContainer",
                            onWheel: this.props.pivotTableComp.onWheel
                        },
                        React.createElement("table", {
                                className: "inner-table"
                            },
                            React.createElement("colgroup", {
                                ref: "colgroup"
                            }),
                            React.createElement("tbody", null,
                                rowHeaders
                            )
                        )
                    );
                }
            });

            module.exports.PivotTableDataCells = React.createClass({
                displayName: "PivotTableDataCells",
                render: function() {
                    var self = this;
                    var PivotRow = comps.PivotRow;

                    var pgridwidget = this.props.pivotTableComp.pgridwidget;
                    var layoutInfos = {
                        lastLeftMostCellVSpan: 0,
                        topMostCells: {}
                    };

                    var dataCells = pgridwidget.dataRows.map(function(dataRow, index) {
                        return React.createElement(PivotRow, {
                            key: index,
                            row: dataRow,
                            axetype: axe.Type.DATA,
                            layoutInfos: layoutInfos,
                            pivotTableComp: self.props.pivotTableComp
                        });
                    });

                    return React.createElement("table", {
                            className: "inner-table"
                        },
                        React.createElement("colgroup", null),
                        React.createElement("tbody", null,
                            dataCells
                        )
                    );
                }
            });

            var scrollBarMixin = {
                scrollEvent: null,
                scrollClient: null,
                getInitialState: function() {
                    // initial state, all zero.
                    return {
                        size: 16,
                        mousedown: false,
                        thumbOffset: 0
                    };
                },
                componentDidMount: function() {
                    this.scrollEvent = new ScrollEvent(this);
                },
                componentDidUpdate: function() {
                    if (!this.state.mousedown) {
                        // mouse not down, don't care about mouse up/move events.
                        document.removeEventListener('mousemove', this.onMouseMove);
                        document.removeEventListener('mouseup', this.onMouseUp);
                    } else if (this.state.mousedown) {
                        // mouse down, interested by mouse up/move events.
                        document.addEventListener('mousemove', this.onMouseMove);
                        document.addEventListener('mouseup', this.onMouseUp);
                    }
                },
                componentWillUnmount: function() {
                    document.removeEventListener('mousemove', this.onMouseMove);
                    document.removeEventListener('mouseup', this.onMouseUp);
                },
                onMouseDown: function(e) {
                    // drag with left mouse button
                    if (e.button !== 0) return;

                    var thumbElem = this.refs.scrollThumb;
                    var thumbposInParent = reactUtils.getParentOffset(thumbElem);

                    reactUtils.addClass(thumbElem, 'orb-scrollthumb-hover');

                    // inform mousedown, save start pos
                    this.setState({
                        mousedown: true,
                        mouseoffset: e[this.mousePosProp],
                        thumbOffset: thumbposInParent[this.posProp]
                    });

                    // prevent event bubbling (to prevent text selection while dragging for example)
                    e.stopPropagation();
                    e.preventDefault();
                },
                onMouseUp: function() {

                    if (this.state.mousedown) {
                        var thumbElem = this.refs.scrollThumb;
                        reactUtils.removeClass(thumbElem, 'orb-scrollthumb-hover');
                    }

                    this.setState({
                        mousedown: false
                    });
                },
                onMouseMove: function(e) {

                    // if the mouse is not down while moving, return (no drag)
                    if (!this.state.mousedown) return;

                    e.stopPropagation();
                    e.preventDefault();

                    var amount = e[this.mousePosProp] - this.state.mouseoffset;
                    this.state.mouseoffset = e[this.mousePosProp];

                    this.scroll(amount);
                },
                getScrollSize: function() {
                    if (this.scrollClient != null) {
                        return reactUtils.getSize(this.scrollClient)[this.sizeProp];
                    } else {
                        return reactUtils.getSize(this)[this.sizeProp];
                    }
                },
                setScrollClient: function(scrollClient, scrollCallback) {
                    this.scrollClient = scrollClient;
                    this.scrollEvent.callback = scrollCallback;
                },
                getScrollPercent: function() {
                    var maxOffset = this.getScrollSize() - this.state.size;
                    return maxOffset <= 0 ? 0 : this.state.thumbOffset / maxOffset;
                },
                refresh: function() {
                    if (this.scrollClient) {
                        var scrolledElement = this.scrollClient.children[0];

                        var clientSize = reactUtils.getSize(this.scrollClient);
                        var elementSize = reactUtils.getSize(scrolledElement);

                        var scrollBarContainerSize = this.getScrollSize();
                        var newSize = clientSize[this.sizeProp] >= elementSize[this.sizeProp] ? 0 : (clientSize[this.sizeProp] / elementSize[this.sizeProp]) * scrollBarContainerSize;

                        this.setState({
                                containerSize: scrollBarContainerSize,
                                size: newSize,
                                thumbOffset: Math.min(this.state.thumbOffset, scrollBarContainerSize - newSize)
                            },
                            this.scrollEvent.raise
                        );

                    }
                },
                scroll: function(amount, mode) {
                    if (this.state.size > 0) {
                        if (mode == 1) amount *= 8;

                        var maxOffset = this.getScrollSize() - this.state.size;
                        var newOffset = this.state.thumbOffset + amount;
                        if (newOffset < 0) newOffset = 0;
                        if (newOffset > maxOffset) newOffset = maxOffset;

                        this.setState({
                                thumbOffset: newOffset
                            },
                            this.scrollEvent.raise
                        );
                        return true;
                    }
                    return false;
                },
                onWheel: function(e) {
                    this.scroll(e.deltaY, e.deltaMode);
                    e.stopPropagation();
                    e.preventDefault();
                },
                render: function() {
                    var self = this;

                    var thumbStyle = {
                        padding: 0
                    };
                    thumbStyle[this.sizeProp] = this.state.size;
                    thumbStyle[this.offsetCssProp] = this.state.thumbOffset;

                    var thisStyle = {};
                    thisStyle[this.sizeProp] = this.state.containerSize;

                    var thumbClass = "orb-scrollthumb " + this.props.pivotTableComp.pgrid.config.theme.getButtonClasses().scrollBar;

                    var scrollThumb = this.state.size <= 0 ?
                        null :
                        React.createElement("div", {
                            className: thumbClass,
                            style: thumbStyle,
                            ref: "scrollThumb",
                            onMouseDown: this.onMouseDown
                        });

                    return React.createElement("div", {
                            className: this.cssClass,
                            style: thisStyle,
                            onWheel: this.onWheel
                        },
                        scrollThumb
                    );
                }
            };

            function ScrollEvent(scrollBarComp) {
                var self = this;
                this.scrollBarComp = scrollBarComp;
                this.callback = null;
                this.raise = function() {
                    if (self.callback) {
                        self.callback(self.scrollBarComp.getScrollPercent());
                    }
                };
            }

            module.exports.HorizontalScrollBar = React.createClass({
                displayName: "HorizontalScrollBar",
                mixins: [scrollBarMixin],
                posProp: 'x',
                mousePosProp: 'pageX',
                sizeProp: 'width',
                offsetCssProp: 'left',
                cssClass: 'orb-h-scrollbar'
            });

            module.exports.VerticalScrollBar = React.createClass({
                displayName: "VerticalScrollBar",
                mixins: [scrollBarMixin],
                posProp: 'y',
                mousePosProp: 'pageY',
                sizeProp: 'height',
                offsetCssProp: 'top',
                cssClass: 'orb-v-scrollbar'
            });

            module.exports.FilterPanel = React.createClass({
                displayName: "FilterPanel",
                pgridwidget: null,
                values: null,
                filterManager: null,
                getInitialState: function() {
                    this.pgridwidget = this.props.pivotTableComp.pgridwidget;
                    return {};
                },
                destroy: function() {
                    var container = this.refs.filterPanel.parentNode;
                    ReactDom.unmountComponentAtNode(container);
                    container.parentNode.removeChild(container);
                },
                onFilter: function(operator, term, staticValue, excludeStatic) {
                    this.props.pivotTableComp.applyFilter(this.props.field, operator, term, staticValue, excludeStatic);
                    this.destroy();
                },
                onMouseDown: function(e) {
                    var container = this.parentNode;
                    var target = e.target;
                    while (target != null) {
                        if (target == container) {
                            return true;
                        }
                        target = target.parentNode;
                    }
                },
                onMouseWheel: function(e) {
                    var valuesTable = this.refs.valuesTable;
                    var target = e.target;
                    while (target != null) {
                        if (target == valuesTable) {
                            if (valuesTable.scrollHeight <= valuesTable.clientHeight) {
                                e.stopPropagation();
                                e.preventDefault();
                            }
                            return;
                        }
                        target = target.parentNode;
                    }

                    this.destroy();
                },
                componentWillMount: function() {
                    document.addEventListener('mousedown', this.onMouseDown);
                    document.addEventListener('wheel', this.onMouseWheel);
                    window.addEventListener('resize', this.destroy);
                },
                componentDidMount: function() {
                    this.filterManager.init(this.refs.filterPanel);
                },
                componentWillUnmount: function() {
                    document.removeEventListener('mousedown', this.onMouseDown);
                    document.removeEventListener('wheel', this.onMouseWheel);
                    window.removeEventListener('resize', this.destroy);
                },
                render: function() {
                    var Dropdown = comps.Dropdown;
                    var checkboxes = [];

                    this.filterManager = new FilterManager(this, this.pgridwidget.pgrid.getFieldFilter(this.props.field));
                    this.values = this.pgridwidget.pgrid.getFieldValues(this.props.field);

                    function addCheckboxRow(value, text) {
                        return checkboxes.push(React.createElement("tr", {
                                key: value
                            },
                            React.createElement("td", {
                                    className: "fltr-chkbox"
                                },
                                React.createElement("div", {
                                        className: "field"
                                    },
                                    React.createElement("div", {
                                            className: "ui checkbox"
                                        },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            value: value,
                                            defaultChecked: "checked"
                                        }),
                                        React.createElement("label", {
                                            title: text || value
                                        }, text || value)
                                    )
                                )
                            )
                        ));
                    }

                    addCheckboxRow(filtering.ALL, '(Show All)');
                    if (this.values.containsBlank) {
                        addCheckboxRow(filtering.BLANK, '(Blank)');
                    }

                    for (var i = 0; i < this.values.length; i++) {
                        addCheckboxRow(this.values[i]);
                    }

                    var buttonClass = this.props.pivotTableComp.pgrid.config.theme.getButtonClasses().orbButton;
                    var pivotStyle = window.getComputedStyle(this.props.pivotTableComp.refs.pivotWrapperTable, null);
                    var style = {
                        fontFamily: pivotStyle.getPropertyValue('font-family'),
                        fontSize: pivotStyle.getPropertyValue('font-size')
                    };

                    var currentFilter = this.pgridwidget.pgrid.getFieldFilter(this.props.field);

                    return React.createElement("div", {
                            ref: "filterPanel",
                            className: "ui container filter-panel",
                            style: style
                        },
                        React.createElement("div", {
                                className: "form"
                            },
                            React.createElement("div", {
                                    className: "field"
                                },
                                React.createElement(Dropdown, {
                                    values: [
                                        filtering.Operators.MATCH.name,
                                        filtering.Operators.NOTMATCH.name,
                                        filtering.Operators.EQ.name,
                                        filtering.Operators.NEQ.name,
                                        filtering.Operators.GT.name,
                                        filtering.Operators.GTE.name,
                                        filtering.Operators.LT.name,
                                        filtering.Operators.LTE.name
                                    ],
                                    selectedValue: currentFilter && currentFilter.operator ? currentFilter.operator.name : filtering.Operators.MATCH.name,
                                    onValueChanged: this.filterManager.onOperatorChanged
                                })
                            ),
                            React.createElement("div", {
                                    className: "field"
                                },
                                React.createElement("div", {
                                        className: "ui fluid icon input"
                                    },
                                    React.createElement("i", {
                                        className: "search icon"
                                    }),
                                    React.createElement("input", {
                                        type: "text",
                                        className: "search-field",
                                        placeholder: "Search..."
                                    })
                                )
                            )
                        ),

                        React.createElement("div", {
                                className: "ui segment"
                            },
                            React.createElement("table", {
                                    className: "fltr-vals-tbl",
                                    ref: "valuesTable"
                                },
                                React.createElement("tbody", null,
                                    checkboxes
                                )
                            )
                        ),

                        React.createElement("div", {
                                className: "form"
                            },
                            React.createElement("input", {
                                type: "button",
                                className: "ui blue mini button",
                                value: "Ok"
                            }),
                            React.createElement("input", {
                                type: "button",
                                className: "ui red mini button",
                                value: "Cancel"
                            })
                        )
                    )
                }
            });

            function FilterManager(reactComp, initialFilterObject) {

                var self = this;
                var INDETERMINATE = 'indeterminate';

                var savedCheckedValues;
                var isSearchMode = false;
                var isRegexMode = false;
                var operator = filtering.Operators.MATCH;
                var lastSearchTerm = '';

                var elems = {
                    filterContainer: null,
                    checkboxes: {},
                    searchBox: null,
                    operatorBox: null,
                    allCheckbox: null,
                    addCheckbox: null,
                    enableRegexButton: null,
                    clearSearchButton: null,
                    okButton: null,
                    cancelButton: null,
                    resizeGrip: null
                };

                var resizeManager;

                this.init = function(filterContainerElement) {

                    elems.filterContainer = filterContainerElement;

                    elems.checkboxes = {};
                    elems.searchBox = elems.filterContainer.children[0].children[1].children[0].children[1];
                    elems.clearSearchButton = null; //elems.filterContainer.rows[0].cells[2].children[0].rows[0].cells[1].children[0];
                    elems.operatorBox = elems.filterContainer.children[0].children[0].children[0];
                    elems.okButton = elems.filterContainer.children[2].children[0];
                    elems.cancelButton = elems.filterContainer.children[2].children[1];
                    elems.resizeGrip = null; //elems.filterContainer.rows[2].cells[1].children[0];

                    var rows = elems.filterContainer.children[1].children[0].rows;
                    for (var i = 0; i < rows.length; i++) {
                        var checkbox = rows[i].cells[0].children[0].children[0].children[0];
                        elems.checkboxes[checkbox.value] = checkbox;
                    }

                    elems.allCheckbox = elems.checkboxes[filtering.ALL];
                    elems.addCheckbox = null;
                    //elems.enableRegexButton = elems.filterContainer.rows[0].cells[1];

                    resizeManager = null //new ResizeManager(elems.filterContainer.parentNode, elems.filterContainer.rows[1].cells[0].children[0], elems.resizeGrip);

                    applyInitialFilterObject();
                    addEventListeners();
                };

                this.onOperatorChanged = function(newOperator) {
                    if (operator.name !== newOperator) {
                        operator = filtering.Operators.get(newOperator);
                        self.toggleRegexpButtonVisibility();
                        self.searchChanged('operatorChanged');
                    }
                };

                function checkboxVisible(checkbox, isVisible) {
                    if (isVisible != null) {
                        checkbox.parentNode.parentNode.style.display = isVisible ? '' : 'none';
                    } else {
                        return checkbox.parentNode.parentNode.style.display != 'none';
                    }
                }

                function applyInitialFilterObject() {
                    if (initialFilterObject) {
                        var staticInfos = {
                            values: initialFilterObject.staticValue,
                            toExclude: initialFilterObject.excludeStatic
                        };

                        if (initialFilterObject.term) {
                            isSearchMode = true;

                            operator = initialFilterObject.operator;
                            self.toggleRegexpButtonVisibility();

                            if (initialFilterObject.regexpMode) {
                                isRegexMode = true;
                                self.toggleRegexpButtonState();
                                lastSearchTerm = initialFilterObject.term.source;
                            } else {
                                lastSearchTerm = initialFilterObject.term;
                            }

                            elems.searchBox.value = lastSearchTerm;

                            self.applyFilterTerm(initialFilterObject.operator, initialFilterObject.term);
                        } else {
                            savedCheckedValues = staticInfos;
                        }

                        self.updateCheckboxes(staticInfos);
                        self.updateAllCheckbox();
                    }
                }

                function addEventListeners() {
                    self.toggleRegexpButtonVisibility();

                    elems.filterContainer.addEventListener('click', self.valueChecked);
                    elems.searchBox.addEventListener('keyup', self.searchChanged);

                    //elems.clearSearchButton.addEventListener('click', self.clearSearchBox);

                    elems.okButton.addEventListener('click', function() {
                        var checkedObj = self.getCheckedValues();
                        reactComp.onFilter(operator.name, operator.regexpSupported && isSearchMode && isRegexMode ? new RegExp(lastSearchTerm, 'i') : lastSearchTerm, checkedObj.values, checkedObj.toExclude);
                    });
                    elems.cancelButton.addEventListener('click', function() {
                        reactComp.destroy();
                    });
                }

                function ResizeManager(outerContainerElem, valuesTableElem, resizeGripElem) {

                    var minContainerWidth = 301;
                    var minContainerHeight = 223;

                    var mousedownpos = {
                        x: 0,
                        y: 0
                    };
                    var isMouseDown = false;

                    this.resizeMouseDown = function(e) {
                        // drag/sort with left mouse button
                        if (e.button !== 0) return;

                        isMouseDown = true;
                        document.body.style.cursor = 'se-resize';

                        mousedownpos.x = e.pageX;
                        mousedownpos.y = e.pageY;

                        // prevent event bubbling (to prevent text selection while dragging for example)
                        e.stopPropagation();
                        e.preventDefault();
                    };

                    this.resizeMouseUp = function() {
                        isMouseDown = false;
                        document.body.style.cursor = 'auto';
                        return true;
                    };

                    this.resizeMouseMove = function(e) {
                        // if the mouse is not down while moving, return (no drag)
                        if (!isMouseDown) return;

                        var resizeGripSize = resizeGripElem.getBoundingClientRect();
                        var outerContainerSize = outerContainerElem.getBoundingClientRect();
                        var valuesTableSize = valuesTableElem.getBoundingClientRect();

                        var outerContainerWidth = outerContainerSize.right - outerContainerSize.left;
                        var outerContainerHeight = outerContainerSize.bottom - outerContainerSize.top;

                        var offset = {
                            x: outerContainerWidth <= minContainerWidth && e.pageX < resizeGripSize.left ? 0 : e.pageX - mousedownpos.x,
                            y: outerContainerHeight <= minContainerHeight && e.pageY < resizeGripSize.top ? 0 : e.pageY - mousedownpos.y
                        };

                        var newContainerWidth = outerContainerWidth + offset.x;
                        var newContainerHeight = outerContainerHeight + offset.y;

                        mousedownpos.x = e.pageX;
                        mousedownpos.y = e.pageY;

                        if (newContainerWidth >= minContainerWidth) {
                            outerContainerElem.style.width = newContainerWidth + 'px';
                        }

                        if (newContainerHeight >= minContainerHeight) {
                            outerContainerElem.style.height = newContainerHeight + 'px';
                            valuesTableElem.style.height = (valuesTableSize.bottom - valuesTableSize.top + offset.y) + 'px';
                        }

                        e.stopPropagation();
                        e.preventDefault();
                    };

                    resizeGripElem.addEventListener('mousedown', this.resizeMouseDown);
                    document.addEventListener('mouseup', this.resizeMouseUp);
                    document.addEventListener('mousemove', this.resizeMouseMove);
                }

                this.clearSearchBox = function() {
                    elems.searchBox.value = '';
                    self.searchChanged();
                };

                this.toggleRegexpButtonVisibility = function() {

                };

                this.toggleRegexpButtonState = function() {

                };

                this.regexpActiveChanged = function() {
                    isRegexMode = !isRegexMode;
                    self.toggleRegexpButtonState();
                    self.searchChanged('regexModeChanged');
                };

                this.valueChecked = function(e) {
                    var target = e.target;
                    if (target && target.type && target.type === 'checkbox') {
                        if (target == elems.allCheckbox) {
                            self.updateCheckboxes({
                                values: elems.allCheckbox.checked
                            });
                        } else {
                            self.updateAllCheckbox();
                        }
                    }
                };

                this.applyFilterTerm = function(operator, term) {
                    var defaultVisible = term ? false : true;
                    var opterm = operator.regexpSupported && isSearchMode ? (isRegexMode ? term : utils.escapeRegex(term)) : term;
                    checkboxVisible(elems.allCheckbox, defaultVisible);
                    for (var i = 0; i < reactComp.values.length; i++) {
                        var val = reactComp.values[i];
                        var checkbox = elems.checkboxes[val];
                        var visible = !isSearchMode || operator.func(val, opterm);
                        checkboxVisible(checkbox, visible);
                        checkbox.checked = visible;
                    }
                };

                this.searchChanged = function(e) {
                    var search = (elems.searchBox.value || '').trim();
                    if (e === 'operatorChanged' || (e === 'regexModeChanged' && search) || search != lastSearchTerm) {
                        lastSearchTerm = search;

                        var previousIsSearchMode = isSearchMode;
                        isSearchMode = search !== '';

                        if (isSearchMode && !previousIsSearchMode) {
                            savedCheckedValues = self.getCheckedValues();
                        }

                        var searchTerm = operator.regexpSupported && isSearchMode ? new RegExp(isRegexMode ? search : utils.escapeRegex(search), 'i') : search;
                        if (e !== 'operatorChanged' || isSearchMode) {
                            self.applyFilterTerm(operator, search);
                        }

                        if (!isSearchMode && previousIsSearchMode) {
                            self.updateCheckboxes(savedCheckedValues);
                        }

                        self.updateAllCheckbox();
                    }
                };

                this.getCheckedValues = function() {
                    if (!isSearchMode && !elems.allCheckbox.indeterminate) {
                        return {
                            values: elems.allCheckbox.checked ? filtering.ALL : filtering.NONE,
                            toExclude: false
                        };
                    } else {
                        var staticValue;
                        var i,
                            val,
                            checkbox;
                        var valuesCount = 0,
                            checkedCount = 0;

                        for (i = 0; i < reactComp.values.length; i++) {
                            val = reactComp.values[i];
                            checkbox = elems.checkboxes[val];
                            if (checkboxVisible(checkbox)) {
                                valuesCount++;
                                if (checkbox.checked) {
                                    checkedCount++;
                                }
                            }
                        }

                        var excludeUnchecked = false;

                        if (checkedCount === 0) {
                            staticValue = filtering.NONE;
                        } else if (checkedCount == valuesCount) {
                            staticValue = filtering.ALL;
                        } else {
                            staticValue = [];
                            excludeUnchecked = checkedCount > (valuesCount / 2 + 1);

                            for (i = 0; i < reactComp.values.length; i++) {
                                val = reactComp.values[i];
                                checkbox = elems.checkboxes[val];
                                if (checkboxVisible(checkbox)) {
                                    if ((!excludeUnchecked && checkbox.checked) || (excludeUnchecked && !checkbox.checked)) {
                                        staticValue.push(val);
                                    }
                                }
                            }
                        }
                        return {
                            values: staticValue,
                            toExclude: excludeUnchecked
                        };
                    }
                };

                this.updateCheckboxes = function(checkedList) {
                    var values = checkedList ? checkedList.values : null;
                    var allchecked = utils.isArray(values) ?
                        null :
                        (values == null || values === filtering.ALL ?
                            true :
                            (values === filtering.NONE ?
                                false :
                                !!values
                            )
                        );
                    for (var i = 0; i < reactComp.values.length; i++) {
                        var val = reactComp.values[i];
                        var checkbox = elems.checkboxes[val];
                        if (checkboxVisible(checkbox)) {
                            if (allchecked != null) {
                                checkbox.checked = allchecked;
                            } else {
                                var valInList = values.indexOf(val) >= 0;
                                checkbox.checked = checkedList.toExclude ? !valInList : valInList;
                            }
                        }
                    }
                };

                this.updateAllCheckbox = function() {
                    if (!isSearchMode) {
                        var allchecked = null;
                        for (var i = 0; i < reactComp.values.length; i++) {
                            var checkbox = elems.checkboxes[reactComp.values[i]];
                            if (allchecked == null) {
                                allchecked = checkbox.checked;
                            } else {
                                if (allchecked !== checkbox.checked) {
                                    allchecked = INDETERMINATE;
                                    break;
                                }
                            }
                        }

                        if (allchecked === INDETERMINATE) {
                            elems.allCheckbox.indeterminate = true;
                            elems.allCheckbox.checked = false;
                        } else {
                            elems.allCheckbox.indeterminate = false;
                            elems.allCheckbox.checked = allchecked;
                        }
                    }
                };
            }

            module.exports.Dropdown = React.createClass({
                displayName: "Dropdown",
                openOrClose: function(e) {
                    var valueNode = this.refs.valueElement;
                    var valuesListNode = this.refs.valuesList;
                    if (e.target === valueNode && valuesListNode.style.display === 'none') {
                        valuesListNode.style.display = 'block';
                    } else {
                        valuesListNode.style.display = 'none';
                    }
                },
                onMouseEnter: function() {
                    var valueNode = this.refs.valueElement;
                    valueNode.className = "orb-tgl-btn-down";
                    valueNode.style.backgroundPosition = 'right center';
                },
                onMouseLeave: function() {
                    this.refs.valueElement.className = "";
                },
                componentDidMount: function() {
                    document.addEventListener('click', this.openOrClose);
                },
                componentWillUnmount: function() {
                    document.removeEventListener('click', this.openOrClose);
                },
                selectValue: function(e) {
                    var listNode = this.refs.valuesList;
                    var target = e.target;
                    var isli = false;
                    while (!isli && target != null) {
                        if (target.parentNode == listNode) {
                            isli = true;
                            break;
                        }
                        target = target.parentNode;
                    }

                    if (isli) {
                        var value = target.textContent;
                        var valueElement = this.refs.valueElement;
                        if (valueElement.textContent != value) {
                            valueElement.textContent = value;
                            if (this.props.onValueChanged) {
                                this.props.onValueChanged(value);
                            }
                        }
                    }
                },
                render: function() {
                    function createSelectValueFunc(value) {
                        return function() {
                            this.selectValue(value);
                        };
                    }

                    var values = [];
                    for (var i = 0; i < this.props.values.length; i++) {
                        values.push(React.createElement("li", {
                            key: 'item' + i,
                            dangerouslySetInnerHTML: {
                                __html: this.props.values[i]
                            }
                        }));
                    }

                    return React.createElement("div", {
                            className: "orb-select"
                        },
                        React.createElement("div", {
                            ref: "valueElement",
                            dangerouslySetInnerHTML: {
                                __html: this.props.selectedValue
                            },
                            onMouseEnter: this.onMouseEnter,
                            onMouseLeave: this.onMouseLeave
                        }),
                        React.createElement("ul", {
                                ref: "valuesList",
                                style: {
                                    display: 'none'
                                },
                                onClick: this.selectValue
                            },
                            values
                        )
                    );
                }
            });

            module.exports.Grid = React.createClass({
                displayName: "Grid",
                render: function() {
                    var data = this.props.data;
                    var headers = this.props.headers;
                    var tableClasses = this.props.theme.getGridClasses();

                    var rows = [];

                    if (headers && headers.length > 0) {
                        var headerRow = [];
                        for (var h = 0; h < headers.length; h++) {
                            headerRow.push(React.createElement("th", {
                                key: 'h' + h
                            }, headers[h]));
                        }
                        rows.push(React.createElement("tr", {
                            key: 'h'
                        }, headerRow));
                    }

                    if (data && data.length > 0) {
                        for (var i = 0; i < data.length; i++) {
                            var row = [];
                            if (utils.isArray(data[i])) {
                                for (var j = 0; j < data[i].length; j++) {
                                    row.push(React.createElement("td", {
                                        key: i + '' + j
                                    }, data[i][j]));
                                }
                            } else {
                                for (var prop in data[i]) {
                                    if (data[i].hasOwnProperty(prop)) {
                                        row.push(React.createElement("td", {
                                            key: i + '' + prop
                                        }, data[i][prop]));
                                    }
                                }
                            }
                            rows.push(React.createElement("tr", {
                                key: i
                            }, row));
                        }
                    }

                    return React.createElement("table", {
                            className: tableClasses.table
                        },
                        React.createElement("tbody", null,
                            rows
                        )
                    );
                }
            });

            function createOverlay() {
                var overlayElement = document.createElement('div');
                overlayElement.className = 'orb-overlay orb-overlay-hidden';
                document.body.appendChild(overlayElement);
                return overlayElement;
            }

            var Dialog = module.exports.Dialog = React.createClass({
                displayName: "Dialog",
                statics: {
                    create: function() {
                        var dialogFactory = React.createFactory(Dialog);
                        var overlay = createOverlay();

                        return {
                            show: function(props) {
                                ReactDom.render(dialogFactory(props), overlay);
                            }
                        };
                    }
                },
                overlayElement: null,
                setOverlayClass: function(visible) {
                    this.overlayElement.className = this.props.theme.getDialogClasses(visible).overlay;
                },
                componentDidMount: function() {
                    this.overlayElement = this.refs.dialog.parentNode;
                    this.setOverlayClass(true);
                    this.overlayElement.addEventListener('click', this.close);

                    var dialogElement = this.overlayElement.children[0];
                    var dialogBodyElement = dialogElement.children[0].children[1];

                    var screenWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                    var screenHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                    var maxHeight = 2 * screenHeight / 3;
                    maxHeight = maxHeight < 301 ? 301 : maxHeight;
                    var dWidth = dialogElement.offsetWidth + (dialogElement.offsetHeight > maxHeight ? 11 : 0);
                    var dHeight = dialogElement.offsetHeight > maxHeight ? maxHeight : dialogElement.offsetHeight;

                    dialogElement.style.top = (screenHeight > dHeight ? (screenHeight - dHeight) / 2 : 0) + 'px';
                    dialogElement.style.left = (screenWidth > dWidth ? (screenWidth - dWidth) / 2 : 0) + 'px';
                    dialogElement.style.height = dHeight + 'px';
                    dialogBodyElement.style.width = dWidth + 'px';
                    dialogBodyElement.style.height = (dHeight - 45) + 'px';
                },
                close: function(e) {
                    if (e.target == this.overlayElement || e.target.className === 'button-close') {
                        this.overlayElement.removeEventListener('click', this.close);
                        ReactDom.unmountComponentAtNode(this.overlayElement);
                        this.setOverlayClass(false);
                    }
                },
                render: function() {
                    if (this.props.comp) {
                        var comp = React.createElement(this.props.comp.type, this.props.comp.props);
                        var classes = this.props.theme.getDialogClasses();

                        return React.createElement("div", {
                                ref: "dialog",
                                className: classes.dialog,
                                style: this.props.style || {}
                            },
                            React.createElement("div", {
                                    className: classes.content
                                },
                                React.createElement("div", {
                                    className: classes.header
                                }, React.createElement("div", {
                                    className: "button-close",
                                    onClick: this.close
                                }), React.createElement("div", {
                                    className: classes.title
                                }, this.props.title)),
                                React.createElement("div", {
                                        className: classes.body
                                    },
                                    comp
                                )
                            )
                        );
                    }
                }
            });

            module.exports.Toolbar = React.createClass({
                displayName: "Toolbar",
                _toInit: [],
                componentDidMount: function() {
                    for (var i = 0; i < this._toInit.length; i++) {
                        var btn = this._toInit[i];
                        btn.init(this.props.pivotTableComp, this.refs[btn.ref]);
                    }
                },
                componentDidUpdate: function() {
                    for (var i = 0; i < this._toInit.length; i++) {
                        var btn = this._toInit[i];
                        btn.init(this.props.pivotTableComp, this.refs[btn.ref]);
                    }
                },
                createCallback: function(action) {
                    if (action != null) {
                        var pgridComponent = this.props.pivotTableComp;
                        return function(e) {
                            action(pgridComponent, e.target);
                        };
                    }
                    return null;
                },
                render: function() {

                    var config = this.props.pivotTableComp.pgridwidget.pgrid.config;

                    if (config.toolbar && config.toolbar.visible) {

                        var configButtons = config.toolbar.buttons ?
                            defaultToolbarConfig.buttons.concat(config.toolbar.buttons) :
                            defaultToolbarConfig.buttons;

                        var buttons = [];
                        for (var i = 0; i < configButtons.length; i++) {
                            var btnConfig = configButtons[i];
                            var refName = 'btn' + i;

                            if (btnConfig.type == 'separator') {} else if (btnConfig.type == 'label') {
                                buttons.push(React.createElement("div", {
                                    key: i,
                                    className: "header item"
                                }, btnConfig.text));
                            } else {
                                buttons.push(React.createElement("div", {
                                    key: i,
                                    className: 'orb-tlbr-btn ' + btnConfig.cssClass,
                                    title: btnConfig.tooltip,
                                    ref: refName,
                                    onClick: this.createCallback(btnConfig.action)
                                }));
                            }
                            if (btnConfig.init) {
                                this._toInit.push({
                                    ref: refName,
                                    init: btnConfig.init
                                });
                            }
                        }

                        return React.createElement("div", {
                                className: "ui menu"
                            },
                            buttons
                        );
                    }

                    return React.createElement("div", null);
                }
            });

            var excelExport = _dereq_('../orb.export.excel');

            var defaultToolbarConfig = {
                exportToExcel: function(pgridComponent, button) {
                    var a = document.createElement('a');
                    a.download = "orbpivotgrid.xls";
                    a.href = excelExport(pgridComponent.props.pgridwidget);
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                },
                expandAllRows: function(pgridComponent, button) {
                    pgridComponent.toggleFieldExpansion(axe.Type.ROWS, null, true);
                },
                collapseAllRows: function(pgridComponent, button) {
                    pgridComponent.toggleFieldExpansion(axe.Type.ROWS, null, false);
                },
                expandAllColumns: function(pgridComponent, button) {
                    pgridComponent.toggleFieldExpansion(axe.Type.COLUMNS, null, true);
                },
                collapseAllColumns: function(pgridComponent, button) {
                    pgridComponent.toggleFieldExpansion(axe.Type.COLUMNS, null, false);
                },
                updateSubtotalsButton: function(axetype, pgridComponent, button) {
                    var subTotalsState = pgridComponent.pgridwidget.areSubtotalsVisible(axetype);
                    button.style.display = subTotalsState === null ? 'none' : '';

                    var classToAdd = '';
                    var classToRemove = '';
                    if (subTotalsState) {
                        classToAdd = 'subtotals-visible';
                        classToRemove = 'subtotals-hidden';
                    } else {
                        classToAdd = 'subtotals-hidden';
                        classToRemove = 'subtotals-visible';
                    }

                    reactUtils.removeClass(button, classToRemove);
                    reactUtils.addClass(button, classToAdd);
                },
                initSubtotals: function(axetype) {
                    var self = this;
                    return function(pgridComponent, button) {
                        self.updateSubtotalsButton(axetype, pgridComponent, button);
                    };
                },
                toggleSubtotals: function(axetype) {
                    var self = this;
                    return function(pgridComponent, button) {
                        pgridComponent.toggleSubtotals(axetype);
                        self.updateSubtotalsButton(axetype, pgridComponent, button);
                    };
                },
                updateGrandtotalButton: function(axetype, pgridComponent, button) {
                    var subTotalsState = pgridComponent.pgridwidget.isGrandtotalVisible(axetype);
                    button.style.display = subTotalsState === null ? 'none' : '';

                    var classToAdd = '';
                    var classToRemove = '';
                    if (subTotalsState) {
                        classToAdd = 'grndtotal-visible';
                        classToRemove = 'grndtotal-hidden';
                    } else {
                        classToAdd = 'grndtotal-hidden';
                        classToRemove = 'grndtotal-visible';
                    }

                    reactUtils.removeClass(button, classToRemove);
                    reactUtils.addClass(button, classToAdd);
                },
                initGrandtotal: function(axetype) {
                    var self = this;
                    return function(pgridComponent, button) {
                        self.updateGrandtotalButton(axetype, pgridComponent, button);
                    };
                },
                toggleGrandtotal: function(axetype) {
                    var self = this;
                    return function(pgridComponent, button) {
                        pgridComponent.toggleGrandtotal(axetype);
                        self.updateGrandtotalButton(axetype, pgridComponent, button);
                    };
                }
            };

            defaultToolbarConfig.buttons = [{
                type: 'label',
                text: 'Rows:'
            }, {
                type: 'button',
                tooltip: 'Expand all rows',
                cssClass: 'expand-all',
                action: defaultToolbarConfig.expandAllRows
            }, {
                type: 'button',
                tooltip: 'Collapse all rows',
                cssClass: 'collapse-all',
                action: defaultToolbarConfig.collapseAllRows
            }, {
                type: 'button',
                tooltip: 'Toggle rows sub totals',
                init: defaultToolbarConfig.initSubtotals(axe.Type.ROWS),
                action: defaultToolbarConfig.toggleSubtotals(axe.Type.ROWS)
            }, {
                type: 'button',
                tooltip: 'Toggle rows grand total',
                init: defaultToolbarConfig.initGrandtotal(axe.Type.ROWS),
                action: defaultToolbarConfig.toggleGrandtotal(axe.Type.ROWS)
            }, {
                type: 'separator'
            }, {
                type: 'label',
                text: 'Columns:'
            }, {
                type: 'button',
                tooltip: 'Expand all columns',
                cssClass: 'expand-all',
                action: defaultToolbarConfig.expandAllColumns
            }, {
                type: 'button',
                tooltip: 'Collapse all columns',
                cssClass: 'collapse-all',
                action: defaultToolbarConfig.collapseAllColumns
            }, {
                type: 'button',
                tooltip: 'Toggle columns sub totals',
                init: defaultToolbarConfig.initSubtotals(axe.Type.COLUMNS),
                action: defaultToolbarConfig.toggleSubtotals(axe.Type.COLUMNS)
            }, {
                type: 'button',
                tooltip: 'Toggle columns grand total',
                init: defaultToolbarConfig.initGrandtotal(axe.Type.COLUMNS),
                action: defaultToolbarConfig.toggleGrandtotal(axe.Type.COLUMNS)
            }, {
                type: 'separator'
            }, {
                type: 'label',
                text: 'Export:'
            }, {
                type: 'button',
                tooltip: 'Export to Excel',
                cssClass: 'export-xls',
                action: defaultToolbarConfig.exportToExcel
            }, ];

        }, {
            "../orb.axe": 181,
            "../orb.export.excel": 184,
            "../orb.filtering": 185,
            "../orb.ui.header": 192,
            "../orb.utils": 195,
            "./orb.react.utils": 197,
            "jquery": 25,
            "react": undefined,
            "react-dom": 29
        }],
        197: [function(_dereq_, module, exports) {

            module.exports.forEach = function(list, func, defStop) {
                var ret;
                if (list) {
                    for (var i = 0, l = list.length; i < l; i++) {
                        ret = func(list[i], i);
                        if (ret !== undefined && defStop === true) {
                            break;
                        }
                    }
                }
                return ret;
            };

            module.exports.removeClass = function(element, classname) {
                if (element && classname) {
                    while (element.className.indexOf(classname) >= 0) {
                        element.className = element.className.replace(classname, '');
                    }
                }
            };

            module.exports.addClass = function(element, classname) {
                if (element && classname) {
                    if (element.className.indexOf(classname) < 0) {
                        element.className += ' ' + classname;
                    }
                }
            };

            module.exports.getOffset = function(element) {
                if (element) {
                    var rect = element.getBoundingClientRect();
                    return {
                        x: rect.left,
                        y: rect.top
                    };
                }
                return {
                    x: 0,
                    y: 0
                };
            };

            module.exports.getParentOffset = function(element) {
                if (element) {
                    var rect = element.getBoundingClientRect();
                    var rectParent = element.parentNode != null ? element.parentNode.getBoundingClientRect() : {
                        top: 0,
                        left: 0
                    };
                    return {
                        x: rect.left - rectParent.left,
                        y: rect.top - rectParent.top
                    };
                }
                return {
                    x: 0,
                    y: 0
                };
            };

            module.exports.getSize = function(element) {
                if (element) {
                    var rect = element.getBoundingClientRect();
                    return {
                        width: rect.right - rect.left,
                        height: rect.bottom - rect.top
                    };
                }
                return {
                    width: 0,
                    height: 0
                };
            };

            module.exports.getStyle = function(element, styleProps, keepString) {
                var values = [];
                if (element && styleProps) {
                    var currStyle, f;
                    if (element.currentStyle) {
                        currStyle = element.currentStyle;
                        f = function(prop) {
                            return currStyle[prop];
                        };
                    } else if (window && window.getComputedStyle) {
                        currStyle = window.getComputedStyle(element, null);
                        f = function(prop) {
                            return currStyle.getPropertyValue(prop);
                        };
                    }

                    for (var i = 0; i < styleProps.length; i++) {
                        var val = f(styleProps[i]);
                        values.push(val && keepString !== true ? Math.ceil(parseFloat(val)) : val);
                    }
                }
                return values;
            };

            module.exports.isVisible = function(element) {
                if (element) {
                    return element.style.display !== 'none' && (element.offsetWidth !== 0 || element.offsetHeight !== 0);
                }
                return false;
            };

            module.exports.updateTableColGroup = function(tableNode, widths) {
                if (tableNode) {
                    var colGroupNode = tableNode.firstChild;
                    if (colGroupNode && colGroupNode.nodeName === 'COLGROUP') {
                        tableNode.style.tableLayout = 'auto';
                        tableNode.style.width = '';

                        colGroupNode.innerHTML = '';
                        for (var i = 0; i < widths.length; i++) {
                            var col = document.createElement('col');
                            col.style.width = widths[i] + 'px';
                            colGroupNode.appendChild(col);
                        }
                        tableNode.style.tableLayout = 'fixed';
                    }
                }
            };
        }, {}]
    }, {}, [1])(1)
});
